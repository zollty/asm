<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="generator" content="http://www.nongnu.org/elyxer/"/>
<meta name="create-date" content="2016-12-02"/>
<link rel="stylesheet" href="http://elyxer.nongnu.org/lyx.css" type="text/css" media="all"/>
<title>ASM 4.0A Java bytecode engineering library</title>
</head>
<body>
<div id="globalWrapper">
<h1 class="title">
ASM 4.0<br/>
A Java bytecode engineering library
</h1>
<h2 class="author">
Eric Bruneton
</h2>
<h2 class="Date">
 
</h2>
<div class="Uppertitleback">
Copyright ©~2007, 2011 Eric Bruneton<br/> All rights reserved.<br/> Redistribution and use in source (L<span class="unknown">\kern</span>-.1667em<span class="unknown">\lower</span>.25em<span class="unknown">\hbox</span>Y<span class="unknown">\kern</span>-.125emX<span class="unknown">\@</span> format) and compiled forms (<span class="unknown">\LaTeX</span>, PDF, PostScript, HTML, RTF, etc), with or without modification, are permitted provided that the following conditions are met: <span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
<span class="unknown">\item</span>Redistributionsofsourcecode(L<span class="unknown">\kern</span> − .1667em<span class="unknown">\lower</span>.25em<span class="unknown">\hbox</span>Y<span class="unknown">\kern</span> − .125emX<span class="unknown">\@</span>format)mustretaintheabovecopyrightnotice, thislistofconditionsandthefollowingdisclaimer.<span class="unknown">\item</span>Redistributionsincompiledform(convertedto<span class="unknown">\LaTeX</span>, PDF, PostScript, HTML, RTF, andotherformats)mustreproducetheabovecopyrightnotice, thislistofconditionsandthefollowingdisclaimerinthedocumentationand ⁄ orothermaterialsprovidedwiththedistribution.<span class="unknown">\item</span>Thenameoftheauthormaynotbeusedtoendorseorpromoteproductsderivedfromthisdocumentationwithoutspecificpriorwrittenpermission.
</span>

</span>
</span> THIS DOCUMENTATION IS PROVIDED BY THE AUTHOR ‘‘AS IS’’ AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</div>
<div class="Lowertitleback">
Version 2.0, September 2011
</div>
<div class="Standard">
<span class="unknown">\pagenumbering</span>roman
</div>
<div class="fulltoc">
<div class="tocheader">
Table of Contents
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Chapter-1">Chapter 1: Introduction</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-1.1">Section 1.1: Motivations</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.2">Section 1.2: Overview</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-1.2.1">Subsection 1.2.1: Scope</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-1.2.2">Subsection 1.2.2: Model</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-1.2.3">Subsection 1.2.3: Architecture</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.3">Section 1.3: Organization</a>
</div>
<div class="tocindent">
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsubsection--1">Subsubsection: Typographic conventions</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.4">Section 1.4: Acknowledgments</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Part-I">Part I: Core API</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Chapter-2">Chapter 2: Classes</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-2.1">Section 2.1: Structure</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-2.1.1">Subsection 2.1.1: Overview</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.1.2">Subsection 2.1.2: Internal names</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.1.3">Subsection 2.1.3: Type descriptors</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.1.4">Subsection 2.1.4: Method descriptors</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-2.2">Section 2.2: Interfaces and components</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-2.2.1">Subsection 2.2.1: Presentation</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.2.2">Subsection 2.2.2: Parsing classes</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.2.3">Subsection 2.2.3: Generating classes</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsubsection--2">Subsubsection: Using generated classes</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.2.4">Subsection 2.2.4: Transforming classes</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsubsection--3">Subsubsection: Optimization</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--4">Subsubsection: Using transformed classes</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.2.5">Subsection 2.2.5: Removing class members</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.2.6">Subsection 2.2.6: Adding class members</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.2.7">Subsection 2.2.7: Transformation chains</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-2.3">Section 2.3: Tools</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-2.3.1">Subsection 2.3.1: <tt>Type</tt></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.3.2">Subsection 2.3.2: <tt>TraceClassVisitor</tt></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.3.3">Subsection 2.3.3: <tt>CheckClassAdapter</tt></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.3.4">Subsection 2.3.4: <tt>ASMifier</tt></a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-3">Chapter 3: Methods</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-3.1">Section 3.1: Structure</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.1">Subsection 3.1.1: Execution model</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.2">Subsection 3.1.2: Bytecode instructions</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.3">Subsection 3.1.3: Examples</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.4">Subsection 3.1.4: Exception handlers</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.5">Subsection 3.1.5: Frames</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.2">Section 3.2: Interfaces and components</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-3.2.1">Subsection 3.2.1: Presentation</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsubsection--5">Subsubsection: <tt>ClassWriter</tt> options</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.2.2">Subsection 3.2.2: Generating methods</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.2.3">Subsection 3.2.3: Transforming methods</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.2.4">Subsection 3.2.4: Stateless transformations</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.2.5">Subsection 3.2.5: Statefull transformations</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsubsection--6">Subsubsection: Labels and frames</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--7">Subsubsection: A more complex example</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.3">Section 3.3: Tools</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-3.3.1">Subsection 3.3.1: Basic tools</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsubsection--8">Subsubsection: <tt>Type</tt></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--9">Subsubsection: <tt>TraceClassVisitor</tt></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--10">Subsubsection: <tt>CheckClassAdapter</tt></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--11">Subsubsection: <tt>ASMifier</tt></a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.3.2">Subsection 3.3.2: <tt>AnalyzerAdapter</tt></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.3.3">Subsection 3.3.3: <tt>LocalVariablesSorter</tt></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.3.4">Subsection 3.3.4: <tt>AdviceAdapter</tt></a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-4">Chapter 4: Metadata</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-4.1">Section 4.1: Generics</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-4.1.1">Subsection 4.1.1: Structure</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.1.2">Subsection 4.1.2: Interfaces and components</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.1.3">Subsection 4.1.3: Tools</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.2">Section 4.2: Annotations</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-4.2.1">Subsection 4.2.1: Structure</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.2.2">Subsection 4.2.2: Interfaces and components</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsubsection--12">Subsubsection: Adding, removing and detecting annotations</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.2.3">Subsection 4.2.3: Tools</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.3">Section 4.3: Debug</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.1">Subsection 4.3.1: Structure</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.2">Subsection 4.3.2: Interfaces and components</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsubsection--13">Subsubsection: Ignoring debug information</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.3">Subsection 4.3.3: Tools</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-5">Chapter 5: Backward compatibility</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-5.1">Section 5.1: Introduction</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-5.1.1">Subsection 5.1.1: Backward compatibility contract</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-5.1.2">Subsection 5.1.2: An example</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-5.2">Section 5.2: Guidelines</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-5.2.1">Subsection 5.2.1: Basic rule</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-5.2.2">Subsection 5.2.2: Inheritance rule</a>
</div>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Part-II">Part II: Tree API</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Chapter-6">Chapter 6: Classes</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-6.1">Section 6.1: Interfaces and components</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-6.1.1">Subsection 6.1.1: Presentation</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.1.2">Subsection 6.1.2: Generating classes</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.1.3">Subsection 6.1.3: Adding and removing class members</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-6.2">Section 6.2: Components composition</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-6.2.1">Subsection 6.2.1: Presentation</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.2.2">Subsection 6.2.2: Patterns</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-7">Chapter 7: Methods</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-7.1">Section 7.1: Interfaces and components</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.1">Subsection 7.1.1: Presentation</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.2">Subsection 7.1.2: Generating methods</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.3">Subsection 7.1.3: Transforming methods</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.4">Subsection 7.1.4: Stateless and statefull transformations</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.5">Subsection 7.1.5: Global transformations</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-7.2">Section 7.2: Components composition</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-7.2.1">Subsection 7.2.1: Presentation</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.2.2">Subsection 7.2.2: Patterns</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-8">Chapter 8: Method Analysis</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-8.1">Section 8.1: Presentation</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.1">Subsection 8.1.1: Data flow analyses</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.2">Subsection 8.1.2: Control flow analyses</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-8.2">Section 8.2: Interfaces and components</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.1">Subsection 8.2.1: Basic data flow analysis</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.2">Subsection 8.2.2: Basic data flow verifier</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.3">Subsection 8.2.3: Simple data flow verifier</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.4">Subsection 8.2.4: User defined data flow analysis</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.5">Subsection 8.2.5: Control flow analysis</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-9">Chapter 9: Metadata</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-9.1">Section 9.1: Generics</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-9.2">Section 9.2: Annotations</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-9.3">Section 9.3: Debug</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-10">Chapter 10: Backward compatibility</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-10.1">Section 10.1: Introduction</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-10.2">Section 10.2: Guidelines</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-10.2.1">Subsection 10.2.1: Basic rules</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsubsection--14">Subsubsection: Creating class nodes</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--15">Subsubsection: Using existing class nodes</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-10.2.2">Subsection 10.2.2: Inheritance rules</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-10.2.3">Subsection 10.2.3: Other packages</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-11">Chapter 11: Appendix</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-11.1">Section 11.1: Bytecode instructions</a>
</div>
<div class="tocindent">
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsubsection--16">Subsubsection: Local variables</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--17">Subsubsection: Stack</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--18">Subsubsection: Constants</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--19">Subsubsection: Arithmetic and logic</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--20">Subsubsection: Casts</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--21">Subsubsection: Objects, fields and methods</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--22">Subsubsection: Arrays</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--23">Subsubsection: Jumps</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection--24">Subsubsection: Return</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-11.2">Section 11.2: Subroutines</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-11.3">Section 11.3: Attributes</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-11.4">Section 11.4: Guidelines</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-11.5">Section 11.5: Performances</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#Index">Index</a>
</div>

</div>
<div class="Standard">
<span class="unknown">\cleardoublepage</span><span class="unknown">\pagenumbering</span>arabic
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-1">1</a> Introduction
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-1.1">1.1</a> Motivations
</h2>
<div class="Standard">
Program analysis, generation and transformation are useful techniques that can be used in many situations:
</div>
<ul>
<li>
Program analysis, which can range from a simple syntaxic parsing to a full semantic analysis, can be used to find potential bugs in applications, to detect unused code, to reverse engineer code, etc.
</li>
<li>
Program generation is used in compilers. This include traditional compilers, but also stub or skeleton compilers used for distributed programming, Just in Time compilers, etc.
</li>
<li>
Program transformation can be used to optimize or obfuscate programs, to insert debugging or performance monitoring code into applications, for aspect oriented programming, etc.
</li>

</ul>
<div class="Standard">
All these techniques can be used for any programming language, but this is more or less easy to do, depending on the language. In the case of Java they can be used on Java source code or on compiled Java classes. One of the advantages of working on compiled classes is that, obviously, the source code is not needed. Program transformations can therefore be used on any applications, including closed source and commercial ones. Another advantage of working on compiled code is that it becomes possible to analyze, generate or transform classes at runtime, just before they are loaded into the Java Virtual Machine (generating and compiling source code at runtime is possible, but this is really slow and requires a full Java compiler). The advantage is that tools such as stub compilers or aspect weavers become transparent to users. 
</div>
<div class="Standard">
Due to the many possible usages of program analysis, generation and transformation techniques, many tools to analyze, generate and transform programs have been implemented, for many languages, Java included. ASM is one of these tools for the Java language, designed for <i>runtime</i> — but also offline — class generation and transformation. The ASM<span class="FootOuter"><span class="SupFootMarker"> [A] </span><span class="HoverFoot"><span class="SupFootMarker"> [A] </span>the ASM name does not mean anything: it is just a reference to the <tt>__asm__</tt> keyword in C, which allows some functions to be implemented in assembly language.</span></span> library was therefore designed to work on <i>compiled</i> Java classes. It was also designed to be as <i>fast</i> and as <i>small</i> as possible. Being as fast as possible is important in order not to slow down too much the applications that use ASM at runtime, for dynamic class generation or transformation. And being as small as possible is important in order to be used in memory constrained environments, and to avoid bloating the size of small applications or libraries using ASM.
</div>
<div class="Standard">
ASM is not the only tool for generating and transforming compiled Java classes, but it is one of the most recent and efficient. It can be downloaded from <a href="http://asm.objectweb.org">http://asm.objectweb.org</a>. Its main advantages are the following:
</div>
<ul>
<li>
It has a simple, well designed and modular API that is easy to use.
</li>
<li>
It is well documented and has an associated Eclipse plugin.
</li>
<li>
It provides support for the latest Java version, Java 7.
</li>
<li>
It is small, fast, and very robust.
</li>
<li>
Its large user community can provide support for new users.
</li>
<li>
Its open source license allows you to use it in almost any way you want.
</li>

</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-1.2">1.2</a> Overview
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.2.1">1.2.1</a> Scope
</h3>
<div class="Standard">
The goal of the ASM library is to generate, transform and analyze compiled Java classes, represented as byte arrays (as they are stored on disk and loaded in the Java Virtual Machine). For this purpose ASM provides tools to read, write and transform such byte arrays by using higher level concepts than bytes, such as numeric constants, strings, Java identifiers, Java types, Java class structure elements, etc. Note that the scope of the ASM library is strictly limited to reading, writing, transforming and analyzing classes. In particular the class loading process is out of scope.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.2.2">1.2.2</a> Model
</h3>
<div class="Standard">
The ASM library provides two APIs for generating and transforming compiled classes: the core API<a class="IndexReference" name="entry-core-API-0" href="#index-core-API">↓</a> provides an <i>event based</i> representation<a class="IndexReference" name="entry-classes-event-based-representation-0" href="#index-classes-event-based-representation">↓</a> of classes, while the tree API<a class="IndexReference" name="entry-tree-API-0" href="#index-tree-API">↓</a> provides an <i>object based</i> representation<a class="IndexReference" name="entry-classes-object-based-representation-0" href="#index-classes-object-based-representation">↓</a>.
</div>
<div class="Standard">
With the event based model a class is represented with a sequence of events, each event representing an element of the class, such as its header, a field, a method declaration, an instruction, etc. The event based API defines the set of possible events and the order in which they must occur, and provides a class parser that generates one event per element that is parsed, as well as a class writer that generates compiled classes from sequences of such events.
</div>
<div class="Standard">
With the object based model a class is represented with a tree of objects, each object representing a part of the class, such as the class itself, a field, a method, an instruction, etc. and each object having references to the objects that represent its constituents. The object based API provides a way to convert a sequence of events representing a class to the object tree representing the same class and, vice versa, to convert an object tree to the equivalent event sequence. In other words the object based API is built on top of the event based API.
</div>
<div class="Standard">
These two APIs can be compared to the Simple API for XML (SAX) and Document Object Model (DOM) APIs for XML documents: the event based API is similar to SAX, while the object based API is similar to DOM. The object based API is built on top of the event based one, like DOM can be provided on top of SAX.
</div>
<div class="Standard">
ASM provides both APIs because there is no best API. Indeed each API has its own advantages and drawbacks:
</div>
<ul>
<li>
The event based API is faster and requires less memory than the object based API, since there is no need to create and store in memory a tree of objects representing the class (the same difference also exists between SAX and DOM).
</li>
<li>
However implementing class transformations can be more difficult with the event based API, since only one element of the class is available at any given time (the element that corresponds to the current event), while the whole class is available in memory with the object based API. 
</li>

</ul>
<div class="Standard">
Note that the two APIs manage only one class at a time, and independently of the others: no information about the class hierarchy is maintained, and if a class transformation affects other classes, it is up to the user to modify these other classes.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.2.3">1.2.3</a> Architecture
</h3>
<div class="Standard">
ASM applications have a strong architectural aspect. Indeed the event based API is organized around event producers (the class parser), event consumers (the class writer) and various predefined event filters, to which user defined producers, consumers and filters can be added. Using this API is therefore a two step process:
</div>
<ul>
<li>
assembling event producer, filter and consumer components into possibly complex architectures,
</li>
<li>
and then starting the event producers to run the generation or transformation process.
</li>

</ul>
<div class="Standard">
The object based API also has an architectural aspect: indeed class generator or transformer components that operate on object trees can be composed, the links between them representing the order of transformations.
</div>
<div class="Standard">
Although most component architectures in typical ASM applications are quite simple, it is possible to imagine complex architectures like the following, where arrows represent event based or object based communications between class parsers, writers or transformers, with possible conversions between the event based and object based representations anywhere in the chain<a class="IndexReference" name="entry-transformation-chain-0" href="#index-transformation-chain">↓</a>:
</div>
<div class="Standard">
<div class="center">
<img class="embedded" src="figures/complexchain.png" alt="figure figures/complexchain.png" style="max-width: 410px; max-height: 133px;"/>

</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.3">1.3</a> Organization
</h2>
<div class="Standard">
The ASM library is organized in several packages that are distributed in several <tt>jar</tt> files:
</div>
<ul>
<li>
the <tt>org.objectweb.asm</tt> and <tt>org.objectweb.asm.signature</tt> packages define the event based API and provide the class parser and writer components. They are contained in the <tt>asm.jar</tt> archive.
</li>
<li>
the <tt>org.objectweb.asm.util</tt> package, in the <tt>asm-util.jar</tt> archive, provides various tools based on the core API that can be used during the development and debuging of ASM applications.
</li>
<li>
the <tt>org.objectweb.asm.commons</tt> package provides several useful predefined class transformers, mostly based on the core API. It is contained in the <tt>asm-commons.jar</tt> archive.
</li>
<li>
the <tt>org.objectweb.asm.tree</tt> package, in the <tt>asm-tree.jar</tt> archive, defines the object based API, and provides tools to convert between the event based and the object based representations.
</li>
<li>
the <tt>org.objectweb.asm.tree.analysis</tt> package provides a class analysis framework and several predefined class analyzers, based on the tree API. It is contained in the <tt>asm-analysis.jar</tt> archive.
</li>

</ul>
<div class="Standard">
This document is organized in two parts. The first part covers the core API, i.e. the <tt>asm</tt>, <tt>asm-util</tt> and <tt>asm-commons</tt> archives. The second part covers the tree API, i.e. the <tt>asm-tree</tt> and <tt>asm-analysis</tt> archives. Each part contains at least one chapter for the API related to classes, one chapter for the API related to methods, and one chapter for the API related to annotations, generic types, etc. Each chapter covers the programming interfaces as well as the related tools and predefined components. The source code of all the examples is available on the <a href="http://asm.objectweb.org">ASM web site</a>.
</div>
<div class="Standard">
This organization makes it easier to introduce class file features progressively, but sometimes required to spread the presentation of a single ASM class in several sections. It is therefore recommanded to read this document in sequential order. For a reference guide about the ASM API, please use the <a href="http://asm.objectweb.org/asm30/javadoc/user/overview-summary.html">Javadoc</a>.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--1"></a>Typographic conventions
</h4>
<div class="Standard">
<i>Italic</i> is used for emphasizing elements in a sentence.
</div>
<div class="Standard">
<tt>Constant width</tt> is used for code fragments.
</div>
<div class="Standard">
<tt><b>Bold constant width</b></tt> is used for emphasizing code elements. 
</div>
<div class="Standard">
<tt><i>Italic constant width</i></tt> is used for variable parts in code and for labels.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.4">1.4</a> Acknowledgments
</h2>
<div class="Standard">
I would like to thank François Horn for his valuable remarks during the elaboration of this document, which greatly improved its structure and readability.
</div>
<h1 class="Part">
<a class="toc" name="toc-Part-I">Part I.</a> Core API
</h1>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-2">2</a> Classes<a class="Label" name="cha:Classes"> </a>
</h1>
<div class="Standard">
This chapter explains how to generate and transform compiled Java classes with the core ASM API. It starts with a presentation of compiled classes and then presents the corresponding ASM interfaces, components and tools to generate and transform them, with many illustrative examples. The content of methods, annotations and generics are explained in the next chapters.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.1">2.1</a> Structure
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.1.1">2.1.1</a> Overview<a class="Label" name="sub:Class-Structure-Overview"> </a>
</h3>
<div class="Standard">
The overall structure<a class="IndexReference" name="entry-classes-overall-structure-0" href="#index-classes-overall-structure">↓</a> of a compiled class is quite simple. Indeed, unlike natively compiled applications, a compiled class retains the structural information and almost all the symbols from the source code. In fact a compiled class contains:
</div>
<ul>
<li>
A section describing the modifiers (such as <tt>public</tt> or <tt>private</tt>), the name, the super class, the interfaces and the annotations of the class.
</li>
<li>
One section per field declared in this class. Each section describes the modifiers, the name, the type and the annotations of a field.
</li>
<li>
One section per method <i>and constructor</i> declared in this class. Each section describes the modifiers, the name, the return and parameter types, and the annotations of a method. It also contains the compiled code of the method, in the form of a sequence of Java bytecode instructions.
</li>

</ul>
<div class="Standard">
There are however some differences between source and compiled classes:
</div>
<ul>
<li>
A compiled class describes only one class, while a source file can contain several classes. For instance a source file describing a class with one inner class is compiled in two class files: one for the main class and one for the inner class. However the main class file contains <i>references</i> to its inner classes, and inner classes defined inside methods contain a <i>reference</i> to their enclosing method.
</li>
<li>
A compiled class does not contain comments, of course, but can contain class, field, method and code <i>attributes</i><a class="IndexReference" name="entry-attributes-0" href="#index-attributes">↓</a> that can be used to associate additional information to these elements. Since the introduction of annotations in Java 5, which can be used for the same purpose, attributes have become mostly useless.
</li>
<li>
A compiled class does not contain a <tt>package</tt> and <tt>import</tt> section, so all type names must be fully qualified.
</li>

</ul>
<div class="Standard">
Another very important structural difference is that a compiled class contains a <i>constant pool</i><a class="IndexReference" name="entry-constant-pool-0" href="#index-constant-pool">↓</a> section. This pool is an array containing all the numeric, string and type constants that appear in the class. These constants are defined only once, in the constant pool section, and are referenced by their index in all other sections of the class file. Hopefully ASM hides all the details related to the constant pool, so you will not have to bother about it. Figure <a class="Reference" href="#fig:Overall-structure-of-class-file">2.1↓</a> summarizes the overall structure of a compiled class. The exact structure is described in the Java Virtual Machine Specification, section 4.
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:Overall-structure-of-class-file"> </a><div class="figure">
<div class="center">
<table>
<tr>
<td align="left" valign="top" colspan="2">
Modifiers, name, super class, interfaces
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
Constant pool: numeric, string and type constants
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
Source file name (optional)
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
Enclosing class reference
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
Annotation*
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
Attribute*
</td>

</tr>
<tr>
<td align="left" valign="top">
Inner class*
</td>
<td align="left" valign="top">
Name
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">
Field*
</td>
<td align="left" valign="top" colspan="1">
Modifiers, name, type
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top">
Annotation*
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top" colspan="1">
Attribute*
</td>

</tr>
<tr>
<td align="left" valign="top">
Method*
</td>
<td align="left" valign="top">
Modifiers, name, return and parameter types
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top">
Annotation*
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top">
Attribute*
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top">
Compiled code
</td>

</tr>

</table>

</div>
<div class="caption">
Figure 2.1 Overall structure of a compiled class (* means zero or more)
</div>

</div>

</div>

</div>
<div class="Standard">
Another important difference is that Java types are represented differently in compiled and source classes. The next sections explain their representation in compiled classes.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.1.2">2.1.2</a> Internal names<a class="Label" name="sub:Internal-names"> </a>
</h3>
<div class="Standard">
In many situations a type is constrained to be a class or interface type. For instance the super class of a class, the interfaces implemented by a class, or the exceptions thrown by a method cannot be primitive types or array types, and are necessarily class or interface types. These types are represented in compiled classes with <i>internal names</i><a class="IndexReference" name="entry-internal-name-0" href="#index-internal-name">↓</a>. The internal name of a class is just the fully qualified name of this class, where dots are replaced with slashes. For example the internal name of <tt>String</tt> is <tt>java/lang/String</tt>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.1.3">2.1.3</a> Type descriptors<a class="Label" name="sub:Type-descriptors"> </a>
</h3>
<div class="Standard">
Internal names are used only for types that are constrained to be class or interface types. In all other situations, such as field types, Java types are represented in compiled classes with <i>type descriptors</i><a class="IndexReference" name="entry-type-descriptor-0" href="#index-type-descriptor">↓</a> (see Figure <a class="Reference" href="#fig:Type-descriptors">2.2↓</a>).
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:Type-descriptors"> </a><div class="figure">
<div class="center">
<table>
<tr>
<td align="left" valign="top">
Java type
</td>
<td align="left" valign="top">
Type descriptor
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>boolean</tt>
</td>
<td align="left" valign="top">
<tt>Z</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>char</tt>
</td>
<td align="left" valign="top">
<tt>C</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>byte</tt>
</td>
<td align="left" valign="top">
<tt>B</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>short</tt>
</td>
<td align="left" valign="top">
<tt>S</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>int</tt>
</td>
<td align="left" valign="top">
<tt>I</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>float</tt>
</td>
<td align="left" valign="top">
<tt>F</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>long</tt>
</td>
<td align="left" valign="top">
<tt>J</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>double</tt>
</td>
<td align="left" valign="top">
<tt>D</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>Object</tt>
</td>
<td align="left" valign="top">
<tt>Ljava/lang/Object;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>int[]</tt>
</td>
<td align="left" valign="top">
<tt>[I</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>Object[][]</tt>
</td>
<td align="left" valign="top">
<tt>[[Ljava/lang/Object;</tt>
</td>

</tr>

</table>

</div>
<div class="caption">
Figure 2.2 Type descriptors of some Java types
</div>

</div>

</div>

</div>
<div class="Standard">
The descriptors of the primitive types are single characters: <tt>Z</tt> for <tt>boolean</tt>, <tt>C</tt> for <tt>char</tt>, <tt>B</tt> for <tt>byte</tt>, <tt>S</tt> for <tt>short</tt>, <tt>I</tt> for <tt>int</tt>, <tt>F</tt> for <tt>float</tt>, <tt>J</tt> for <tt>long</tt> and <tt>D</tt> for <tt>double</tt>. The descriptor of a class type is the internal name of this class, preceded by <tt>L</tt> and followed by a semicolon. For instance the type descriptor of <tt>String</tt> is <tt>Ljava/lang/String;</tt>. Finally the descriptor of an array type is a square bracket followed by the descriptor of the array element type.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.1.4">2.1.4</a> Method descriptors
</h3>
<div class="Standard">
A <i>method descriptor</i><a class="IndexReference" name="entry-method-descriptor-0" href="#index-method-descriptor">↓</a> is a list of type descriptors that describe the parameter types and the return type of a method, in a single string. A method descriptor starts with a left parenthesis, followed by the type descriptors of each formal parameter, followed by a right parenthesis, followed by the type descriptor of the return type, or <tt>V</tt> if the method returns <tt>void</tt> (a method descriptor does not contain the method’s name or the argument names). <div class="float">
<a class="Label" name="fig:Sample-method-descriptors"> </a><div class="figure">
<div class="center">
<table>
<tr>
<td align="left" valign="top">
Method declaration in source file
</td>
<td align="left" valign="top">
Method descriptor
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>void m(int i, float f)</tt>
</td>
<td align="left" valign="top">
<tt>(IF)V</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>int m(Object o)</tt>
</td>
<td align="left" valign="top">
<tt>(Ljava/lang/Object;)I</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>int[] m(int i, String s)</tt>
</td>
<td align="left" valign="top">
<tt>(ILjava/lang/String;)[I</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>Object m(int[] i)</tt>
</td>
<td align="left" valign="top">
<tt>([I)Ljava/lang/Object;</tt>
</td>

</tr>

</table>

</div>
<div class="caption">
Figure 2.3 Sample method descriptors
</div>

</div>

</div>

</div>
<div class="Standard">
Once you know how type descriptors work, understanding method descriptors is easy. For instance <tt>(I)I</tt> describes a method that takes one argument of type <tt>int</tt>, and returns an <tt>int</tt>. Figure <a class="Reference" href="#fig:Sample-method-descriptors">2.3↑</a> gives several method descriptor examples.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.2">2.2</a> Interfaces and components<a class="IndexReference" name="entry-classes-core-API-0" href="#index-classes-core-API">↓</a>
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.2.1">2.2.1</a> Presentation<a class="Label" name="sub:Classes-CoreAPI"> </a>
</h3>
<div class="Standard">
The ASM API for generating and transforming compiled classes is based on the <tt>ClassVisitor</tt> abstract class (see Figure <a class="Reference" href="#fig:The-ClassVisitor-interface">2.4↓</a>). Each method in this class corresponds to the class file structure section of the same name (see Figure <a class="Reference" href="#fig:Overall-structure-of-class-file">2.1↑</a>). Simple sections are visited with a single method call whose arguments describe their content, and which returns <tt>void</tt>. Sections whose content can be of arbitrary length and complexity are visited with a initial method call that returns an auxiliary visitor class. This is the case of the <tt>visitAnnotation</tt>, <tt>visitField</tt> and <tt>visitMethod</tt> methods, which return an <tt>AnnotationVisitor</tt>, a <tt>FieldVisitor</tt> and a <tt>MethodVisitor</tt> respectively.
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:The-ClassVisitor-interface"> </a><div class="figure">
<pre class="LyX-Code">
public abstract class <b>ClassVisitor</b> {
  public ClassVisitor(int api);
  public ClassVisitor(int api, ClassVisitor cv);
  public void <b>visit</b>(int version, int access, String name, 
      String signature, String superName, String[] interfaces);
  public void <b>visitSource</b>(String source, String debug);
  public void <b>visitOuterClass</b>(String owner, String name, String desc);
  AnnotationVisitor <b>visitAnnotation</b>(String desc, boolean visible);
  public void <b>visitAttribute</b>(Attribute attr);
  public void <b>visitInnerClass</b>(String name, String outerName,
      String innerName, int access);
  public FieldVisitor <b>visitField</b>(int access, String name, String desc,
      String signature, Object value);
  public MethodVisitor <b>visitMethod</b>(int access, String name, String desc,
      String signature, String[] exceptions);
  void <b>visitEnd</b>();
}
</pre>
<div class="caption">
Figure 2.4 The <tt>ClassVisitor</tt><a class="IndexReference" name="entry-ClassVisitor_-0" href="#index-ClassVisitor_">↓</a> class
</div>

</div>

</div>

</div>
<div class="Standard">
The same principles are used recursively for these auxiliary classes. For example each method in the <tt>FieldVisitor</tt> abstract class (see Figure <a class="Reference" href="#fig:The-FieldVisitor-interface">2.5↓</a>) corresponds to the class file sub structure of the same name, and <tt>visitAnnotation</tt> returns an auxiliary <tt>AnnotationVisitor</tt>, as in <tt>ClassVisitor</tt>. The creation and usage of these auxiliary visitors is explained in the next chapters: indeed this chapter is restricted to simple problems that can be solved with the <tt>ClassVisitor</tt> class alone.
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:The-FieldVisitor-interface"> </a><div class="figure">
<pre class="LyX-Code">
public abstract class <b>FieldVisitor</b> {
  public FieldVisitor(int api);
  public FieldVisitor(int api, FieldVisitor fv);
  public AnnotationVisitor <b>visitAnnotation</b>(String desc, boolean visible);
  public void <b>visitAttribute</b>(Attribute attr);
  public void <b>visitEnd</b>();
}
</pre>
<div class="caption">
Figure 2.5 The <tt>FieldVisitor</tt><a class="IndexReference" name="entry-FieldVisitor_-0" href="#index-FieldVisitor_">↓</a> class
</div>

</div>

</div>

</div>
<div class="Standard">
The methods of the <tt>ClassVisitor</tt> class must be called in the following order, specified in the Javadoc of this class:
</div>
<pre class="LyX-Code">
<tt>visit<span class="unknown">\normalfont</span>~visitSource<span class="unknown">\normalfont</span>?~visitOuterClass<span class="unknown">\normalfont</span>?~(~visitAnnotation<span class="unknown">\normalfont</span>~|~visitAttribute</tt><span class="unknown">\normalfont</span>~)*
<tt><span class="unknown">\normalfont</span>(~visitInnerClass<span class="unknown">\normalfont</span>~|~visitField<span class="unknown">\normalfont</span>~|~visitMethod</tt><span class="unknown">\normalfont</span>~)*
<tt>visitEnd</tt>
</pre>
<div class="Standard">
This means that <tt>visit</tt> must be called first, followed by at most one call to <tt>visitSource</tt>, followed by at most one call to <tt>visitOuterClass</tt>, followed by any number of calls in any order to <tt>visitAnnotation</tt> and <tt>visitAttribute</tt>, followed by any number of calls in any order to <tt>visitInnerClass</tt>, <tt>visitField</tt> and <tt>visitMethod</tt>, and terminated by a single call to <tt>visitEnd</tt>.
</div>
<div class="Standard">
ASM provides three core components based on the <tt>ClassVisitor</tt> API to generate and transform classes:
</div>
<ul>
<li>
The <tt>ClassReader</tt><a class="IndexReference" name="entry-ClassReader_-0" href="#index-ClassReader_">↓</a> class parses a compiled class given as a byte array, and calls the corresponding <tt>visit<i>Xxx</i></tt> methods on the <tt>ClassVisitor</tt> instance passed as argument to its <tt>accept</tt> method. It can be seen as an event producer.
</li>
<li>
The <tt>ClassWriter</tt><a class="IndexReference" name="entry-ClassWriter_-0" href="#index-ClassWriter_">↓</a> class is a subclass of the <tt>ClassVisitor</tt> abstract class that builds compiled classes directly in binary form. It produces as output a byte array containing the compiled class, which can be retrieved with the <tt>toByteArray</tt> method. It can be seen as an event consumer.
</li>
<li>
The <tt>ClassVisitor</tt> class delegates all the method calls it receives to another <tt>ClassVisitor</tt> instance. It can be seen as an event filter.
</li>

</ul>
<div class="Standard">
The next sections show with concrete examples how these components can be used to generate and transform classes.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.2.2">2.2.2</a> Parsing classes<a class="Label" name="sub:Parsing-classes-coreAPI"> </a>
</h3>
<div class="Standard">
The only required component to parse<a class="IndexReference" name="entry-classes-parsing-0" href="#index-classes-parsing">↓</a> an existing class is the <tt>ClassReader</tt> component. Let’s take an example to illustrate this. Suppose that we would like to print the content of a class, in a similar way as the <tt>javap</tt> tool. The first step is to write a subclass of the <tt>ClassVisitor</tt> class that prints information about the classes it visits. Here is a possible, overly simplified implementation:
</div>
<pre class="LyX-Code">
public class <b>ClassPrinter</b> extends <b>ClassVisitor</b> {
  public ClassPrinter() {
    super(ASM4);
  }
  public void visit(int version, int access, String name,
      String signature, String superName, String[] interfaces) {
    <b>System.out.println(name + " extends " + superName + " {");</b>
  }
  public void visitSource(String source, String debug) {
  }
  public void visitOuterClass(String owner, String name, String desc) {
  }
  public AnnotationVisitor visitAnnotation(String desc,
      boolean visible) {
    return null;
  }
  public void visitAttribute(Attribute attr) {
  }
  public void visitInnerClass(String name, String outerName,
      String innerName, int access) {
  }
  public FieldVisitor visitField(int access, String name, String desc,
      String signature, Object value) {
    <b>System.out.println("    " + desc + " " + name);</b>
    return null;
  }
  public MethodVisitor visitMethod(int access, String name,
      String desc, String signature, String[] exceptions) {
    <b>System.out.println("    " + name + desc);</b>
    return null;
  }
  public void visitEnd() {
    <b>System.out.println("}");</b>
  }
}
</pre>
<div class="Standard">
The second step is to combine this <tt>ClassPrinter</tt> with a <tt>ClassReader</tt> component, so that the events produced by the <tt>ClassReader</tt> are consumed by our <tt>ClassPrinter</tt>:
</div>
<pre class="LyX-Code">
ClassPrinter cp = new ClassPrinter();
ClassReader cr = new ClassReader("java.lang.Runnable");
cr.accept(cp, 0);
</pre>
<div class="Standard">
The second line creates a <tt>ClassReader</tt> to parse the <tt>Runnable</tt> class. The <tt>accept</tt> method called at the last line parses the <tt>Runnable</tt> class bytecode and calls the corresponding <tt>ClassVisitor</tt> methods on <tt>cp</tt>. The result is the following output:
</div>
<pre class="LyX-Code">
java/lang/Runnable extends java/lang/Object {
    run()V
}
</pre>
<div class="Standard">
Note that there are several ways to construct<a class="IndexReference" name="entry-ClassReader_-1" href="#index-ClassReader_">↓</a> a <tt>ClassReader</tt> instance. The class that must be read can be specified by name, as above, or by value, as a byte array or as an <tt>InputStream</tt>. An input stream to read the content of a class can be obtained with the <tt>ClassLoader</tt>’s <tt>getResourceAsStream</tt> method with:
</div>
<pre class="LyX-Code">
<i>cl</i>.getResourceAsStream(<i>classname</i>.replace(’.’, ’/’) + ".class");
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.2.3">2.2.3</a> Generating classes<a class="Label" name="sub:Generating-classes-CoreAPI"> </a>
</h3>
<div class="Standard">
The only required component to generate<a class="IndexReference" name="entry-classes-generating-0" href="#index-classes-generating">↓</a> a class is the <tt>ClassWriter</tt> component. Let’s take an example to illustrate this. Consider the following interface:
</div>
<pre class="LyX-Code">
package pkg;
public interface Comparable extends Mesurable {
  int LESS = -1;
  int EQUAL = 0;
  int GREATER = 1;
  int compareTo(Object o);
}
</pre>
<div class="Standard">
It can be generated with six method calls to a <tt>ClassVisitor</tt>:
</div>
<pre class="LyX-Code">
ClassWriter cw = <b>new ClassWriter(0)</b>;
cw.<b>visit</b>(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE,
    "pkg/Comparable", null, "java/lang/Object",
    new String[] { "pkg/Mesurable" });
cw.<b>visitField</b>(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, "LESS", "I",
    null, new Integer(-1)).visitEnd();
cw.<b>visitField</b>(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, "EQUAL", "I",
    null, new Integer(0)).visitEnd();
cw.<b>visitField</b>(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, "GREATER", "I",
    null, new Integer(1)).visitEnd();
cw.<b>visitMethod</b>(ACC_PUBLIC + ACC_ABSTRACT, "compareTo",
    "(Ljava/lang/Object;)I", null, null).visitEnd();
cw.<b>visitEnd</b>();
byte[] b = cw.<b>toByteArray</b>();
</pre>
<div class="Standard">
The first line creates a <tt>ClassWriter</tt> instance that will actually build the byte array representation of the class (the constructor argument is explained in the next chapter).
</div>
<div class="Standard">
The call to the <tt>visit</tt> method defines the class header. The <tt>V1_5</tt> argument is a constant defined, like all other ASM constants, in the ASM <tt>Opcodes</tt><a class="IndexReference" name="entry-Opcodes_-0" href="#index-Opcodes_">↓</a> interface. It specifies the class version, Java 1.5. The <tt>ACC_<i>XXX</i></tt> constants are flags that correspond to Java modifiers. Here we specify that the class is an interface, and that it is <tt>public</tt> and <tt>abstract</tt> (because it cannot be instantiated). The next argument specifies the class name, in internal form (see section <a class="Reference" href="#sub:Internal-names">2.1.2↑</a>). Recall that compiled classes do not contain a package or import section, so all class names must be fully qualified. The next argument corresponds to generics (see section <a class="Reference" href="#sec:Generics">4.1↓</a>). In our case it is <tt>null</tt> because the interface is not parameterized by a type variable. The fifth argument is the super class, in internal form (interface classes implicitly inherit from <tt>Object</tt>). The last argument is an array of the interfaces that are extended, specified by their internal names.
</div>
<div class="Standard">
The next three calls to <tt>visitField</tt> are similar, and are used to define the three interface fields. The first argument is a set of flags that correspond to Java modifiers. Here we specify that the fields are <tt>public</tt>, <tt>final</tt> and <tt>static</tt>. The second argument is the name of the field, as it appears in source code. The third argument is the type of the field, in type descriptor form. Here the fields are <tt>int</tt> fields, whose descriptor is <tt>I</tt>. The fourth argument corresponds to generics. In our case it is <tt>null</tt> because the field types are not using generics. The last argument is the field’s <i>constant</i><a class="IndexReference" name="entry-fields-constant-value-0" href="#index-fields-constant-value">↓</a> value: this argument must be used only for truly constant fields, i.e. <tt>final</tt> <tt>static</tt> fields. For other fields it must be <tt>null</tt>. Since there are no annotations here, we call the <tt>visitEnd</tt> method of the returned <tt>FieldVisitor</tt> immediately, i.e. without any call to its <tt>visitAnnotation</tt> or <tt>visitAttribute</tt> methods.
</div>
<div class="Standard">
The <tt>visitMethod</tt> call is used to define the <tt>compareTo</tt> method. Here again the first argument is a set of flags that correspond to Java modifiers. The second argument is the method name, as it appears in source code. The third argument is the descriptor of the method. The fourth argument corresponds to generics. In our case it is <tt>null</tt> because the method is not using generics. The last argument is an array of the exceptions<a class="IndexReference" name="entry-exceptions-declaration-0" href="#index-exceptions-declaration">↓</a> that can be thrown by the method, specified by their internal names. Here it is <tt>null</tt> because the method does not declare any exception. The <tt>visitMethod</tt> method returns a <tt>MethodVisitor</tt> (see Figure <a class="Reference" href="#fig:The-MethodVisitor-interface">3.4↓</a>), which can be used to define the method’s annotations and attributes, and most importantly the method’s code. Here, since there are no annotations and since the method is abstract, we call the <tt>visitEnd</tt> method of the returned <tt>MethodVisitor</tt> immediately.
</div>
<div class="Standard">
Finally a last call to <tt>visitEnd</tt> is used to inform <tt>cw</tt> that the class is finished and a call to <tt>toByteArray</tt> is used to retrieve it as a byte array.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--2"></a>Using generated classes
</h4>
<div class="Standard">
The previous byte array can be stored in a <tt>Comparable.class</tt> file for future use. Alternatively it can be loaded<a class="IndexReference" name="entry-classes-loading-0" href="#index-classes-loading">↓</a> dynamically with a <tt>ClassLoader</tt>. One method is to define a <tt>ClassLoader</tt> subclass whose <tt>defineClass</tt> method is public:
</div>
<pre class="LyX-Code">
  class MyClassLoader extends ClassLoader {
    public Class defineClass(String name, byte[] b) {
      return defineClass(name, b, 0, b.length);
    }
  }
</pre>
<div class="Standard">
Then the generated class can be loaded directly with:
</div>
<pre class="LyX-Code">
Class c = myClassLoader.defineClass("pkg.Comparable", b);
</pre>
<div class="Standard">
Another method to load a generated class, which is probably cleaner, is to define a <tt>ClassLoader</tt> subclass whose <tt>findClass</tt> method is overridden in order to generate the requested class on the fly:
</div>
<pre class="LyX-Code">
class StubClassLoader extends ClassLoader {
  @Override 
  protected Class findClass(String name)
      throws ClassNotFoundException {
    if (name.endsWith("_Stub")) {
      ClassWriter cw = new ClassWriter(0);
      ...
      byte[] b = cw.toByteArray();
      return defineClass(name, b, 0, b.length);
    }
    return super.findClass(name);
  }
}
</pre>
<div class="Standard">
In fact the way of using your generated classes depends on the context, and is out of scope of the ASM API. If you are writing a compiler, the class generation process will be driven by an abstract syntax tree representing the program to be compiled, and the generated classes will be stored on disk. If you are writing a dynamic proxy class generator or aspect weaver you will use, in one way or another, a <tt>ClassLoader</tt>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.2.4">2.2.4</a> Transforming classes<a class="Label" name="sub:Transforming-classes-CoreAPI"> </a><a class="IndexReference" name="entry-classes-transforming-0" href="#index-classes-transforming">↓</a>
</h3>
<div class="Standard">
So far the <tt>ClassReader</tt> and <tt>ClassWriter</tt> components were used alone. The events were produced &ldquo;by hand&rdquo; and consumed directly by a <tt>ClassWriter</tt> or, symetrically, they were produced by a <tt>ClassReader</tt> and consumed &ldquo;by hand&rdquo;, i.e. by a custom <tt>ClassVisitor</tt> implementation. Things start to become really interesting when these components are used together. The first step is to direct the events produced by a <tt>ClassReader</tt> to a <tt>ClassWriter</tt>. The result is that the class parsed by the class reader is reconstructed by the class writer:
</div>
<pre class="LyX-Code">
byte[] b1 = ...;
ClassWriter cw = new ClassWriter(0);
ClassReader cr = new ClassReader(b1);
cr.accept(cw, 0);
byte[] b2 = cw.toByteArray(); // b2 represents the same class as b1
</pre>
<div class="Standard">
This is not really interesting in itself (there are easier ways to copy a byte array!), but wait. The next step is to introduce a <tt>ClassVisitor</tt> between the class reader and the class writer:
</div>
<pre class="LyX-Code">
byte[] b1 = ...;
ClassWriter cw = new ClassWriter(0);
// cv forwards all events to cw
<b>ClassVisitor cv = new ClassVisitor(ASM4, cw) { };</b>
ClassReader cr = new ClassReader(b1);
cr.accept(<b>cv</b>, 0);
byte[] b2 = cw.toByteArray(); // b2 represents the same class as b1
</pre>
<div class="Standard">
The architecture corresponding to the above code is depicted in Figure <a class="Reference" href="#fig:A-transformation-chain">2.6↓</a>, where components are represented with squares, and events with arrows (with a vertical time line as in sequence diagrams).
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:A-transformation-chain"> </a><div class="figure">
<div class="center">
<img class="embedded" src="figures/chain.png" alt="figure figures/chain.png" style="max-width: 410px; max-height: 95px;"/>

</div>
<div class="caption">
Figure 2.6 A transformation chain<a class="IndexReference" name="entry-transformation-chain-1" href="#index-transformation-chain">↓</a>
</div>

</div>

</div>

</div>
<div class="Standard">
The result does not change, however, because the <tt>ClassVisitor</tt> event filter does not filter anything. But it is now sufficient to filter some events, by overriding some methods, in order to be able to transform a class. For example, consider the following <tt>ClassVisitor</tt> subclass:
</div>
<pre class="LyX-Code">
public class ChangeVersionAdapter <b>extends ClassVisitor</b> {
  public ChangeVersionAdapter(ClassVisitor cv) {
    super(ASM4, cv);
  }
  @Override 
  public void visit(int version, int access, String name,
      String signature, String superName, String[] interfaces) {
    cv.visit(<b>V1_5</b>, access, name, signature, superName, interfaces);
  }
}
</pre>
<div class="Standard">
This class overrides only one method of the <tt>ClassVisitor</tt> class. As a consequence all calls are forwarded unchanged to the class visitor <tt>cv</tt> passed to the constructor, except calls to the <tt>visit</tt> method, which are forwarded with a modified class version number. The corresponding sequence diagram is shown in Figure <a class="Reference" href="#fig:ChangeVersionAdapter">2.7↓</a>.
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:ChangeVersionAdapter"> </a><div class="figure">
<div class="center">
<img class="embedded" src="figures/changeversion.png" alt="figure figures/changeversion.png" style="max-width: 451px; max-height: 227px;"/>

</div>
<div class="caption">
Figure 2.7 Sequence diagram for the <tt>ChangeVersionAdapter</tt>
</div>

</div>

</div>

</div>
<div class="Standard">
By modifying other arguments of the <tt>visit</tt> method you can implement other transformations than just changing the class version. For instance you can add an interface to the list of implemented interfaces. It is also possible to change the name of the class, <i>but this requires much more than just changing the</i> <tt><i>name</i></tt> <i>argument in the</i> <tt><i>visit</i></tt> <i>method</i>. Indeed the name of the class can appear in many different places inside a compiled class, and <i>all</i> these occurrences must be changed to really rename the class.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--3"></a>Optimization
</h4>
<div class="Standard">
The previous transformation changes only four bytes in the original class. However, with the above code, <tt>b1</tt> is fully parsed and the corresponding events are used to construct <tt>b2</tt> from scratch, which is not very efficient. It would be much more efficient to copy the parts of <tt>b1</tt> that are not transformed directly into <tt>b2</tt>, without parsing these parts and without generating the corresponding events. ASM automatically performs this optimization for methods: 
</div>
<ul>
<li>
If a <tt>ClassReader</tt> component detects that a <tt>MethodVisitor</tt> returned by the <tt>ClassVisitor</tt> passed as argument to its <tt>accept</tt> method comes from a <tt>ClassWriter</tt>, this means that the content of this method will not be transformed, and will in fact not even be <i>seen</i> by the application.
</li>
<li>
In this case the <tt>ClassReader</tt> component does not parse the content of this method, does not generate the corresponding events, and just copies the byte array representation of this method in the <tt>ClassWriter</tt>.
</li>

</ul>
<div class="Standard">
This optimization<a class="IndexReference" name="entry-ClassWriter_-1" href="#index-ClassWriter_">↓</a> is performed by the <tt>ClassReader</tt> and <tt>ClassWriter</tt> components if they have a reference to each other, which can be set like this:
</div>
<pre class="LyX-Code">
byte[] b1 = ...
ClassReader cr = new ClassReader(b1);
ClassWriter cw = new ClassWriter(<b>cr</b>, 0);
ChangeVersionAdapter ca = new ChangeVersionAdapter(cw);
cr.accept(ca, 0);
byte[] b2 = cw.toByteArray();
</pre>
<div class="Standard">
Thanks to this optimization the above code is <i>two times</i> faster than the previous one, because <tt>ChangeVersionAdapter</tt> does not transform any method. For common class transformations, which transform some or all methods, the speedup is smaller, but is still noticeable: it is indeed of the order of <span class="formula">10</span> to <span class="formula">20%</span>. Unfortunately this optimization requires to copy all the constants defined in the original class into the transformed one. This is not a problem for tranformations that <i>add</i> fields, methods or instructions, but this leads to bigger class files, compared to the unoptimized case, for transformations that <i>remove</i> or <i>rename</i> many class elements. It is therefore recommanded to use this optimization only for &ldquo;additive&rdquo; transformations.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--4"></a>Using transformed classes<a class="IndexReference" name="entry-classes-loading-1" href="#index-classes-loading">↓</a>
</h4>
<div class="Standard">
The transformed class <tt>b2</tt> can be stored on disk or loaded with a <tt>ClassLoader</tt>, as described in the previous section. But class transformations done inside a <tt>ClassLoader</tt> can only transform the classes loaded by this class loader. If you want to transform <i>all</i> classes you will have to put your transformation inside a <tt>ClassFileTransformer</tt>, as defined in the <tt>java.lang.instrument</tt> package (see the documentation of this package for more details):
</div>
<pre class="LyX-Code">
public static void premain(String agentArgs, Instrumentation inst) {
  inst.addTransformer(new ClassFileTransformer() {
    public byte[] transform(ClassLoader l, String name, Class c,
        ProtectionDomain d, byte[] b)
        throws IllegalClassFormatException {
      ClassReader cr = new ClassReader(b);
      ClassWriter cw = new ClassWriter(cr, 0);
      ClassVisitor cv = new ChangeVersionAdapter(cw);
      cr.accept(cv, 0);
      return cw.toByteArray();
    }
  });
}
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.2.5">2.2.5</a> Removing class members<a class="Label" name="sub:Removing-class-members-coreAPI"> </a><a class="IndexReference" name="entry-classes-removing-members-0" href="#index-classes-removing-members">↓</a>
</h3>
<div class="Standard">
The method used to transform the class version in the previous section can of course be applied to other methods of the <tt>ClassVisitor</tt> class. For instance, by changing the <tt>access</tt> or <tt>name</tt> argument in the <tt>visitField</tt> and <tt>visitMethod</tt> methods, you can change the modifiers or the name of a field or of a method. Furthermore, instead of forwarding a method call with modified arguments, you can choose to <i>not</i> forward this call at all. The effect is that the corresponding class element is <i>removed</i>.
</div>
<div class="Standard">
For example the following class adapter removes the information about outer and inner classes, as well as the name of the source file from which the class was compiled (the resulting class remains fully functional, because these elements are only used for debugging purposes). This is done by not forwarding anything in the appropriate visit methods:
</div>
<pre class="LyX-Code">
public class RemoveDebugAdapter extends ClassVisitor {
  public RemoveDebugAdapter(ClassVisitor cv) {
    super(ASM4, cv);
  }
  @Override 
  public void visitSource(String source, String debug) {
  }
  @Override
  public void visitOuterClass(String owner, String name, String desc) {
  }
  @Override
  public void visitInnerClass(String name, String outerName,
      String innerName, int access) {
  }
}
</pre>
<div class="Standard">
This strategy does not work for fields and methods, because the <tt>visitField</tt> and <tt>visitMethod</tt> methods must return a result. In order to remove a field<a class="IndexReference" name="entry-fields-removing-0" href="#index-fields-removing">↓</a> or method, you must not forward the method call, and return <tt>null</tt> to the caller. For example the following class adapter removes a single method<a class="IndexReference" name="entry-methods-removing-0" href="#index-methods-removing">↓</a>, specified by its name and by its descriptor (the name is not sufficient to identify a method, because a class can contain several methods of the same name but with different parameters):
</div>
<pre class="LyX-Code">
public class RemoveMethodAdapter extends ClassVisitor {
  private String mName;
  private String mDesc;
  public RemoveMethodAdapter(
      ClassVisitor cv, String mName, String mDesc) {
    super(ASM4, cv);
    this.mName = mName;
    this.mDesc = mDesc;
  }
  @Override
  public MethodVisitor visitMethod(int access, String name,
      String desc, String signature, String[] exceptions) {
    <b>if (name.equals(mName) &amp;&amp; desc.equals(mDesc)) {</b>
 <b>     // do not delegate to next visitor -&gt; this removes the method</b>
 <b>     return null;</b>
 <b>   }</b>
    return cv.visitMethod(access, name, desc, signature, exceptions);
  }
}
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.2.6">2.2.6</a> Adding class members<a class="Label" name="sub:Adding-class-members-coreAPI"> </a><a class="IndexReference" name="entry-classes-adding-members-0" href="#index-classes-adding-members">↓</a>
</h3>
<div class="Standard">
Instead of forwarding fewer calls than you receive, you can &ldquo;forward&rdquo; more, which has the effect of <i>adding</i> class elements. The new calls can be inserted at several places between the original method calls, provided that the order in which the various <tt>visit<i>Xxx</i></tt> methods must be called is respected (see section <a class="Reference" href="#sub:Classes-CoreAPI">2.2.1↑</a>).
</div>
<div class="Standard">
For instance, if you want to add a field<a class="IndexReference" name="entry-fields-adding-0" href="#index-fields-adding">↓</a> to a class you have to insert a new call to <tt>visitField</tt> between the original method calls, and you must put this new call in one of the visit method of your class adapter. You cannot do this in the <tt>visit</tt> method, for example, because this may result in a call to <tt>visitField</tt> followed by <tt>visitSource</tt>, <tt>visitOuterClass</tt>, <tt>visitAnnotation</tt> or <tt>visitAttribute</tt>, which is not valid. You cannot put this new call in the <tt>visitSource</tt>, <tt>visitOuterClass</tt>, <tt>visitAnnotation</tt> or <tt>visitAttribute</tt> methods, for the same reason. The only possibilities are the <tt>visitInnerClass</tt>, <tt>visitField</tt>, <tt>visitMethod</tt> or <tt>visitEnd</tt> methods.
</div>
<div class="Standard">
If you put the new call in the <tt>visitEnd</tt> method the field will always be added (unless you add explicit conditions), because this method is always called. If you put it in <tt>visitField</tt> or <tt>visitMethod</tt>, <i>several</i> fields will be added: one per field or method in the original class. Both solutions can make sense; it depends on what you need. For instance you can add a single counter field to count the invocations on an object, or one counter per method, to count the invocations of each method separately. 
</div>
<div class="Description">
<span class="Description-entry">Note:</span> in fact the only truly correct solution is to add new members by making additional calls in the <tt>visitEnd</tt> method. Indeed a class must not contain duplicate members, and the only way to be sure that a new member is unique is to compare it with all the existing members, which can only be done once they have all been visited, i.e. in the <tt>visitEnd</tt> method. This is rather constraining. Using generated names that are unlikely to be used by a programmer, such as <tt>_counter$</tt> or <tt>_4B7F_</tt> is sufficient in practice to avoid duplicate members without having to add them in <tt>visitEnd</tt>. Note that, as discussed in the first chapter, the tree API does not have this limitation: it is possible to add new members at any time inside a transformation with this API.
</div>
<div class="Standard">
In order to illustrate the above discussion, here is a class adapter that adds a field to a class, unless this field already exists:
</div>
<pre class="LyX-Code">
public class AddFieldAdapter extends ClassVisitor {
  private int fAcc;
  private String fName;
  private String fDesc;
  private boolean isFieldPresent;
  public AddFieldAdapter(ClassVisitor cv, int fAcc, String fName,
      String fDesc) {
    super(ASM4, cv);
    this.fAcc = fAcc;
    this.fName = fName;
    this.fDesc = fDesc;
  }
  @Override
  public FieldVisitor visitField(int access, String name, String desc,
      String signature, Object value) {
    <b>if (name.equals(fName)) {</b>
 <b>     isFieldPresent = true;</b>
 <b>   }</b>
    return cv.visitField(access, name, desc, signature, value);
  }
  @Override 
  public void visitEnd() {
    <b>if (!isFieldPresent) {</b>
 <b>     FieldVisitor fv = cv.visitField(fAcc, fName, fDesc, null, null);</b>
 <b>     if (fv != null) {</b>
 <b>       fv.visitEnd();</b>
 <b>     }</b>
 <b>   }</b>
    cv.visitEnd();
  }
}
</pre>
<div class="Standard">
The field is added in the <tt>visitEnd</tt> method. The <tt>visitField</tt> method is not overridden to modify existing fields or to remove a field, but just to detect if the field we want to add already exists or not. Note the <tt>fv != null</tt> test in the <tt>visitEnd</tt> method, before calling <tt>fv.visitEnd()</tt>: this is because, as we have seen in the previous section, a class visitor can return <tt>null</tt> in <tt>visitField</tt>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.2.7">2.2.7</a> Transformation chains<a class="Label" name="sub:Transformation-chains"> </a>
</h3>
<div class="Standard">
So far we have seen simple transformation chains<a class="IndexReference" name="entry-transformation-chain-2" href="#index-transformation-chain">↓</a> made of a <tt>ClassReader</tt>, a class adapter, and a <tt>ClassWriter</tt>. It is of course possible to use more complex chains, with <i>several</i> class adapters chained together. Chaining several adapters allows you to compose several independent class transformations in order to do complex transformations. Note also that a transformation chain is not necessarily linear. You can write a <tt>ClassVisitor</tt> that forwards all the method calls it receives to several <tt>ClassVisitor</tt> at the same time:
</div>
<pre class="LyX-Code">
public class MultiClassAdapter extends ClassVisitor {
  protected <b>ClassVisitor[]</b> cvs;
  public MultiClassAdapter(<b>ClassVisitor[]</b> cvs) {
    super(ASM4);
    this.cvs = cvs;
  }
  @Override public void visit(int version, int access, String name,
      String signature, String superName, String[] interfaces) {
    <b>for (ClassVisitor cv : cvs) {</b>
      cv.visit(version, access, name, signature, superName, interfaces);
    <b>}</b>
  }
  ...
}
</pre>
<div class="Standard">
Symmetrically several class adapters can delegate to the same <tt>ClassVisitor</tt> (this requires some precautions to ensure, for example, that the <tt>visit</tt> and <tt>visitEnd</tt> methods are called exactly once on this <tt>ClassVisitor</tt>). Thus a transformation chain such as the one shown in Figure <a class="Reference" href="#fig:A-complex-transformation-chain">2.8↓</a> is perfectly possible.
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:A-complex-transformation-chain"> </a><div class="figure">
<div class="center">
<img class="embedded" src="figures/complexchain.png" alt="figure figures/complexchain.png" style="width: 328px; max-width: 410px; height: 106px; max-height: 133px;"/>

</div>
<div class="caption">
Figure 2.8 A complex transformation chain
</div>

</div>

</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.3">2.3</a> Tools<a class="Label" name="sub:ClassTools"> </a>
</h2>
<div class="Standard">
In addition to the <tt>ClassVisitor</tt> class and to the related <tt>ClassReader</tt> and <tt>ClassWriter</tt> components, ASM provides, in the <tt>org.objectweb.asm.util</tt> package, several tools that can be useful during the development of a class generator or adapter, but which are not needed at runtime. ASM also provides a utility class for manipulating internal names, type descriptors and method descriptors at runtime. All these tools are presented below.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.3.1">2.3.1</a> <tt>Type</tt><a class="Label" name="sub:Type"> </a>
</h3>
<div class="Standard">
As you have seen in the previous sections, the ASM API exposes Java types as they are stored in compiled classes, i.e. as internal names or type descriptors. It would be possible to expose them as they appear in source code, to make code more readable. But this would require systematic conversions between the two representations in <tt>ClassReader</tt> and <tt>ClassWriter</tt>, which would degrade performances. This is why ASM does not transparently transform internal names and type descriptors to their equivalent source code form. However it provides the <tt>Type</tt> class for doing that manually when necessary.
</div>
<div class="Standard">
A <tt>Type</tt><a class="IndexReference" name="entry-Type_-0" href="#index-Type_">↓</a> object represents a Java type, and can be constructed either from a type descriptor or from a <tt>Class</tt> object. The <tt>Type</tt> class also contains static variables representing the primitive types. For example <tt>Type.INT_TYPE</tt> is the <tt>Type</tt> object representing the <tt>int</tt> type.
</div>
<div class="Standard">
The <tt>getInternalName</tt><a class="IndexReference" name="entry-internal-name-1" href="#index-internal-name">↓</a> method returns the internal name of a <tt>Type</tt>. For example <tt>Type.getType(String.class).getInternalName()</tt> gives the internal name of the <tt>String</tt> class, i.e. <tt>"java/lang/String"</tt>. This method must be used only for class or interface types. 
</div>
<div class="Standard">
The <tt>getDescriptor</tt><a class="IndexReference" name="entry-type-descriptor-1" href="#index-type-descriptor">↓</a> method returns the descriptor of a <tt>Type</tt>. So, for example, instead of using <tt>"Ljava/lang/String;"</tt> in your code you could use <tt>Type.getType(String.class).getDescriptor()</tt>. Or, instead of using <tt>I</tt>, you could use <tt>Type.INT_TYPE.getDescriptor()</tt>.
</div>
<div class="Standard">
A <tt>Type</tt> object can also represent a method type. Such objects can be constructed either from a method descriptor or from a <tt>Method</tt> object. The <tt>getDescriptor</tt> method then returns the method descriptor corresponding to this type. In addition, the <tt>getArgumentTypes</tt> and <tt>getReturnType</tt> methods can be used to get the <tt>Type</tt> objects corresponding to the argument types and return types of a method. For instance <tt>Type.getArgumentTypes("(I)V")</tt><a class="IndexReference" name="entry-method-descriptor-1" href="#index-method-descriptor">↓</a> returns an array containing the single element <tt>Type.INT_TYPE</tt>. Similarly, a call to <tt>Type.getReturnType("(I)V")</tt> returns the <tt>Type.VOID_TYPE</tt> object.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.3.2">2.3.2</a> <tt>TraceClassVisitor</tt>
</h3>
<div class="Standard">
In order to check that a generated or transformed class is conforming to what you expect, the byte array returned by a <tt>ClassWriter</tt> is not really helpful because it is unreadable by humans. A textual representation would be much easier to use. This is what the <tt>TraceClassVisitor</tt><a class="IndexReference" name="entry-TraceClassVisitor_-0" href="#index-TraceClassVisitor_">↓</a> class provides. This class, as its name implies, extends the <tt>ClassVisitor</tt> class, and builds a textual representation<a class="IndexReference" name="entry-classes-textual-representation-0" href="#index-classes-textual-representation">↓</a> of the visited class. So, instead of using a <tt>ClassWriter</tt> to generate your classes, you can use a <tt>TraceClassVisitor</tt>, in order to get a readable trace of what is actually generated. Or, even better, you can use both at the same time. Indeed the <tt>TraceClassVisitor</tt> can, in addition to its default behavior, delegate all calls to its methods to another visitor, for instance a <tt>ClassWriter</tt>:
</div>
<pre class="LyX-Code">
ClassWriter cw = new ClassWriter(0);
TraceClassVisitor cv = new TraceClassVisitor(cw, printWriter);
cv.visit(...);
...
cv.visitEnd();
byte b[] = cw.toByteArray();
</pre>
<div class="Standard">
This code creates a <tt>TraceClassVisitor</tt> that delegates all the calls it receives to <tt>cw</tt>, and that prints<a class="IndexReference" name="entry-classes-printing-0" href="#index-classes-printing">↓</a> a textual representation of these calls to <tt>printWriter</tt>. For example, using a <tt>TraceClassVisitor</tt> in the example of section <a class="Reference" href="#sub:Generating-classes-CoreAPI">2.2.3↑</a> would give:
</div>
<pre class="LyX-Code">
// class version 49.0 (49)
// access flags 1537
public abstract interface pkg/Comparable implements pkg/Mesurable  {
  // access flags 25
  public final static I LESS = -1
  // access flags 25
  public final static I EQUAL = 0
  // access flags 25
  public final static I GREATER = 1
  // access flags 1025
  public abstract compareTo(Ljava/lang/Object;)I
}
</pre>
<div class="Standard">
Note that you can use a <tt>TraceClassVisitor</tt> at any point in a generation or transformation chain, and not only just before a <tt>ClassWriter</tt>, in order to see what happens at this point in the chain. Note also that the textual representation of classes generated by this adapter can be used to compare classes easily, with <tt>String.equals()</tt>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.3.3">2.3.3</a> <tt>CheckClassAdapter</tt>
</h3>
<div class="Standard">
The <tt>ClassWriter</tt> class does not check that its methods are called in the appropriate order and with valid arguments. It is therefore possible to generate invalid classes that will be rejected by the Java Virtual Machine verifier. In order to detect some of these errors as soon as possible, it is possible to use the <tt>CheckClassAdapter</tt><a class="IndexReference" name="entry-CheckClassAdapter_-0" href="#index-CheckClassAdapter_">↓</a> class. Like <tt>TraceClassVisitor</tt>, this class extends the <tt>ClassVisitor</tt> class, and delegates all calls to its method to another <tt>ClassVisitor</tt>, for instance a <tt>TraceClassVisitor</tt> or a <tt>ClassWriter</tt>. However, instead of printing a textual representation of the visited class, this class checks<a class="IndexReference" name="entry-classes-checking-0" href="#index-classes-checking">↓</a> that its methods are called in the appropriate order, and with valid arguments, before delegating to the next visitor. In case of errors an <tt>IllegalStateException</tt> or <tt>IllegalArgumentException</tt> is thrown.
</div>
<div class="Standard">
In order to check a class, print a textual representation of this class, and finally create a byte array representation, you should use something like:
</div>
<pre class="LyX-Code">
ClassWriter cw = new ClassWriter(0);
TraceClassVisitor tcv = new TraceClassVisitor(cw, printWriter);
<b>CheckClassAdapter cv = new CheckClassAdapter(tcv);</b>
cv.visit(...);
...
cv.visitEnd();
byte b[] = cw.toByteArray();
</pre>
<div class="Standard">
Note that if you chain these class visitors in a different order, the operations they perform will be done in a different order too. For example, with the following code, the checks will take place <i>after</i> the trace:
</div>
<pre class="LyX-Code">
ClassWriter cw = new ClassWriter(0);
<b>CheckClassAdapter cca = new CheckClassAdapter(cw);</b>
TraceClassVisitor cv = new TraceClassVisitor(cca, printWriter);
</pre>
<div class="Standard">
Like with <tt>TraceClassVisitor</tt>, you can use a <tt>CheckClassAdapter</tt> at any point in a generation or transformation chain, and not only just before a <tt>ClassWriter</tt>, in order to check classes at this point in the chain. 
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.3.4">2.3.4</a> <tt>ASMifier</tt>
</h3>
<div class="Standard">
This class provides an alternative backend for the <tt>TraceClassVisitor</tt> tool (which by default uses a <tt>Textifier</tt> backend, producing the kind of output shown above). This backend makes each method of the <tt>TraceClassVisitor</tt> class print the Java code that was used to call it. For instance calling the<tt> visitEnd()</tt> method prints <tt>cv.visitEnd();</tt>. The result is that, when a <tt>TraceClassVisitor</tt> visitor with an <tt>ASMifier</tt> backend visits a class, it prints the source code to generate this class with ASM. This is useful if you use this visitor to visit an already existing class. For instance, if you don’t know how to generate some compiled class with ASM, write the corresponding source code, compile it with <tt>javac</tt>, and visit the compiled class with the <tt>ASMifier</tt><a class="IndexReference" name="entry-ASMifier_-0" href="#index-ASMifier_">↓</a>. You will get the ASM code to generate this compiled class!
</div>
<div class="Standard">
The <tt>ASMifier</tt> class can be used from the command line. For example using:
</div>
<pre class="LyX-Code">
java -classpath asm.jar:asm-util.jar \
     org.objectweb.asm.util.ASMifier \
     java.lang.Runnable
</pre>
<div class="Standard">
produces code that, after indentation, reads:
</div>
<pre class="LyX-Code">
package asm.java.lang;
import org.objectweb.asm.*;
public class RunnableDump implements Opcodes {
  public static byte[] dump() throws Exception {
    ClassWriter cw = new ClassWriter(0);
    FieldVisitor fv;
    MethodVisitor mv;
    AnnotationVisitor av0;
    cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE,
        "java/lang/Runnable", null, "java/lang/Object", null);
    {
      mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "run", "()V",
          null, null);
      mv.visitEnd();
    }
    cw.visitEnd();
    return cw.toByteArray();
  }
}
</pre>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-3">3</a> Methods
</h1>
<div class="Standard">
This chapter explains how to generate and transform compiled methods with the core ASM API. It starts with a presentation of compiled methods and then presents the corresponding ASM interfaces, components and tools to generate and transform them, with many illustrative examples.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.1">3.1</a> Structure<a class="IndexReference" name="entry-methods-structure-0" href="#index-methods-structure">↓</a>
</h2>
<div class="Standard">
Inside compiled classes the code of methods is stored as a sequence of <i>bytecode</i> instructions<a class="IndexReference" name="entry-bytecode-instruction-0" href="#index-bytecode-instruction">↓</a>. In order to generate and transform classes it is fundamental to know these instructions and to understand how they work. This section gives an overview of these instructions which should be sufficient to start coding simple class generators and transformers. For a complete definition you should read the Java Virtual Machine Specification.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.1">3.1.1</a> Execution model
</h3>
<div class="Standard">
Before presenting the bytecode instructions it is necessary to present the Java Virtual Machine execution model. As you know Java code is executed inside <i>threads</i>. Each thread has its own execution stack<a class="IndexReference" name="entry-execution-stack-0" href="#index-execution-stack">↓</a>, which is made of <i>frames</i><a class="IndexReference" name="entry-execution-frame-0" href="#index-execution-frame">↓</a>. Each frame represents a method invocation: each time a method is invoked, a new frame is pushed on the current thread’s execution stack. When the method returns, either normally or because of an exception, this frame is popped from the execution stack and execution continues in the calling method (whose frame is now on top of the stack).
</div>
<div class="Standard">
Each frame contains two parts: a local variables part and an operand stack part. The <i>local variables</i><a class="IndexReference" name="entry-local-variables-0" href="#index-local-variables">↓</a> part contains variables that can be accessed by their index, in random order. The <i>operand stack</i><a class="IndexReference" name="entry-operand-stack-0" href="#index-operand-stack">↓</a> part, as its name implies, is a stack of values that are used as operands by bytecode instructions. This means that the values in this stack can only be accessed in Last In First Out order. Do not confuse the operand stack and the thread’s execution stack: each frame in the execution stack contains its <i>own</i> operand stack.
</div>
<div class="Standard">
The size of the local variables<a class="IndexReference" name="entry-local-variables-size-0" href="#index-local-variables-size">↓</a> and operand stack<a class="IndexReference" name="entry-operand-stack-size-0" href="#index-operand-stack-size">↓</a> parts depends on the method’s code. It is computed at compile time and is stored along with the bytecode instructions in compiled classes. As a consequence, all the frames that correspond to the invocation of a given method have the same size, but frames that correspond to different methods can have different sizes for their local variables and operand stack parts.
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:An-execution-stack"> </a><div class="figure">
<div class="center">
<span class="vspace" style="height: 0.5cm;"> </span><img class="embedded" src="figures/frames.png" alt="figure figures/frames.png" style="max-width: 290px; max-height: 73px;"/>
<span class="vspace" style="height: 0.5cm;"> </span>
</div>
<div class="caption">
Figure 3.1 An execution stack<a class="IndexReference" name="entry-execution-stack-1" href="#index-execution-stack">↓</a> with 3 frames
</div>

</div>

</div>

</div>
<div class="Standard">
Figure <a class="Reference" href="#fig:An-execution-stack">3.1↑</a> shows a sample execution stack with 3 frames. The first frame contains 3 local variables, its operand stack has a maximum size of 4, and it contains two values. The second frame contains 2 local variables, and two values in its operand stack. Finally the third frame, on top of the execution stack, contains 4 local variables and two operands.
</div>
<div class="Standard">
When it is created, a frame is initialized with an empty stack, and its local variables are initialized with the target object <tt>this</tt> (for non static methods) and with the method’s arguments. For instance, calling the method <tt>a.equals(b)</tt> creates a frame with an empty stack and with the first two local variables initialized to <tt>a</tt> and <tt>b</tt> (other local variables are uninitialized).
</div>
<div class="Standard">
Each slot in the local variables and operand stack parts can hold any Java value, except <tt>long</tt> and <tt>double</tt> values. These values require two slots. This complicates the management of local variables: for instance the <span class="formula"><i>i</i><sup><i>th</i></sup></span> method argument is not necessarily stored in local variable <span class="formula"><i>i</i></span>. For example, calling <tt>Math.max(1L, 2L)</tt> creates a frame with the <tt>1L</tt> value in the first two local variable slots, and with the value <tt>2L</tt> in the third and fourth slots.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.2">3.1.2</a> Bytecode instructions<a class="Label" name="sub:Bytecode-instructions"> </a>
</h3>
<div class="Standard">
A bytecode instruction<a class="IndexReference" name="entry-bytecode-instruction-1" href="#index-bytecode-instruction">↓</a> is made of an opcode that identifies this instruction, and of a fixed number of arguments:
</div>
<ul>
<li>
The <i>opcode</i><a class="IndexReference" name="entry-opcode-0" href="#index-opcode">↓</a><a class="IndexReference" name="entry-bytecode-instruction-opcode-0" href="#index-bytecode-instruction-opcode">↓</a> is an unsigned byte value — hence the bytecode name — and is identified by a mnemonic symbol. For example the opcode value 0 is designed by the mnemonic symbol <tt>NOP</tt>, and corresponds to the instruction that does nothing. 
</li>
<li>
The <i>arguments</i><a class="IndexReference" name="entry-bytecode-instruction-arguments-0" href="#index-bytecode-instruction-arguments">↓</a> are static values that define the precise instruction behavior. They are given just after the opcode. For instance the <tt>GOTO</tt> <i>label</i> instruction, whose opcode value is 167, takes as argument <i>label</i>, a label that designates the next instruction to be executed. Instruction arguments must not be confused with instruction operands<a class="IndexReference" name="entry-operand-0" href="#index-operand">↓</a><a class="IndexReference" name="entry-bytecode-instruction-operands-0" href="#index-bytecode-instruction-operands">↓</a>: argument values are statically known and are stored in the compiled code, while operand values come from the operand stack and are known only at runtime.
</li>

</ul>
<div class="Standard">
The bytecode instructions can be divided in two categories: a small set of instructions is designed to transfer values from the local variables to the operand stack, and vice versa; the other instructions only act on the operand stack: they pop some values from the stack, compute a result based on these values, and push it back on the stack.
</div>
<div class="Standard">
The <tt>ILOAD</tt>, <tt>LLOAD</tt>, <tt>FLOAD</tt>, <tt>DLOAD</tt>, and <tt>ALOAD</tt> instructions read a local variable and push its value on the operand stack. They take as argument the index <span class="formula"><i>i</i></span> of the local variable that must be read. <tt>ILOAD</tt> is used to load a <tt>boolean</tt>, <tt>byte</tt>, <tt>char</tt>, <tt>short</tt>, or <tt>int</tt> local variable. <tt>LLOAD</tt>, <tt>FLOAD</tt> and <tt>DLOAD</tt> are used to load a <tt>long</tt>, <tt>float</tt> or <tt>double</tt> value, respectively (<tt>LLOAD</tt> and <tt>DLOAD</tt> actually load the two slots <span class="formula"><i>i</i></span> and <span class="formula"><i>i</i> + 1</span>). Finally <tt>ALOAD</tt> is used to load any non primitive value, i.e. object and array references. Symmetrically the <tt>ISTORE</tt>, <tt>LSTORE</tt>, <tt>FSTORE</tt>, <tt>DSTORE</tt> and <tt>ASTORE</tt> instructions pop a value from the operand stack and store it in a local variable designated by its index <tt>i</tt>.
</div>
<div class="Standard">
As you can see the <i>x<tt></tt></i>LOAD and <i>x<tt></tt></i>STORE instructions are typed (in fact, as you will see below, almost all instructions are typed). This is used to ensure that no illegal conversion is done. Indeed it is illegal to store a value in a local variable and then to load it with a different type. For instance the <tt>ISTORE 1 ALOAD 1</tt> sequence is illegal — it would allow to store an arbitrary memory address in local variable 1, and to convert this address to an object reference! It is however perfectly legal to store in a local variable a value whose type differ from the type of the current value stored in this local variable. This means that the type of a local variable, i.e. the type of the value stored in this local variable, can change during the execution of a method.
</div>
<div class="Standard">
As said above, all other bytecode instructions work on the operand stack only. They can be grouped in the following categories (see appendix <a class="Reference" href="#app:Bytecode-instructions">11.1↓</a>):
</div>
<div class="Description">
<span class="Description-entry">Stack</span> These instructions are used to manipulate values on the stack: <tt>POP</tt> pops the value on top of the stack, <tt>DUP</tt> pushes a copy of the top stack value, <tt>SWAP</tt> pops two values and pushes them in the reverse order, etc.
</div>
<div class="Description">
<span class="Description-entry">Constants</span> These instructions push a constant value on the operand stack: <tt>ACONST_NULL</tt> pushes <tt>null</tt>, <tt>ICONST_0</tt> pushes the int value <tt>0</tt>, <tt>FCONST_0</tt> pushes <tt>0f</tt>, <tt>DCONST_0</tt> pushes <tt>0d</tt>, <tt>BIPUSH</tt> <i>b</i> pushes the byte value <i>b</i>, <tt>SIPUSH</tt> <i>s</i> pushes the short value <i>s</i>, <tt>LDC</tt> <i>cst</i> pushes the arbitrary <tt>int</tt>, <tt>float</tt>, <tt>long</tt>, <tt>double</tt>, <tt>String</tt>, or <tt>class</tt><span class="FootOuter"><span class="SupFootMarker"> [B] </span><span class="HoverFoot"><span class="SupFootMarker"> [B] </span>this corresponds to the <i>identifier<tt></tt></i>.class Java syntax.</span></span> constant <i>cst</i>, etc.
</div>
<div class="Description">
<span class="Description-entry">Arithmetic and logic</span> These instructions pop numeric values from the operand stack combine them and push the result on the stack. They do not have any argument. <i>x<tt></tt></i>ADD, <i>x<tt></tt></i>SUB, <i>x<tt></tt></i>MUL, <i>x<tt></tt></i>DIV and <i>x<tt></tt></i>REM correspond to the <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt> and <tt>%</tt> operations, where <i>x</i> is either <tt>I</tt>, <tt>L</tt>, <tt>F</tt> or <tt>D</tt>. Similarly there are other instructions corresponding to <tt>&lt;&lt;</tt>, <tt>&gt;&gt;</tt>, <tt>&gt;&gt;&gt;</tt>, <tt><span class="versalitas">|</span></tt>, <tt>&amp;</tt> and <tt>^</tt>, for <tt>int</tt> and <tt>long</tt> values.
</div>
<div class="Description">
<span class="Description-entry">Casts</span> These instructions pop a value from the stack, convert it to another type, and push the result back. They correspond to cast expressions in Java. <tt>I2F</tt>, <tt>F2D</tt>, <tt>L2D</tt>, etc. convert numeric values from one numeric type to another. <tt>CHECKCAST</tt> <i>t</i> converts a reference value to the type <i>t</i>.
</div>
<div class="Description">
<span class="Description-entry">Objects</span> These instructions are used to create objects, lock them, test their type, etc. For instance the <tt>NEW</tt> <i>type</i> instruction pushes a new object of type <i>type</i> on the stack (where <i>type</i> is an internal name).
</div>
<div class="Description">
<span class="Description-entry">Fields</span> These instructions read or write the value of a field. <tt>GETFIELD</tt> <i>owner</i> <i>name</i> <i>desc</i> pops an object reference, and pushes the value of its <i>name</i> field. <tt>PUTFIELD</tt> <i>owner</i> <i>name</i> <i>desc</i> pops a value and an object reference, and stores this value in its <i>name</i> field. In both cases the object must be of type <i>owner</i>, and its field must be of type <i>desc</i>. <tt>GETSTATIC</tt> and <tt>PUTSTATIC</tt> are similar instructions, but for static fields.
</div>
<div class="Description">
<span class="Description-entry">Methods</span> These instructions invoke a method or a constructor. They pop as many values as there are method arguments, plus one value for the target object, and push the result of the method invocation. <tt>INVOKEVIRTUAL</tt> <i>owner</i> <i>name</i> <i>desc</i> invokes the <i>name</i> method defined in class <i>owner</i>, and whose method descriptor is <i>desc</i>. <tt>INVOKESTATIC</tt> is used for static methods, <tt>INVOKESPECIAL</tt> for private methods and constructors, and <tt>INVOKEINTERFACE</tt> for methods defined in interfaces. Finally, for Java 7 classes,<tt> INVOKEDYNAMIC</tt> is used for the new dynamic method invocation mechanism.
</div>
<div class="Description">
<span class="Description-entry">Arrays</span> These instructions are used to read and write values in arrays. The <i>x<tt></tt></i>ALOAD instructions pop an index and an array, and push the value of the array element at this index. The <i>x<tt></tt></i>ASTORE instructions pop a value, an index and an array, and store this value at that index in the array. Here <i>x</i> can be <tt>I</tt>, <tt>L</tt>, <tt>F</tt>, <tt>D</tt> or <tt>A</tt>, but also <tt>B</tt>, <tt>C</tt> or <tt>S</tt>.
</div>
<div class="Description">
<span class="Description-entry">Jumps</span> These instructions jump to an arbitrary instruction if some condition is true, or unconditionally. They are used to compile <tt>if</tt>, <tt>for</tt>, <tt>do</tt>, <tt>while</tt>, <tt>break</tt> and <tt>continue</tt> instructions. For instance <tt>IFEQ</tt> <i>label</i> pops an <tt>int</tt> value from the stack, and jumps to the instruction designed by <i>label</i><a class="IndexReference" name="entry-label-0" href="#index-label">↓</a> if this value is 0 (otherwise execution continues normally to the next instruction). Many other jump instructions exist, such as <tt>IFNE</tt> or <tt>IFGE</tt>. Finally <tt>TABLESWITCH</tt> and <tt>LOOKUPSWITCH</tt> correspond to the <tt>switch</tt> Java instruction.
</div>
<div class="Description">
<span class="Description-entry">Return</span> Finally the <i>x<tt></tt></i>RETURN and <tt>RETURN</tt> instructions are used to terminate the execution of a method and to return its result to the caller. <tt>RETURN</tt> is used for methods that return <tt>void</tt>, and <i>x<tt></tt></i>RETURN for the other methods.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.3">3.1.3</a> Examples<a class="Label" name="sub:Bytecode-sequence-examples"> </a>
</h3>
<div class="Standard">
Lets look at some basic examples to get a more concrete sense of how bytecode instructions work. Consider the following bean class:
</div>
<pre class="LyX-Code">
package pkg;
public class Bean {
  private int f;
  public int getF() {
    return this.f;
  }
  public void setF(int f) {
    this.f = f;
  }
}
</pre>
<div class="Standard">
The bytecode of the getter method is:
</div>
<pre class="LyX-Code">
ALOAD 0
GETFIELD pkg/Bean f I
IRETURN
</pre>
<div class="Standard">
The first instruction reads the local variable 0, which was initialized to <tt>this</tt> during the creation of the frame for this method call, and pushes this value on the operand stack. The second instruction pops this value from the stack, i.e. <tt>this</tt>, and pushes the <tt>f</tt> field of this object, i.e. <tt>this.f</tt>. The last instruction pops this value from the stack, and returns it to the caller. The successive states of the execution frame for this method are shown in Figure <a class="Reference" href="#fig:Successive-frame-states-getF">3.2↓</a>.
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:Successive-frame-states-getF"> </a><div class="figure">
<div class="center">
<span class="vspace" style="height: 0.6cm;"> </span><img class="embedded" src="figures/getter-frames.png" alt="figure figures/getter-frames.png" style="max-width: 217px; max-height: 67px;"/>
<span class="vspace" style="height: 0.6cm;"> </span>
</div>
<div class="caption">
Figure 3.2 Successive frame states for the <tt>getF</tt> method: a) initial state, b) after <tt>ALOAD 0</tt> and c) after <tt>GETFIELD</tt>
</div>

</div>

</div>

</div>
<div class="Standard">
The bytecode of the setter method is:
</div>
<pre class="LyX-Code">
ALOAD 0
ILOAD 1
PUTFIELD pkg/Bean f I
RETURN
</pre>
<div class="Standard">
The first instruction pushes <tt>this</tt> on the operand stack, as before. The second instruction pushes the local variable 1, which was initialized with the <tt>f</tt> argument value during the creation of the frame for this method call. The third instruction pops these two values and stores the <tt>int</tt> value in the <tt>f</tt> field of the referenced object, i.e. in <tt>this.f</tt>. The last instruction, which is implicit in the source code but which is mandatory in the compiled code, destroys the current execution frame and returns to the caller. The successive states of the execution frame for this method are shown in Figure <a class="Reference" href="#fig:Successive-frame-states-setF">3.3↓</a>.
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:Successive-frame-states-setF"> </a><div class="figure">
<div class="center">
<span class="vspace" style="height: 0.6cm;"> </span><img class="embedded" src="figures/setter-frames.png" alt="figure figures/setter-frames.png" style="max-width: 296px; max-height: 68px;"/>
<span class="vspace" style="height: 0.6cm;"> </span>
</div>
<div class="caption">
Figure 3.3 Successive frame states for the <tt>setF</tt> method: a) initial state, b) after <tt>ALOAD 0</tt>, c) after <tt>ILOAD 1</tt> and d) after <tt>PUTFIELD</tt>
</div>

</div>

</div>

</div>
<div class="Standard">
The <tt>Bean</tt> class also has a default public constructor which is generated by the compiler, since no explicit constructor<a class="IndexReference" name="entry-constructors-0" href="#index-constructors">↓</a> was defined by the programmer. This default public constructor is generated as <tt>Bean() { super(); }</tt>. The bytecode of this constructor is the following:
</div>
<pre class="LyX-Code">
ALOAD 0
INVOKESPECIAL java/lang/Object &lt;init&gt; ()V
RETURN
</pre>
<div class="Standard">
The first instruction pushes <tt>this</tt> on the operand stack. The second instruction pops this value from the stack, and calls the <tt>&lt;init&gt;</tt> method defined in the <tt>Object</tt> class. This corresponds to the <tt>super()</tt> call, i.e. a call to the constructor of the super class, <tt>Object</tt>. You can see here that constructors are named differently in compiled and source classes: in compiled classes they are always named <tt>&lt;init&gt;</tt>, while in source classes they have the name of the class in which they are defined. Finally the last instruction returns to the caller.
</div>
<div class="Standard">
Now let us consider a slightly more complex setter method:
</div>
<pre class="LyX-Code">
public void checkAndSetF(int f) {
  if (f &gt;= 0) {
    this.f = f;
  } else {
    throw new IllegalArgumentException();
  }
}
</pre>
<div class="Standard">
The bytecode for this new setter method is the following:
</div>
<pre class="LyX-Code">
  ILOAD 1
  IFLT <i>label</i>
  ALOAD 0
  ILOAD 1
  PUTFIELD pkg/Bean f I
  GOTO <i>end</i>
<i>label:</i>
  NEW java/lang/IllegalArgumentException
  DUP
  INVOKESPECIAL java/lang/IllegalArgumentException &lt;init&gt; ()V
  ATHROW
<i>end:</i>
  RETURN
</pre>
<div class="Standard">
The first instruction pushes the local variable 1, initialized to <tt>f</tt>, on the operand stack. The <tt>IFLT</tt> instruction pops this value from the stack, and compares it to 0. If it is Less Than (<tt>LT</tt>) 0, it jumps to the instruction designated by the <tt><i>label</i></tt> label, otherwise it does nothing and the execution continues to the next instruction. The next three instructions are the same instructions as in the <tt>setF</tt> method. The <tt>GOTO</tt> instruction unconditionally jumps to the instruction designated by the <tt><i>end</i></tt> label, which is the <tt>RETURN</tt> instruction. The instructions between the <tt><i>label</i></tt> and <tt><i>end</i></tt> labels create and throw an exception: the <tt>NEW</tt> instruction creates an exception object and pushes it on the operand stack. The <tt>DUP</tt> instruction duplicates this value on the stack. The <tt>INVOKESPECIAL</tt> instruction pops one of these two copies and calls the exception constructor on it. Finally the <tt>ATHROW</tt> instruction pops the remaining copy and throws it as an exception (so the execution does not continue to the next instruction).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.4">3.1.4</a> Exception handlers<a class="Label" name="sub:Exception-handlers"> </a>
</h3>
<div class="Standard">
There is no bytecode instruction to catch exceptions: instead the bytecode of a method is associated with a list of <i>exception handlers</i><a class="IndexReference" name="entry-exceptions-handlers-0" href="#index-exceptions-handlers">↓</a> that specify the code that must be executed when an exception is thrown in a given part of a method. An exception handler is similar to a <tt>try</tt> <tt>catch</tt> block: it has a range, which is a sequence of instructions that corresponds to the content of the <tt>try</tt> block, and a handler, which corresponds to the content of the <tt>catch</tt> block. The range is specified by a start and end labels, and the handler with a start label. For example the source code below:
</div>
<pre class="LyX-Code">
public static void sleep(long d) {
  try {
    Thread.sleep(d);
  } catch (InterruptedException e) {
    e.printStackTrace();
  }
}
</pre>
<div class="Standard">
can be compiled into:
</div>
<pre class="LyX-Code">
TRYCATCHBLOCK <i>try</i> <i>catch</i> <i>catch</i> java/lang/InterruptedException
<i>try:</i>
  LLOAD 0
  INVOKESTATIC java/lang/Thread sleep (J)V
  RETURN
<i>catch:</i>
  INVOKEVIRTUAL java/lang/InterruptedException printStackTrace ()V
  RETURN
</pre>
<div class="Standard">
The code between the <tt><i>try</i></tt> and <tt><i>catch</i></tt> labels corresponds to the <tt>try</tt> block, while the code after the <tt><i>catch</i></tt> label corresponds to the <tt>catch</tt> block. The <tt>TRYCATCHBLOCK</tt> line specifies an exception handler that covers the range between the <tt><i>try</i></tt> and <tt><i>catch</i></tt> labels, with a handler starting at the <tt><i>catch</i></tt> label, and for exceptions whose class is a subclass of <tt>InterruptedException</tt>. This means that if such an exception is thrown anywhere between <tt><i>try</i></tt> and <tt><i>catch</i></tt> the stack is cleared, the exception is pushed on this empty stack, and execution continues at <tt><i>catch</i></tt>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.5">3.1.5</a> Frames<a class="Label" name="sub:Frames"> </a>
</h3>
<div class="Standard">
Classes compiled with Java 6 or higher contain, in addition to bytecode instructions, a set of <i>stack map frames</i><a class="IndexReference" name="entry-frames-0" href="#index-frames">↓</a> that are used to speed up the class verification process inside the Java Virtual Machine. A stack map frame gives the state of the execution frame of a method at some point during its execution. More precisely it gives the <i>type</i> of the values that are contained in each local variable slot and in each operand stack slot just before some specific bytecode instruction is executed.
</div>
<div class="Standard">
For example, if we consider the <tt>getF</tt> method of the previous section, we can define three stack map frames giving the state of the execution frame just before <tt>ALOAD</tt>, just before <tt>GETFIELD</tt>, and just before <tt>IRETURN</tt>. These three stack map frames correspond to the three cases shown in Figure <a class="Reference" href="#fig:Successive-frame-states-getF">3.2↑</a> and can be described as follows, where the types between the first square brackets correspond to the local variables, and the others to the operand stack:
</div>
<div class="Standard">
<div class="center">
<table>
<tr>
<td align="left" valign="top">
State of the execution frame <i>before</i>
</td>
<td align="left" valign="top">
Instruction
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt>] []
</td>
<td align="left" valign="top">
<tt>ALOAD 0</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt>] [<tt>pkg/Bean</tt>]
</td>
<td align="left" valign="top">
<tt>GETFIELD</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt>] [<tt>I</tt>]
</td>
<td align="left" valign="top">
<tt>IRETURN</tt>
</td>

</tr>

</table>

</div>

</div>
<div class="Standard">
We can do the same for the <tt>checkAndSetF</tt> method:
</div>
<div class="Standard">
<div class="center">
<table>
<tr>
<td align="left" valign="top">
State of the execution frame <i>before</i>
</td>
<td align="left" valign="top">
Instruction
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt> <tt>I</tt>] []
</td>
<td align="left" valign="top">
<tt>ILOAD 1</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt> <tt>I</tt>] [<tt>I</tt>]
</td>
<td align="left" valign="top">
<tt>IFLT</tt> <tt><i>label</i></tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt> <tt>I</tt>] []
</td>
<td align="left" valign="top">
<tt>ALOAD 0</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt> <tt>I</tt>] [<tt>pkg/Bean</tt>]
</td>
<td align="left" valign="top">
<tt>ILOAD 1</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt> <tt>I</tt>] [<tt>pkg/Bean</tt> <tt>I</tt>]
</td>
<td align="left" valign="top">
<tt>PUTFIELD</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt> <tt>I</tt>] []
</td>
<td align="left" valign="top">
<tt>GOTO</tt> <tt><i>end</i></tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt> <tt>I</tt>] []
</td>
<td align="left" valign="top">
<tt><i>label</i>:</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<b>[<tt>pkg/Bean</tt></b> <tt><b>I</b></tt>] []
</td>
<td align="left" valign="top">
<tt>NEW</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt> <tt>I</tt>] [Uninitialized(label)]
</td>
<td align="left" valign="top">
<tt>DUP</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt> <tt>I</tt>] [Uninitialized(label) Uninitialized(label)]
</td>
<td align="left" valign="top">
<tt>INVOKESPECIAL</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt> <tt>I</tt>] [<tt>java/lang/IllegalArgumentException</tt>]
</td>
<td align="left" valign="top">
<tt>ATHROW</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
[<tt>pkg/Bean</tt> <tt>I</tt>] []
</td>
<td align="left" valign="top">
<tt><i>end</i>:</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<b>[<tt>pkg/Bean</tt></b> <tt><b>I</b></tt>] []
</td>
<td align="left" valign="top">
<tt>RETURN</tt>
</td>

</tr>

</table>

</div>

</div>
<div class="Standard">
This is similar to the previous method, except for the Uninitialized(label) type. This is a special type that is used only in stack map frames, and that designates an object whose memory has been allocated but whose constructor<a class="IndexReference" name="entry-constructors-1" href="#index-constructors">↓</a> has not been called yet. The argument designates the instruction that created this object. The only possible method that can be called on a value of this type is a constructor. When it is called, <i>all the occurrences</i> of this type in the frame are replaced with the real type, here <tt>IllegalArgumentException</tt>. Stack map frames can use three other special types: <tt>UNINITIALIZED_THIS</tt> is the initial type of local variable 0 in constructors, <tt>TOP</tt> corresponds to an undefined value, and <tt>NULL</tt> corresponds to <tt>null</tt>.
</div>
<div class="Standard">
As said above, starting from Java 6, compiled classes contain, in addition to bytecode, a set of stack map frames. In order to save space, a compiled method does not contain one frame per instruction: in fact it contains only the frames for the instructions that correspond to jump targets or exception handlers, or that follow unconditional jump instructions. Indeed the other frames can be easily and quickly inferred from these ones. 
</div>
<div class="Standard">
In the case of the <tt>checkAndSetF</tt> method, this means that only two frames are stored: one for the <tt>NEW</tt> instruction, because it is the target of the <tt>IFLT</tt> instruction, but also because it follows the unconditional jump <tt>GOTO</tt> instruction, and one for the <tt>RETURN</tt> instruction, because it is the target of the <tt>GOTO</tt> instruction, and also because it follows the &ldquo;unconditional jump&rdquo; <tt>ATHROW</tt> instruction.
</div>
<div class="Standard">
In order to save even more space, each frame is compressed<a class="IndexReference" name="entry-frames-compression-0" href="#index-frames-compression">↓</a> by storing only its difference compared to the previous frame, and the initial frame is not stored at all, because it can easily be deduced from the method parameter types. In the case of the <tt>checkAndSetF</tt> method the two frames that must be stored are equal and are equal to the initial frame, so they are stored as the single byte value designated by the <tt>F_SAME</tt> mnemonic. These frames can be represented just before their associated bytecode instruction. This gives the final bytecode for the <tt>checkAndSetF</tt> method:
</div>
<pre class="LyX-Code">
  ILOAD 1
  IFLT <i>label</i>
  ALOAD 0
  ILOAD 1
  PUTFIELD pkg/Bean f I
  GOTO <i>end</i>
<i>label:</i>
<b>F_SAME</b>
  NEW java/lang/IllegalArgumentException
  DUP
  INVOKESPECIAL java/lang/IllegalArgumentException &lt;init&gt; ()V
  ATHROW
<i>end:</i>
<b>F_SAME</b>
  RETURN
</pre>
<h2 class="Section">
<a class="toc" name="toc-Section-3.2">3.2</a> Interfaces and components
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.2.1">3.2.1</a> Presentation<a class="Label" name="sub:Methods-coreAPI"> </a>
</h3>
<div class="Standard">
The ASM API for generating and transforming compiled methods is based on the <tt>MethodVisitor</tt> abstract class (see Figure <a class="Reference" href="#fig:The-MethodVisitor-interface">3.4↓</a>), which is returned by the <tt>ClassVisitor</tt>’s <tt>visitMethod</tt> method. In addition to some methods related to annotations and debug information, which are explained in the next chapter, this class defines one method per bytecode instruction category, based on the number and type of arguments of these instructions (these categories do <i>not</i> correspond to the ones presented in section <a class="Reference" href="#sub:Bytecode-instructions">3.1.2↑</a>). These methods must be called in the following order (with some additional constraints specified in the Javadoc of the <tt>MethodVisitor</tt> interface):
</div>
<pre class="LyX-Code">
<tt>visitAnnotationDefault</tt><span class="unknown">\normalfont</span>?
<tt><span class="unknown">\normalfont</span>(~visitAnnotation<span class="unknown">\normalfont</span>~|~visitParameterAnnotation<span class="unknown">\normalfont</span>~|~visitAttribute</tt><span class="unknown">\normalfont</span>~)*
<tt><span class="unknown">\normalfont</span>(~visitCode</tt>
 <tt> <span class="unknown">\normalfont</span>(~visitTryCatchBlock<span class="unknown">\normalfont</span>~|~visitLabel<span class="unknown">\normalfont</span>~|~visitFrame<span class="unknown">\normalfont</span>~|~visit</tt><i>Xxx<tt></tt></i>Insn<span class="unknown">\normalfont</span>~|
 <tt>   visitLocalVariable<span class="unknown">\normalfont</span>~|~visitLineNumber</tt><span class="unknown">\normalfont</span>~)*
 <tt> visitMaxs</tt><span class="unknown">\normalfont</span>~)?
<tt>visitEnd</tt>
</pre>
<div class="Standard">
This means that annotations and attributes, if any, must be visited first, followed by the method’s bytecode, for non abstract methods. For these methods the code must be visited in <i>sequential</i> order, between exactly one call to <tt>visitCode</tt> and exactly one call to <tt>visitMaxs</tt>. 
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:The-MethodVisitor-interface"> </a><div class="figure">
<pre class="LyX-Code">
abstract class <b>MethodVisitor</b> { // public accessors ommited
  MethodVisitor(int api);
  MethodVisitor(int api, MethodVisitor mv);
  AnnotationVisitor visitAnnotationDefault();
  AnnotationVisitor visitAnnotation(String desc, boolean visible);
  AnnotationVisitor visitParameterAnnotation(int parameter,
      String desc, boolean visible);
  void visitAttribute(Attribute attr);
  void <b>visitCode</b>();
  void <b>visitFrame</b>(int type, int nLocal, Object[] local, int nStack,
      Object[] stack);
  void <b>visitInsn</b>(int opcode);
  void <b>visitIntInsn</b>(int opcode, int operand);
  void <b>visitVarInsn</b>(int opcode, int var);
  void <b>visitTypeInsn</b>(int opcode, String desc);
  void <b>visitFieldInsn</b>(int opc, String owner, String name, String desc);
  void <b>visitMethodInsn</b>(int opc, String owner, String name, String desc);
  void <b>visitInvokeDynamicInsn</b>(String name, String desc, Handle bsm, 
      Object... bsmArgs);
  void <b>visitJumpInsn</b>(int opcode, Label label);
  void <b>visitLabel</b>(Label label);
  void <b>visitLdcInsn</b>(Object cst);
  void <b>visitIincInsn</b>(int var, int increment);
  void <b>visitTableSwitchInsn</b>(int min, int max, Label dflt, Label[] labels);
  void <b>visitLookupSwitchInsn</b>(Label dflt, int[] keys, Label[] labels);
  void <b>visitMultiANewArrayInsn</b>(String desc, int dims);
  void <b>visitTryCatchBlock</b>(Label start, Label end, Label handler,
      String type);
  void visitLocalVariable(String name, String desc, String signature,
      Label start, Label end, int index);
  void visitLineNumber(int line, Label start);
  void <b>visitMaxs</b>(int maxStack, int maxLocals);
  void <b>visitEnd</b>();
}
</pre>
<div class="caption">
Figure 3.4 The <tt>MethodVisitor</tt><a class="IndexReference" name="entry-MethodVisitor_-0" href="#index-MethodVisitor_">↓</a> class
</div>

</div>

</div>

</div>
<div class="Standard">
The <tt>visitCode</tt> and <tt>visitMaxs</tt> methods can therefore be used to detect the start and end of the method’s bytecode in a sequence of events. Like for classes, the <tt>visitEnd</tt> method must be called last, and is used to detect the end of a method in a sequence of events.
</div>
<div class="Standard">
The <tt>ClassVisitor</tt> and <tt>MethodVisitor</tt> classes can be combined in order to generate complete classes:
</div>
<pre class="LyX-Code">
ClassVisitor cv = ...;
cv.visit(...);
MethodVisitor mv1 = cv.visitMethod(..., "m1", ...);
mv1.visitCode();
mv1.visitInsn(...);
...
mv1.visitMaxs(...);
mv1.visitEnd();
MethodVisitor mv2 = cv.visitMethod(..., "m2", ...);
mv2.visitCode();
mv2.visitInsn(...);
...
mv2.visitMaxs(...);
mv2.visitEnd();
cv.visitEnd();
</pre>
<div class="Standard">
Note that it is not necessary to finish one method in order to start visiting another one. In fact <tt>MethodVisitor</tt> instances are completely independent and can be used in any order (as long as <tt>cv.visitEnd()</tt> has not been called):
</div>
<pre class="LyX-Code">
ClassVisitor cv = ...;
cv.visit(...);
MethodVisitor mv1 = cv.visitMethod(..., "m1", ...);
mv1.visitCode();
mv1.visitInsn(...);
...
MethodVisitor mv2 = cv.visitMethod(..., "m2", ...);
mv2.visitCode();
mv2.visitInsn(...);
...
mv1.visitMaxs(...);
mv1.visitEnd();
...
mv2.visitMaxs(...);
mv2.visitEnd();
cv.visitEnd();
</pre>
<div class="Standard">
ASM provides three core components based on the <tt>MethodVisitor</tt> API to generate and transform methods:
</div>
<ul>
<li>
The <tt>ClassReader</tt> class parses the content of compiled methods and calls the corresponding methods on the <tt>MethodVisitor</tt> objects returned by the <tt>ClassVisitor</tt> passed as argument to its <tt>accept</tt> method.
</li>
<li>
The <tt>ClassWriter</tt>’s <tt>visitMethod</tt> method returns an implementation of the <tt>MethodVisitor</tt> interface that builds compiled methods directly in binary form.
</li>
<li>
The <tt>MethodVisitor</tt> class delegates all the method calls it receives to another <tt>MethodVisitor</tt> instance. It can be seen as an event filter.
</li>

</ul>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--5"></a><tt>ClassWriter</tt> options
</h4>
<div class="Standard">
As we have seen in section <a class="Reference" href="#sub:Frames">3.1.5↑</a>, computing the stack map frames<a class="IndexReference" name="entry-frames-computing-0" href="#index-frames-computing">↓</a> for a method is not very easy: you have to compute all the frames, find the frames that correspond to jump targets or that follow unconditional jumps, and finally compress these remaining frames. Likewise, computing the size of the local variables<a class="IndexReference" name="entry-local-variables-computing-number-of-0" href="#index-local-variables-computing-number-of">↓</a> and operand stack parts for a method is easier but still not very easy.
</div>
<div class="Standard">
Hopefully ASM can compute this for you. When you create a <tt>ClassWriter</tt> you can specify what must be automatically computed:
</div>
<ul>
<li>
with <tt>new ClassWriter(0)</tt> nothing is automatically computed. You have to compute yourself the frames and the local variables and operand stack sizes.
</li>
<li>
with <tt>new ClassWriter(ClassWriter.COMPUTE_MAXS)</tt> the sizes of the local variables and operand stack parts are computed for you. You must still call <tt>visitMaxs</tt>, but you can use any arguments: they will be ignored and recomputed. With this option you still have to compute the frames yourself.
</li>
<li>
with <tt>new ClassWriter(ClassWriter.COMPUTE_FRAMES)</tt> everything is computed automatically. You don’t have to call <tt>visitFrame</tt>, but you must still call <tt>visitMaxs</tt> (arguments will be ignored and recomputed).
</li>

</ul>
<div class="Standard">
Using these options<a class="IndexReference" name="entry-ClassWriter_-2" href="#index-ClassWriter_">↓</a> is convenient but this has a cost: the <tt>COMPUTE_MAXS</tt> option makes a <tt>ClassWriter</tt> <span class="formula">10%</span> slower, and using the <tt>COMPUTE_FRAMES</tt> option makes it <i>two times</i> slower. This must be compared to the time it would take to compute this yourself: in specific situations there are often easier and faster algorithms for computing this, compared to the algorithm used in ASM, which must handle all cases.
</div>
<div class="Standard">
Note that if you choose to compute the frames yourself, you can let the <tt>ClassWriter</tt> class do the compression step for you. For this you just have to visit your uncompressed frames with <tt>visitFrame(<b>F_NEW</b>, nLocals, locals, nStack, stack)</tt>, where <tt>nLocals</tt> and <tt>nStack</tt> are the number of locals and the operand stack size, and <tt>locals</tt> and <tt>stack</tt> are arrays containing the corresponding types (see the Javadoc for more details).
</div>
<div class="Standard">
Note also that, in order to compute frames automatically, it is sometimes necessary to compute the common super class of two given classes. By default the <tt>ClassWriter</tt> class computes this, in the <tt>getCommonSuperClass</tt> method, by loading the two classes into the JVM and by using the reflection API. This can be a problem if you are generating several classes that reference each other, because the referenced classes may not yet exist. In this case you can override the <tt>getCommonSuperClass</tt> method to solve this problem.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.2.2">3.2.2</a> Generating methods<a class="IndexReference" name="entry-methods-generating-0" href="#index-methods-generating">↓</a>
</h3>
<div class="Standard">
The bytecode of the <tt>getF</tt> method defined in section <a class="Reference" href="#sub:Bytecode-sequence-examples">3.1.3↑</a> can be generated with the following method calls, if <tt>mv</tt> is a <tt>MethodVisitor</tt>:
</div>
<pre class="LyX-Code">
mv.visitCode();
mv.visitVarInsn(ALOAD, 0);
mv.visitFieldInsn(GETFIELD, "pkg/Bean", "f", "I");
mv.visitInsn(IRETURN);
mv.visitMaxs(1, 1);
mv.visitEnd();
</pre>
<div class="Standard">
The first call starts the bytecode generation. It is followed by three calls that generate the three instructions of this method (as you can see the mapping between the bytecode and the ASM API is quite simple). The call to <tt>visitMaxs</tt> must be done after all the instructions have been visited. It is used to define the sizes of the local variables and operand stack parts for the execution frame of this method. As we saw in section <a class="Reference" href="#sub:Bytecode-sequence-examples">3.1.3↑</a>, these sizes are 1 slot for each part. Finally the last call is used to end the generation of the method.
</div>
<div class="Standard">
The bytecode of the <tt>setF</tt> method and of the constructor can be generated in a similar way. A more interesting example is the <tt>checkAndSetF</tt> method:
</div>
<pre class="LyX-Code">
mv.visitCode();
mv.visitVarInsn(ILOAD, 1);
Label label = new Label();
mv.visitJumpInsn(IFLT, label);
mv.visitVarInsn(ALOAD, 0);
mv.visitVarInsn(ILOAD, 1);
mv.visitFieldInsn(PUTFIELD, "pkg/Bean", "f", "I");
Label end = new Label();
mv.visitJumpInsn(GOTO, end);
mv.visitLabel(label);
mv.visitFrame(F_SAME, 0, null, 0, null);
mv.visitTypeInsn(NEW, "java/lang/IllegalArgumentException");
mv.visitInsn(DUP);
mv.visitMethodInsn(INVOKESPECIAL,
    "java/lang/IllegalArgumentException", "&lt;init&gt;", "()V");
mv.visitInsn(ATHROW);
mv.visitLabel(end);
mv.visitFrame(F_SAME, 0, null, 0, null);
mv.visitInsn(RETURN);
mv.visitMaxs(2, 2);
mv.visitEnd();
</pre>
<div class="Standard">
Between the <tt>visitCode</tt> and <tt>visitEnd</tt> calls you can see method calls that map exactly to the bytecode shown at the end of section <a class="Reference" href="#sub:Frames">3.1.5↑</a>: one call per instruction, label or frame (the only exceptions are the declaration and construction of the <tt>label</tt> and <tt>end</tt> <tt>Label</tt> objects).
</div>
<div class="Description">
<span class="Description-entry">Note:</span> a <tt>Label</tt><a class="IndexReference" name="entry-Label_-0" href="#index-Label_">↓</a> object designates the <i>instruction</i> that follows the <tt>visitLabel</tt> call for this label. For example <tt>end</tt> designates the <tt>RETURN</tt> instruction, and not the frame that is visited just after, since this is not an instruction. It is perfectly legal to have several labels designating the same instruction, but a label must designate exactly one instruction. In other words it is possible to have successive calls to <tt>visitLabel</tt> with different labels, but a label used in an instruction must be visited exactly once with <tt>visitLabel</tt>. A last constraint is that labels can not be shared: each method must have its own labels.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.2.3">3.2.3</a> Transforming methods<a class="IndexReference" name="entry-methods-transforming-0" href="#index-methods-transforming">↓</a>
</h3>
<div class="Standard">
You should now have guessed that methods can be transformed like classes, i.e. by using a method adapter that forwards the method calls it receives with some modifications: changing arguments can be used to change individual instructions, not forwarding a received call removes an instruction, and inserting calls between the received ones adds new instructions. The <tt>MethodVisitor</tt> class provides a basic implementation of such a method adapter, which does nothing else than just forwarding all the method calls it receives.
</div>
<div class="Standard">
In order to understand how method adapters can be used, let’s consider a very simple adapter that removes the <tt>NOP</tt> instructions inside methods (they can be removed without problems since they do nothing):
</div>
<pre class="LyX-Code">
public class RemoveNopAdapter extends MethodVisitor {
  public RemoveNopAdapter(MethodVisitor mv) {
    super(ASM4, mv);
  }
  @Override 
  public void visitInsn(int opcode) {
    <b>if (opcode != NOP) {</b>
 <b>     mv.visitInsn(opcode);</b>
 <b>   }</b>
  }
}
</pre>
<div class="Standard">
This adapter can be used inside a class adapter as follows:
</div>
<pre class="LyX-Code">
public class RemoveNopClassAdapter extends ClassVisitor {
  public RemoveNopClassAdapter(ClassVisitor cv) {
    super(ASM4, cv);
  }
  @Override 
  public MethodVisitor visitMethod(int access, String name,
      String desc, String signature, String[] exceptions) {
    MethodVisitor mv;
    <b>mv = cv.visitMethod(access, name, desc, signature, exceptions);</b>
 <b>   if (mv != null) {</b>
 <b>     mv = new RemoveNopAdapter(mv);</b>
 <b>   }</b>
    return mv;
  }
}
</pre>
<div class="Standard">
In other words the class adapter just builds a method adapter encapsulating the method visitor returned by the next class visitor in the chain, and returns this adapter. The effect is the construction of a method adapter chain that is similar to the class adapter chain (see Figure <a class="Reference" href="#fig:Sequence-diagram-for-RemoveNopAdapter">3.5↓</a>).
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:Sequence-diagram-for-RemoveNopAdapter"> </a><div class="figure">
<div class="center">
<img class="embedded" src="figures/removenop.png" alt="figure figures/removenop.png" style="max-width: 422px; max-height: 221px;"/>

</div>
<div class="caption">
Figure 3.5 Sequence diagram for the <tt>RemoveNopAdapter</tt>
</div>

</div>

</div>

</div>
<div class="Standard">
Note however that this is not mandatory: it is perfectly possible to build a method adapter chain that is not similar to the class adapter chain. Each method can even have a different method adapter chain. For instance the class adapter could choose to remove <tt>NOP</tt>s only in methods and not in constructors. This can be done as follows:
</div>
<pre class="LyX-Code">
...
mv = cv.visitMethod(access, name, desc, signature, exceptions);
if (mv != null &amp;&amp; <b>!name.equals("&lt;init&gt;")</b>) {
  mv = new RemoveNopAdapter(mv);
}
...
</pre>
<div class="Standard">
In this case the adapter chain is shorter for constructors. On the contrary, the adapter chain for constructors could have been longer, with several method adapters chained together created inside <tt>visitMethod</tt>. The method adapter chain can even have a different topology than the class adapter chain. For instance the class adapter chain could be linear, while the method adapter chain has branches:
</div>
<pre class="LyX-Code">
public MethodVisitor visitMethod(int access, String name,
    String desc, String signature, String[] exceptions) {
  MethodVisitor mv1, mv2;
  mv1 = cv.visitMethod(access, name, desc, signature, exceptions);
  mv2 = cv.visitMethod(access, "_" + name, desc, signature, exceptions);
  return new MultiMethodAdapter(mv1, mv2);
}
</pre>
<div class="Standard">
Now that we have seen how method adapters can be used and combined inside a class adapter, let’s see how to implement more interesting adapters than <tt>RemoveNopAdapter</tt>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.2.4">3.2.4</a> Stateless transformations<a class="Label" name="sub:Stateless-transformations"> </a>
</h3>
<div class="Standard">
Let’s suppose we want to measure the time spent in each class of a program. We need to add a static timer field in each class, and we need to add the execution time of each method of this class to this timer field. In other words we want to transform a class such as <tt>C</tt>:
</div>
<pre class="LyX-Code">
public class C {
  public void m() throws Exception {
    Thread.sleep(100);
  }
}
</pre>
<div class="Standard">
into this:
</div>
<pre class="LyX-Code">
public class C {
  <b>public static long timer;</b>
  public void m() throws Exception {
    <b>timer -= System.currentTimeMillis();</b>
    Thread.sleep(100);
    <b>timer += System.currentTimeMillis();</b>
  }
}
</pre>
<div class="Standard">
In order to have an idea of how this can be implemented in ASM, we can compile these two classes and compare the output of <tt>TraceClassVisitor</tt> on these two versions (either with the default <tt>Textifier</tt> backend, or with an <tt>ASMifier</tt> backend). With the default backend we get the following differences (in bold):
</div>
<pre class="LyX-Code">
<b>GETSTATIC C.timer : J</b>
<b>INVOKESTATIC java/lang/System.currentTimeMillis()J</b>
<b>LSUB</b>
<b>PUTSTATIC C.timer : J</b>
LDC 100
INVOKESTATIC java/lang/Thread.sleep(J)V
<b>GETSTATIC C.timer : J</b>
<b>INVOKESTATIC java/lang/System.currentTimeMillis()J</b>
<b>LADD</b>
<b>PUTSTATIC C.timer : J</b>
RETURN
MAXSTACK = <b>4</b>
MAXLOCALS = 1
</pre>
<div class="Standard">
We see that we must add four instructions at the beginning of the method, and four other instructions before the return instruction. We also need to update the maximum operand stack size. The beginning of the method’s code is visited with the <tt>visitCode</tt> method. We can therefore add the first four instructions by overriding this method in our method adapter:
</div>
<pre class="LyX-Code">
public void visitCode() {
  mv.visitCode();
  <b>mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");</b>
 <b> mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",</b>
 <b>     "currentTimeMillis", "()J");</b>
 <b> mv.visitInsn(LSUB);</b>
 <b> mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");</b>
}
</pre>
<div class="Standard">
where <tt>owner</tt> must be set to the name of the class that is being transformed. We must now add four other instructions before any <tt>RETURN</tt>, but also before any <i>x<tt></tt></i>RETURN or before <tt>ATHROW</tt>, which are all the instructions that terminate the method’s execution. These instructions do not have any argument, and are therefore visited in the <tt>visitInsn</tt> method. We can then override this method in order to add our instructions:
</div>
<pre class="LyX-Code">
public void visitInsn(int opcode) {
  if ((opcode &gt;= IRETURN &amp;&amp; opcode &lt;= RETURN) || opcode == ATHROW) {
    <b>mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");</b>
 <b>   mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",</b>
 <b>       "currentTimeMillis", "()J");</b>
 <b>   mv.visitInsn(LADD);</b>
 <b>   mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");</b>
  }
  mv.visitInsn(opcode);
}
</pre>
<div class="Standard">
Finally we must update the maximum operand stack size<a class="IndexReference" name="entry-operand-stack-updating-size-0" href="#index-operand-stack-updating-size">↓</a>. The instructions that we add push two long values, and therefore require four slots on the operand stack. At the beginning of the method the operand stack is initially empty, so we know that the four instructions added at the beginning require a stack of size <span class="formula">4</span>. We also know that our inserted code leaves the stack state unchanged (because it pops as many values as it pushes). As a consequence, if the original code requires a stack of size <span class="formula"><i>s</i></span>, the maximum stack size needed by the transformed method is <span class="formula"><i>max</i>(4, <i>s</i>)</span>. Unfortunately we also add four instructions before the return instructions, and here we do not know the size of the operand stack just before these instructions. We just know that it is less than or equal to <span class="formula"><i>s</i></span>. As a consequence we can just say that the code added before the return instructions may require an operand stack of size up to <span class="formula"><i>s</i> + 4</span>. This worst case scenario rarely happens in practice: with common compilers the operand stack before a <tt>RETURN</tt> contains only the return value, i.e. it has a size of 0, 1 or 2 at most. But if we want to handle all possible cases, we need to use the worst case scenario<span class="FootOuter"><span class="SupFootMarker"> [C] </span><span class="HoverFoot"><span class="SupFootMarker"> [C] </span>hopefully it is not necessary to give the optimal operand stack size. Giving any value greater than or equal to this optimal value is possible, although it may waste memory on the thread’s execution stack.</span></span>. We must then override the <tt>visitMaxs</tt> method as follows:
</div>
<pre class="LyX-Code">
public void visitMaxs(int maxStack, int maxLocals) {
  mv.visitMaxs(maxStack + 4, maxLocals);
}
</pre>
<div class="Standard">
Of course it is possible to not bother about the maximum stack size and rely on the <tt>COMPUTE_MAXS</tt> option that, in addition, will compute the optimal value and not a worst case value. But for such simple transformations it does not cost much effort to update <tt>maxStack</tt> manually.
</div>
<div class="Standard">
Now an interesting question is: what about stack map frames? The original code did not contain any frame, nor the transformed one, but is this due to the specific code we used as example? are there some situations where frames must be updated<a class="IndexReference" name="entry-frames-updating-0" href="#index-frames-updating">↓</a>? The answer is no because 1) the inserted code leaves the operand stack unchanged, 2) the inserted code does not contain jump instructions and 3) the jump instructions — or, more formally, the control flow graph<a class="IndexReference" name="entry-control-flow-graph-0" href="#index-control-flow-graph">↓</a> — of the original code is not modified. This means that the original frames do not change, and since no new frames must be stored for the inserted code, the compressed original frames do not change either.
</div>
<div class="Standard">
We can now put all the elements together in associated <tt>ClassVisitor</tt> and <tt>MethodVisitor</tt> subclasses:
</div>
<pre class="LyX-Code">
public class AddTimerAdapter extends ClassVisitor {
  private String owner;
  private boolean isInterface;
  public AddTimerAdapter(ClassVisitor cv) {
    super(ASM4, cv);
  }
  @Override public void visit(int version, int access, String name,
      String signature, String superName, String[] interfaces) {
    cv.visit(version, access, name, signature, superName, interfaces);
    <b>owner = name;</b>
    <b>isInterface = (access &amp; ACC_INTERFACE) != 0;</b>
  }
  @Override public MethodVisitor visitMethod(int access, String name,
      String desc, String signature, String[] exceptions) {
    MethodVisitor mv = cv.visitMethod(access, name, desc, signature,
        exceptions);
    <b>if (!isInterface &amp;&amp; mv != null &amp;&amp; !name.equals("&lt;init&gt;")) {</b>
 <b>     mv = new AddTimerMethodAdapter(mv);</b>
 <b>   }</b>
    return mv;
  }
  @Override public void visitEnd() {
    <b>if (!isInterface) {</b>
 <b>     FieldVisitor fv = cv.visitField(ACC_PUBLIC + ACC_STATIC, "timer",</b>
 <b>         "J", null, null);</b>
      if (fv != null) {
        fv.visitEnd();
      }
    }
    cv.visitEnd();
  }
  class AddTimerMethodAdapter extends MethodVisitor {
    public AddTimerMethodAdapter(MethodVisitor mv) {
      super(ASM4, mv);
    }
    @Override public void visitCode() {
      <b>mv.visitCode();</b>
 <b>     mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");</b>
 <b>     mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",</b>
 <b>         "currentTimeMillis", "()J");</b>
 <b>     mv.visitInsn(LSUB);</b>
 <b>     mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");</b>
    }
    @Override public void visitInsn(int opcode) {
      <b>if ((opcode &gt;= IRETURN &amp;&amp; opcode &lt;= RETURN) || opcode == ATHROW) {</b>
 <b>       mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");</b>
 <b>       mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",</b>
 <b>           "currentTimeMillis", "()J");</b>
 <b>       mv.visitInsn(LADD);</b>
 <b>       mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");</b>
 <b>     }</b>
 <b>     mv.visitInsn(opcode);</b>
    }
    @Override public void visitMaxs(int maxStack, int maxLocals) {
      mv.visitMaxs(maxStack <b>+ 4</b>, maxLocals);
    }
  }
}
</pre>
<div class="Standard">
The class adapter is used to instantiate the method adapter (except for constructors), but also to add the timer field and to store the name of the class that is being transformed in a field that can be accessed from the method adapter.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.2.5">3.2.5</a> Statefull transformations<a class="Label" name="sub:Statefull-transformations"> </a>
</h3>
<div class="Standard">
The transformation seen in the previous section is local and does not depend on the instructions that have been visited before the current one: the code added at the beginning is always the same and is always added, and likewise for the code inserted before each <tt>RETURN</tt> instruction. Such transformations are called <i>stateless</i> transformations. They are simple to implement but only the simplest transformations verify this property.
</div>
<div class="Standard">
More complex transformations require memorizing some state about the instructions that have been visited before the current one. Consider for example a transformation that removes all occurrences of the <tt>ICONST_0</tt> <tt>IADD</tt> sequence, whose empty effect is to add 0. It is clear that when an <tt>IADD</tt> instruction is visited, it must be removed only if the last visited instruction was an <tt>ICONST_0</tt>. This requires storing state inside the method adapter. For this reason such transformations are called <i>statefull</i> transformations.
</div>
<div class="Standard">
Let’s look in more details at this example. When an <tt>ICONST_0</tt> is visited, it must be removed only if the <i>next</i> instruction is an <tt>IADD</tt>. The problem is that the next instruction is not yet known. The solution is to postpone this decision to the next instruction: if it is an <tt>IADD</tt> then remove both instructions, otherwise emit the <tt>ICONST_0</tt> and the current instruction.
</div>
<div class="Standard">
In order to implement transformations that remove or replace some instruction sequence, it is convenient to introduce a <tt>MethodVisitor</tt> subclass whose <tt>visit<i>Xxx</i>Insn</tt> methods call a common <tt>visitInsn()</tt> method:
</div>
<pre class="LyX-Code">
public abstract class PatternMethodAdapter extends MethodVisitor {
  protected final static int SEEN_NOTHING = 0;
  protected int <b>state</b>;
  public PatternMethodAdapter(int api, MethodVisitor mv) {
    super(api, mv);
  }
  @Overrid public void visitInsn(int opcode) {
    <b>visitInsn</b>();
    mv.visitInsn(opcode);
  }
  @Override public void visitIntInsn(int opcode, int operand) {
    <b>visitInsn</b>();
    mv.visitIntInsn(opcode, operand);
  }
  ...
  protected abstract void <b>visitInsn</b>();
}
</pre>
<div class="Standard">
Then the above transformation can be implemented like this:
</div>
<pre class="LyX-Code">
public class RemoveAddZeroAdapter extends PatternMethodAdapter {
  private static int SEEN_ICONST_0 = 1;
  public RemoveAddZeroAdapter(MethodVisitor mv) {
    super(ASM4, mv);
  }
  @Override public void visitInsn(int opcode) {
    if (state == SEEN_ICONST_0) {
      if (opcode == IADD) {
        state = SEEN_NOTHING;
        return;
      }
    }
    visitInsn();
    if (opcode == ICONST_0) {
      state = SEEN_ICONST_0;
      return;
    }
    mv.visitInsn(opcode);
  }
  @Override protected void visitInsn() {
    if (state == SEEN_ICONST_0) {
      mv.visitInsn(ICONST_0);
    }
    state = SEEN_NOTHING;
  }
}
</pre>
<div class="Standard">
The <tt>visitInsn(int)</tt> method first tests if the sequence has been detected. In this case it reinitializes <tt>state</tt> and returns immediately, which has the effect of removing the sequence. In the other cases it calls the common <tt>visitInsn</tt> method, which emits an <tt>ICONST_0</tt> if this was the <i>last</i> visited instruction. Then, if the <i>current</i> instruction is an <tt>ICONST_0</tt>, it memorizes this fact and returns, in order to postpone the decision about this instruction. In all other cases the current instruction is forwarded to the next visitor.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--6"></a>Labels and frames
</h4>
<div class="Standard">
As we have seen in the previous sections, labels and frames are visited just before their associated instruction. In other words they are visited at the same time as instructions, although they are not instructions themselves. This has an impact on transformations that detect <i>instruction</i> sequences, but this impact is in fact an advantage. Indeed, what happens if one of the instructions we remove is the target of a jump instruction? If some instruction may jump to the <tt>ICONST_0</tt>, this means that there is a label designating this instruction. After the removal of the two instructions this label will designate the instruction that follows the removed <tt>IADD</tt>, which is what we want. But if some instruction may jump to the <tt>IADD</tt>, we can not remove the instruction sequence (we can not be sure that before this jump a 0 was pushed on the stack). Hopefully, in this case, there must be a label between the <tt>ICONST_0</tt> and the <tt>IADD</tt>, which can easily be detected.
</div>
<div class="Standard">
The reasoning is the same for stack map frames: if a stack map frame is visited between the two instructions, we can not remove them. Both cases can be handled by considering labels and frames as instructions in the pattern matching algorithm. This can be done in <tt>PatternMethodAdapter</tt><a class="IndexReference" name="entry-PatternMethodAdapter_-0" href="#index-PatternMethodAdapter_">↓</a> (note that <tt>visitMaxs</tt> also calls the common <tt>visitInsn</tt> method; this is used to handle the case where the end of the method is a prefix of the sequence that must be detected):
</div>
<pre class="LyX-Code">
public abstract class PatternMethodAdapter extends MethodVisitor {
  ...
  @Override public void visitFrame(int type, int nLocal, Object[] local,
      int nStack, Object[] stack) {
    <b>visitInsn</b>();
    mv.visitFrame(type, nLocal, local, nStack, stack);
  }
  @Override public void visitLabel(Label label) {
    <b>visitInsn</b>();
    mv.visitLabel(label);
  }
  @Override public void visitMaxs(int maxStack, int maxLocals) {
    <b>visitInsn</b>();
    mv.visitMaxs(maxStack, maxLocals);
  }
}
</pre>
<div class="Standard">
As we will see in the next chapter, a compiled method may contain information about source file line numbers, used for instance in exception stack traces. This information is visited with the <tt>visitLineNumber</tt> method, which is also called at the same time as instructions. Here however the presence of line numbers in the middle of an instruction sequence does not have any impact on the possibility to transform or remove it. The solution is therefore to ignore them completely in the pattern matching algorithm.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--7"></a>A more complex example
</h4>
<div class="Standard">
The previous example can be easily generalized to more complex instruction sequences. Consider for example a transformation that removes self field assignments, generally due to typos, such as <tt>f = f;</tt> or, in bytecode, <tt>ALOAD</tt> <tt>0</tt> <tt>ALOAD</tt> <tt>0</tt> <tt>GETFIELD</tt> <tt>f</tt> <tt>PUTFIELD</tt> <tt>f</tt>. Before implementing this transformation, it is preferable to design the state machine to recognize this sequence (see Figure <a class="Reference" href="#fig:StateMachine-for-RemoveSelfAssignAdapter">3.6↓</a>).
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:StateMachine-for-RemoveSelfAssignAdapter"> </a><div class="figure">
<div class="center">
<img class="embedded" src="figures/automaton.png" alt="figure figures/automaton.png" style="max-width: 457px; max-height: 255px;"/>

</div>
<div class="caption">
Figure 3.6 State machine for <tt>ALOAD 0 ALOAD 0 GETFIELD f PUTFIELD f</tt>
</div>

</div>

</div>

</div>
<div class="Standard">
Each transition is labeled with a condition (the value of the current instruction) and an action (an instruction sequence that must be emitted, in bold). For instance the transition from S1 to S0 happens if the current instruction is not an <tt>ALOAD</tt> <tt>0</tt>. In this case the <tt>ALOAD</tt> <tt>0</tt> that was visited to arrive at this state is emitted. Note the transition from S2 to itself: this happens when three or more consecutive <tt>ALOAD</tt> <tt>0</tt> are found. In this case we stay in the state where two <tt>ALOAD</tt> <tt>0</tt> have been visited, and we emit the third one. Once the state machine has been found, writing the corresponding method adapter is straightforward (the 8 switch cases correspond to the 8 transitions in the diagram):
</div>
<pre class="LyX-Code">
class RemoveGetFieldPutFieldAdapter extends PatternMethodAdapter {
  private final static int SEEN_ALOAD_0 = 1;
  private final static int SEEN_ALOAD_0ALOAD_0 = 2;
  private final static int SEEN_ALOAD_0ALOAD_0GETFIELD = 3;
  private String fieldOwner;
  private String fieldName;
  private String fieldDesc;
  public RemoveGetFieldPutFieldAdapter(MethodVisitor mv) {
    super(mv);
  }
  @Override 
  public void visitVarInsn(int opcode, int var) {
    switch (state) {
    case SEEN_NOTHING: // S0 -&gt; S1
      if (opcode == ALOAD &amp;&amp; var == 0) {
        state = SEEN_ALOAD_0;
        return;
      }
      break;
    case SEEN_ALOAD_0: // S1 -&gt; S2
      if (opcode == ALOAD &amp;&amp; var == 0) {
        state = SEEN_ALOAD_0ALOAD_0;
        return;
      }
      break;
    case SEEN_ALOAD_0ALOAD_0: // S2 -&gt; S2
      if (opcode == ALOAD &amp;&amp; var == 0) {
        mv.visitVarInsn(ALOAD, 0);
        return;
      }
      break;
    }
    visitInsn();
    mv.visitVarInsn(opcode, var);
  }
  @Override
  public void visitFieldInsn(int opcode, String owner, String name,
      String desc) {
    switch (state) {
    case SEEN_ALOAD_0ALOAD_0: // S2 -&gt; S3
      if (opcode == GETFIELD) {
        state = SEEN_ALOAD_0ALOAD_0GETFIELD;
        fieldOwner = owner;
        fieldName = name;
        fieldDesc = desc;
        return;
      }
      break;
    case SEEN_ALOAD_0ALOAD_0GETFIELD: // S3 -&gt; S0
      if (opcode == PUTFIELD &amp;&amp; name.equals(fieldName)) {
        state = SEEN_NOTHING;
        return;
      }
      break;
    }
    visitInsn();
    mv.visitFieldInsn(opcode, owner, name, desc);
  }
  @Override protected void visitInsn() {
    switch (state) {
    case SEEN_ALOAD_0: // S1 -&gt; S0
      mv.visitVarInsn(ALOAD, 0);
      break;
    case SEEN_ALOAD_0ALOAD_0: // S2 -&gt; S0
      mv.visitVarInsn(ALOAD, 0);
      mv.visitVarInsn(ALOAD, 0);
      break;
    case SEEN_ALOAD_0ALOAD_0GETFIELD: // S3 -&gt; S0
      mv.visitVarInsn(ALOAD, 0);
      mv.visitVarInsn(ALOAD, 0);
      mv.visitFieldInsn(GETFIELD, fieldOwner, fieldName, fieldDesc);
      break;
    }
    state = SEEN_NOTHING;
  }
}
</pre>
<div class="Standard">
Note that, for the same reasons as in the <tt>AddTimerAdapter</tt> case in section <a class="Reference" href="#sub:Stateless-transformations">3.2.4↑</a>, the statefull transformations presented in this section do not need to transform stack map frames<a class="IndexReference" name="entry-frames-updating-1" href="#index-frames-updating">↓</a>: the original frames stay valid after the transformation. They don’t even need to transform the local variables and operand stack size. Finally it must be noted that statefull transformations are not limited to transformations that detect and transform instruction sequences. Many other types of transformation are also statefull. This is the case, for instance, of the method adapters presented in the next section.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.3">3.3</a> Tools<a class="Label" name="sub:MethodTools"> </a>
</h2>
<div class="Standard">
The <tt>org.objectweb.asm.commons</tt> package contains some predefined method adapters that can be useful to define your own adapters. This section presents three of them and shows how they can be used with the <tt>AddTimerAdapter</tt> example of section <a class="Reference" href="#sub:Stateless-transformations">3.2.4↑</a>. It also shows how the tools seen in the previous chapter can be used to ease method generation or transformation.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.1">3.3.1</a> Basic tools
</h3>
<div class="Standard">
The tools presented in section <a class="Reference" href="#sub:ClassTools">2.3↑</a> can also be used for methods.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--8"></a><tt>Type</tt>
</h4>
<div class="Standard">
Many bytecode instructions, such as <i>x<tt></tt></i>LOAD, <i>x<tt></tt></i>ADD or <i>x<tt></tt></i>RETURN, depend on the type to which they are applied. The <tt>Type</tt><a class="IndexReference" name="entry-Type_-1" href="#index-Type_">↓</a> class provides a <tt>getOpcode</tt> method that can be used to get, for these instructions, the opcode corresponding to a given type. This method takes as parameter an opcode for the <tt>int</tt> type, and returns the opcode for the type on which it is called. For instance <tt>t.getOpcode(IMUL)</tt> returns <tt>FMUL</tt> if <tt>t</tt> is equal to <tt>Type.FLOAT_TYPE</tt>.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--9"></a><tt>TraceClassVisitor</tt>
</h4>
<div class="Standard">
This class<a class="IndexReference" name="entry-TraceClassVisitor_-1" href="#index-TraceClassVisitor_">↓</a>, which has already been presented in the previous chapter, prints a textual representation of the classes it visits, <i>including a textual representation of their methods</i>, in a form very similar to the one used in this chapter. It can therefore be used to trace the content of generated or transformed methods at any point in a transformation chain. For example:
</div>
<pre class="LyX-Code">
java -classpath asm.jar:asm-util.jar \
     org.objectweb.asm.util.TraceClassVisitor \
     java.lang.Void
</pre>
<div class="Standard">
prints:
</div>
<pre class="LyX-Code">
// class version 49.0 (49)
// access flags 49
public final class java/lang/Void {
  // access flags 25
  // signature Ljava/lang/Class&lt;Ljava/lang/Void;&gt;;
  // declaration: java.lang.Class&lt;java.lang.Void&gt;
  public final static Ljava/lang/Class; TYPE
  // access flags 2
  private &lt;init&gt;()V
    ALOAD 0
    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V
    RETURN
    MAXSTACK = 1
    MAXLOCALS = 1
  // access flags 8
  static &lt;clinit&gt;()V
    LDC "void"
    INVOKESTATIC java/lang/Class.getPrimitiveClass (...)...
    PUTSTATIC java/lang/Void.TYPE : Ljava/lang/Class;
    RETURN
    MAXSTACK = 1
    MAXLOCALS = 0
}
</pre>
<div class="Standard">
This shows how to generate a static block<a class="IndexReference" name="entry-static-blocks-0" href="#index-static-blocks">↓</a> <tt>static { ... }</tt>, namely with a <tt>&lt;clinit&gt;</tt> method (for CLass INITializer). Note that if you want to trace the content of a single method at some point in a chain, instead of tracing all the content of its class, you can use <tt>TraceMethodVisitor</tt><a class="IndexReference" name="entry-TraceMethodVisitor_-0" href="#index-TraceMethodVisitor_">↓</a> instead of <tt>TraceClassVisitor</tt> (in this case you must specify the backend explicitly; here we use a <tt>Textifier</tt>):
</div>
<pre class="LyX-Code">
<tt>public MethodVisitor visitMethod(int access, String name,</tt>
 <tt>   String desc, String signature, String[] exceptions) {</tt>
 <tt> MethodVisitor mv = cv.visitMethod(access, name, desc, signature,</tt>
 <tt>       exceptions);</tt>
 <tt> if (</tt><i>debug</i> &amp;&amp; mv != null &amp;&amp; ...<tt>) { // if this method must be traced</tt>
    Printer p = new Textifier(ASM4) {
      @Override <tt>public void visitMethodEnd() {</tt>
 <tt>       print(</tt><i>aPrintWriter<tt></tt></i>); // print it after it has been visited 
 <tt>     }</tt>
<tt>    };</tt>
<tt>    mv = new TraceMethodVisitor(mv, p);</tt>
  }
  return new <i>MyMethodAdapter</i>(mv);
<tt>}</tt>
</pre>
<div class="Standard">
This code prints the method after transformation by <tt>MyMethodAdapter</tt>.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--10"></a><tt>CheckClassAdapter</tt>
</h4>
<div class="Standard">
This class<a class="IndexReference" name="entry-CheckClassAdapter_-1" href="#index-CheckClassAdapter_">↓</a>, which has already been presented in the previous chapter, checks that the <tt>ClassVisitor</tt> methods are called in the appropriate order, and with valid arguments, and it does the same for the <tt>MethodVisitor</tt> methods. It can therefore be used to check that the <tt>MethodVisitor</tt> API is correctly used at any point in a transformation chain. Like with <tt>TraceMethodVisitor</tt>, you can use the <tt>CheckMethodAdapter</tt><a class="IndexReference" name="entry-CheckMethodAdapter_-0" href="#index-CheckMethodAdapter_">↓</a> class to check a single method instead of checking all its class:
</div>
<pre class="LyX-Code">
<tt>public MethodVisitor visitMethod(int access, String name,</tt>
 <tt>   String desc, String signature, String[] exceptions) {</tt>
 <tt> MethodVisitor mv = cv.visitMethod(access, name, desc, signature,</tt>
 <tt>       exceptions);</tt>
 <tt> if (</tt><i>debug</i> &amp;&amp; mv != null &amp;&amp; ...<tt>) { // if this method must be checked</tt>
 <tt>   mv = new CheckMethodAdapter(mv);</tt>
  }
  return new <i>MyMethodAdapter</i>(mv);
<tt>}</tt>
</pre>
<div class="Standard">
This code checks that <tt>MyMethodAdapter</tt> uses the <tt>MethodVisitor</tt> API correctly. Note however that this adapter will <i>not</i> check that the bytecode is correct: for instance it will not detect that <tt>ISTORE</tt> <tt>1</tt> <tt>ALOAD</tt> <tt>1</tt> is invalid. In fact this kind of error <i>can</i> be detected, if you use the other constructor of <tt>CheckMethodAdapter</tt> (see the Javadoc), and if you provide valid <tt>maxStack</tt> and <tt>maxLocals</tt> arguments in <tt>visitMaxs</tt>.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--11"></a><tt>ASMifier</tt>
</h4>
<div class="Standard">
This class<a class="IndexReference" name="entry-ASMifier_-1" href="#index-ASMifier_">↓</a>, which has already been presented in the previous chapter, also works with the content of methods. It can be used to know how to generate some compiled code with ASM: just write the corresponding source code in Java, compile it with <tt>javac</tt>, and use the <tt>ASMifier</tt> to visit this class. You will get the ASM code to generate the bytecode corresponding to your source code.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.2">3.3.2</a> <tt>AnalyzerAdapter</tt><a class="IndexReference" name="entry-AnalyzerAdapter_-0" href="#index-AnalyzerAdapter_">↓</a>
</h3>
<div class="Standard">
This method adapter computes the stack map frames before each instruction, based on the frames visited in <tt>visitFrame</tt>. Indeed, as explained in section <a class="Reference" href="#sub:Frames">3.1.5↑</a>, <tt>visitFrame</tt> is only called before some specific instructions in a method, in order to save space, and because &ldquo;the other frames can be easily and quickly inferred from these ones&rdquo;. This is what this adapter does. Of course it only works on classes that contain precomputed stack map frames, i.e. compiled with Java 6 or higher (or previously upgraded to Java 6 with an ASM adapter using the <tt>COMPUTE_FRAMES</tt> option).
</div>
<div class="Standard">
In the case of our <tt>AddTimerAdapter</tt> example, this adapter could be used to get the size of the operand stack just before the <tt>RETURN</tt> instructions, thereby allowing to compute an optimal transformed value for <tt>maxStack</tt> in <tt>visitMaxs</tt> (in fact this method is not recommended in practice, because it is much less efficient than using <tt>COMPUTE_MAXS</tt>):
</div>
<pre class="LyX-Code">
class AddTimerMethodAdapter2 <b>extends AnalyzerAdapter</b> {
  <b>private int maxStack;</b>
  public AddTimerMethodAdapter2(String owner, int access,
      String name, String desc, MethodVisitor mv) {
    super(ASM4, owner, access, name, desc, mv);
  }
  @Override public void visitCode() {
    <b>super</b>.visitCode();
    mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
    mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
        "currentTimeMillis", "()J");
    mv.visitInsn(LSUB);
    mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
    <b>maxStack = 4;</b>
  }
  @Override public void visitInsn(int opcode) {
    if ((opcode &gt;= IRETURN &amp;&amp; opcode &lt;= RETURN) || opcode == ATHROW) {
      mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
      mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
          "currentTimeMillis", "()J");
      mv.visitInsn(LADD);
      mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
      <b>maxStack = Math.max(maxStack, stack.size() + 4);</b>
    }
    <b>super</b>.visitInsn(opcode);
  }
  @Override public void visitMaxs(int maxStack, int maxLocals) {
    <b>super</b>.visitMaxs(<b>Math.max(this.maxStack, maxStack)</b>, maxLocals);
  }
}
</pre>
<div class="Standard">
The <tt>stack</tt> field is defined in the <tt>AnalyzerAdapter</tt> class, and contains the types in operand stack. More precisely, in a <tt>visit<i>Xxx</i>Insn</tt>, and before the overridden method is called, this list contains the state of the operand stack just before this instruction. Note that the overridden methods <i>must</i> be called so that the <tt>stack</tt> field is correctly updated (hence the use of <tt>super</tt> instead of <tt>mv</tt> in the original code).
</div>
<div class="Standard">
Alternatively the new instructions can be inserted by calling the methods of the super class: the effect is that the frames for these instructions will be computed by <tt>AnalyzerAdapter</tt>. Since, in addition, this adapter updates the arguments of <tt>visitMaxs</tt> based on the frames it computes, we do not need to update them ourselves:
</div>
<pre class="LyX-Code">
class AddTimerMethodAdapter3 extends AnalyzerAdapter {
  public AddTimerMethodAdapter3(String owner, int access,
      String name, String desc, MethodVisitor mv) {
    super(ASM4, owner, access, name, desc, mv);
  }
  @Override public void visitCode() {
    super.visitCode();
    <b>super</b>.visitFieldInsn(GETSTATIC, owner, "timer", "J");
    <b>super</b>.visitMethodInsn(INVOKESTATIC, "java/lang/System",
        "currentTimeMillis", "()J");
    <b>super</b>.visitInsn(LSUB);
    <b>super</b>.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
  }
  @Override public void visitInsn(int opcode) {
    if ((opcode &gt;= IRETURN &amp;&amp; opcode &lt;= RETURN) || opcode == ATHROW) {
      <b>super</b>.visitFieldInsn(GETSTATIC, owner, "timer", "J");
      <b>super</b>.visitMethodInsn(INVOKESTATIC, "java/lang/System",
          "currentTimeMillis", "()J");
      <b>super</b>.visitInsn(LADD);
      <b>super</b>.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
    }
    super.visitInsn(opcode);
  }
}
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.3">3.3.3</a> <tt>LocalVariablesSorter</tt><a class="IndexReference" name="entry-LocalVariablesSorter_-0" href="#index-LocalVariablesSorter_">↓</a>
</h3>
<div class="Standard">
This method adapter renumbers<a class="IndexReference" name="entry-local-variables-renumbering-0" href="#index-local-variables-renumbering">↓</a> the local variables used in a method in the order they appear in this method. For instance in a method with two parameters, the first local variable read or written whose index is greater than or equal to 3 — the first three local variables correspond to this and to the two method parameters, and can therefore not be changed — is assigned index 3, the second one is assigned index 4, and so on. This adapter is useful to insert<a class="IndexReference" name="entry-local-variables-inserting-0" href="#index-local-variables-inserting">↓</a> new local variables in a method. Without this adapter it would be necessary to add new local variables after all the existing ones, but unfortunately their number is not known until the end of the method, in <tt>visitMaxs</tt>.
</div>
<div class="Standard">
In order to show how this adapter can be used, let’s suppose that we want to use a local variable to implement <tt>AddTimerAdapter</tt>:
</div>
<pre class="LyX-Code">
public class C {
  <b>public static long timer;</b>
  public void m() throws Exception {
    <b>long t = System.currentTimeMillis();</b>
    Thread.sleep(100);
    <b>timer += System.currentTimeMillis() - t;</b>
  }
}
</pre>
<div class="Standard">
This can be done easily by extending <tt>LocalVariablesSorter</tt>, and by using the <tt>newLocal</tt> method defined in this class:
</div>
<pre class="LyX-Code">
class AddTimerMethodAdapter4 <b>extends LocalVariablesSorter</b> {
  <b>private int time;</b>
  public AddTimerMethodAdapter4(int access, String desc,
      MethodVisitor mv) {
    super(ASM4, access, desc, mv);
  }
  @Override public void visitCode() {
    super.visitCode();
    mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
        "currentTimeMillis", "()J");
    <b>time = newLocal(Type.LONG_TYPE);</b>
    mv.visitVarInsn(LSTORE, <b>time</b>);
  }
  @Override public void visitInsn(int opcode) {
    if ((opcode &gt;= IRETURN &amp;&amp; opcode &lt;= RETURN) || opcode == ATHROW) {
      mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
          "currentTimeMillis", "()J");
      mv.visitVarInsn(LLOAD, <b>time</b>);
      mv.visitInsn(LSUB);
      mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
      mv.visitInsn(LADD);
      mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
    }
    super.visitInsn(opcode);
  }
  @Override public void visitMaxs(int maxStack, int maxLocals) {
    super.visitMaxs(maxStack + 4, maxLocals);
  }
}
</pre>
<div class="Standard">
Note that the original frames associated to the method become invalid when the local variables are renumbered, and a fortiori when new local variables are inserted. Hopefully it is possible to avoid recomputing these frames from scratch: indeed no frames must be added or removed, and it &ldquo;suffices&rdquo; to reorder the content of local variables in the original frames to get the frames of the transformed method. <tt>LocalVariablesSorter</tt> takes care of that automatically. If you also need to do incremental stack map frame updates<a class="IndexReference" name="entry-frames-updating-2" href="#index-frames-updating">↓</a> for one of your method adapters, you can inspire yourself from the source of this class.
</div>
<div class="Standard">
As you can see above using a local variable does not solve the problem we had in the original version of this class, concerning the worst case value for <tt>maxStack</tt>. If you want to use an <tt>AnalyzerAdapter</tt> to solve that, in addition to a <tt>LocalVariablesSorter</tt>, you must use these adapters through delegation instead of via inheritance (since multiple inheritance is not possible):
</div>
<pre class="LyX-Code">
class AddTimerMethodAdapter5 <b>extends MethodVisitor</b> {
  <b>public LocalVariablesSorter lvs;</b>
 <b> public AnalyzerAdapter aa;</b>
 <b> private int time;</b>
 <b> private int maxStack;</b>
  public AddTimerMethodAdapter5(MethodVisitor mv) {
    super(ASM4, mv);
  }
  @Override public void visitCode() {
    mv.visitCode();
    mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
        "currentTimeMillis", "()J");
    <b>time = lvs.newLocal(Type.LONG_TYPE);</b>
    mv.visitVarInsn(LSTORE, <b>time</b>);
    <b>maxStack = 4;</b>
  }
  @Override public void visitInsn(int opcode) {
    if ((opcode &gt;= IRETURN &amp;&amp; opcode &lt;= RETURN) || opcode == ATHROW) {
      mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
          "currentTimeMillis", "()J");
      mv.visitVarInsn(LLOAD, <b>time</b>);
      mv.visitInsn(LSUB);
      mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
      mv.visitInsn(LADD);
      mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
      <b>maxStack = Math.max(aa.stack.size() + 4, maxStack);</b>
    }
    mv.visitInsn(opcode);
  }
  @Override public void visitMaxs(int maxStack, int maxLocals) {
    mv.visitMaxs(<b>Math.max(this.maxStack, maxStack)</b>, maxLocals);
  }
}
</pre>
<div class="Standard">
In order to use this adapter you must chain a <tt>LocalVariablesSorter</tt> to an <tt>AnalyzerAdapter</tt>, itself chained to your adapter: the first adapter will sort local variables and update frames accordingly, the analyzer adapter will compute intermediate frames taking into account the renumbering done in the previous adapter, and your adapter will have access to these renumbered intermediate frames. This chain can be constructed as follows in <tt>visitMethod</tt>:
</div>
<pre class="LyX-Code">
mv = cv.visitMethod(access, name, desc, signature, exceptions);
if (!isInterface &amp;&amp; mv != null &amp;&amp; !name.equals("&lt;init&gt;")) {
   AddTimerMethodAdapter5 at = new AddTimerMethodAdapter5(mv);
   at.aa = new AnalyzerAdapter(owner, access, name, desc, at);
   at.lvs = new LocalVariablesSorter(access, desc, at.aa);
   return at.lvs;
}
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.4">3.3.4</a> <tt>AdviceAdapter</tt><a class="IndexReference" name="entry-AdviceAdapter_-0" href="#index-AdviceAdapter_">↓</a>
</h3>
<div class="Standard">
This method adapter is an abstract class that can be used to insert code at the beginning of a method and just before any <tt>RETURN</tt> or <tt>ATHROW</tt> instruction. Its main advantage is that it also works for constructors<a class="IndexReference" name="entry-constructors-2" href="#index-constructors">↓</a>, where code must not be inserted just at the beginning of the constructor, but after the call to the super constructor. In fact most of the code of this adapter is dedicated to the detection of this super constructor call.
</div>
<div class="Standard">
If you look carefully at the <tt>AddTimerAdapter</tt> class in section <a class="Reference" href="#sub:Stateless-transformations">3.2.4↑</a>, you will see that the <tt>AddTimerMethodAdapter</tt> is not used for constructors, because of this problem. By inheriting from <tt>AdviceAdapter</tt> this method adapter can be improved to work on constructors too (note that <tt>AdviceAdapter</tt> inherits from <tt>LocalVariablesSorter</tt>, so we could also easily use a local variable):
</div>
<pre class="LyX-Code">
class AddTimerMethodAdapter6 <b>extends AdviceAdapter</b> {
  public AddTimerMethodAdapter6(int access, String name, String desc,
      MethodVisitor mv) {
    super(ASM4, mv, access, name, desc);
  }
  @Override protected void <b>onMethodEnter</b>() {
    mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
    mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
        "currentTimeMillis", "()J");
    mv.visitInsn(LSUB);
    mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
  }
  @Override protected void <b>onMethodExit</b>(int opcode) {
    mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
    mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
        "currentTimeMillis", "()J");
    mv.visitInsn(LADD);
    mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
  }
  @Override public void visitMaxs(int maxStack, int maxLocals) {
    super.visitMaxs(maxStack + 4, maxLocals);
  }
}
</pre>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-4">4</a> Metadata<a class="Label" name="cha:Metadata"> </a>
</h1>
<div class="Standard">
This chapter explains how to generate and transform compiled Java classes metadata, such as annotations, with the core API. Each section starts with a presentation of one type of metadata, and then presents the corresponding ASM interfaces, components and tools to generate and transform these metadata, with some illustrative examples.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.1">4.1</a> Generics<a class="Label" name="sec:Generics"> </a>
</h2>
<div class="Standard">
Generic classes<a class="IndexReference" name="entry-generic-classes-0" href="#index-generic-classes">↓</a> such as <tt>List&lt;E&gt;</tt>, and classes using them, contain information about the generic types they declare or use. This information is not used at runtime by the bytecode instructions, but it can be accessed via the reflection API. It is also used by compilers, for separate compilation.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.1.1">4.1.1</a> Structure
</h3>
<div class="Standard">
For backward compatibility reasons the information about generic types is not stored in type or method descriptors (which were defined long before the introduction of generics in Java 5), but in similar constructs called type, method and class <i>signatures</i><a class="IndexReference" name="entry-signature-0" href="#index-signature">↓</a>. These signatures are stored in addition to descriptors in class, field and method <i>declarations</i> when a generic type is involved (generic types do not affect the bytecode of methods: the compiler uses them to perform static type checks, but then compiles methods as if they were not used, by reintroducing type casts where necessary).
</div>
<div class="Standard">
Unlike type and method descriptors, and due to the recursive nature of generic types (a generic type can be parameterized by a generic type — consider for example <tt>List&lt;List&lt;E&gt;&gt;</tt>) the grammar of type signatures is quite complex. It is given by the following rules (see the Java Virtual Machine Specification for a complete description of these rules):
</div>
<blockquote class="Quote">
<span class="small"><i>TypeSignature</i>: <tt><b>Z</b></tt> <b>|</b> <tt><b>C</b></tt> <b>|</b> <tt><b>B</b></tt> <b>|</b> <tt><b>S</b></tt> <b>|</b> <tt><b>I</b></tt> <b>|</b> <tt><b>F</b></tt> <b>|</b> <tt><b>J</b></tt> <b>|</b> <tt><b>D</b></tt> | <i>FieldTypeSignature</i></span><br/>
<span class="small"><i>FieldTypeSignature</i>: <i>ClassTypeSignature</i> | <tt><b>[</b></tt> <i>TypeSignature</i> | <i>TypeVar</i></span><br/>
<span class="small"><i>ClassTypeSignature</i>: <tt><b>L</b></tt> <i>Id</i> ( <tt><b>/</b></tt> <i>Id</i> )* <i>TypeArgs</i>? ( <tt><b>.</b></tt> <i>Id</i> <i>TypeArgs</i>? )* <tt><b>;</b></tt></span><br/>
<span class="small"><i>TypeArgs</i>: <tt><b>&lt;</b></tt> <i>TypeArg</i>+ <tt><b>&gt;</b></tt></span><br/>
<span class="small"><i>TypeArg</i>: <tt><b>*</b></tt> | ( <tt><b>+</b></tt> | <tt><b>-</b></tt> )? <i>FieldTypeSignature</i></span><br/>
<span class="small"><i>TypeVar</i>: <tt><b>T</b></tt> <i>Id</i> <tt><b>;</b></tt></span>
</blockquote>
<div class="Standard">
The first rule says that a <i>type signature</i><a class="IndexReference" name="entry-type-signature-0" href="#index-type-signature">↓</a> is either a primitive type descriptor or a field type signature. The second rule defines a field type signature as a class type signature, an array type signature, or a type variable. The third rule defines class type signatures: they are class type descriptors with possible type arguments, between angle brackets, after the main class name or after the inner class names (prefixed with dots). The remaining rules define type arguments and type variables. Note that a type argument can be a complete field type signature, with its own type arguments: type signatures can therefore be very complex (see Figure <a class="Reference" href="#fig:Sample-type-signatures">4.1↓</a>).
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:Sample-type-signatures"> </a><div class="figure">
<div class="center">
<table>
<tr>
<td align="left" valign="top" colspan="2">
Java type and corresponding type signature
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
<tt>List&lt;E&gt;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
<tt>Ljava/util/List&lt;TE;&gt;;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
<tt>List&lt;?&gt;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
<tt>Ljava/util/List&lt;*&gt;;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
<tt>List&lt;? extends Number&gt;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
<tt>Ljava/util/List&lt;+Ljava/lang/Number;&gt;;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
<tt>List&lt;? super Integer&gt;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
<tt>Ljava/util/List&lt;-Ljava/lang/Integer;&gt;;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
<tt>List&lt;List&lt;String&gt;[]&gt;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
 
</td>
<td align="left" valign="top">
<tt>Ljava/util/List&lt;[Ljava/util/List&lt;Ljava/lang/String;&gt;;&gt;;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
<tt>HashMap&lt;K, V&gt;.HashIterator&lt;K&gt;</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
<tt>Ljava/util/HashMap&lt;TK;TV;&gt;.HashIterator&lt;TK;&gt;;</tt>
</td>

</tr>

</table>

</div>
<div class="caption">
Figure 4.1 Sample type signatures
</div>

</div>

</div>

</div>
<div class="Standard">
Method signatures extend method descriptors like type signatures extend type descriptors. A <i>method signature</i><a class="IndexReference" name="entry-method-signature-0" href="#index-method-signature">↓</a> describes the type signatures of the method parameters and the signature of its return type. Unlike method descriptors, it also contains the signatures of the exceptions thrown by the method, preceded by <tt>^</tt>, and can also contain optional formal type parameters between angle brackets:
</div>
<blockquote class="Quote">
<span class="small"><i>MethodTypeSignature</i>:<i><br/>
</i></span><span class="default"><span class="unknown">\verb</span>! !</span><span class="small"><i>TypeParams</i>? <tt><b>(</b></tt> <i>TypeSignature</i>* <tt><b>)</b></tt> ( <i>TypeSignature</i> | <tt><b>V</b></tt> ) <i>Exception</i>*</span><br/>
<span class="small"><i>Exception:</i> <tt><b>^</b></tt><i>ClassTypeSignature</i> | <tt><b>^</b></tt><i>TypeVar</i></span><br/>
<span class="small"><i>TypeParams</i>: <tt><b>&lt;</b></tt> <i>TypeParam</i>+ <tt><b>&gt;</b></tt></span><br/>
<span class="small"><i>TypeParam</i>: <i>Id</i> <tt><b>:</b></tt> <i>FieldTypeSignature</i>? ( <tt><b>:</b></tt> <i>FieldTypeSignature</i> )*</span>
</blockquote>
<div class="Standard">
For example the method signature of the following generic static method, parameterized by the type variable <tt>T</tt>:
</div>
<blockquote class="Quote">
<tt>static &lt;T&gt; Class&lt;? extends T&gt; m (int n)</tt>
</blockquote>
<div class="Standard">
is the following method signature:
</div>
<blockquote class="Quote">
<tt>&lt;T:Ljava/lang/Object;&gt;(I)Ljava/lang/Class&lt;+TT;&gt;;</tt>
</blockquote>
<div class="Standard">
Finally a <i>class signature</i><a class="IndexReference" name="entry-class-signature-0" href="#index-class-signature">↓</a>, which must not be confused with a class type signature, is defined as the type signature of its super class, followed by the type signatures of the implemented interfaces, and with optional formal type parameters:
</div>
<blockquote class="Quote">
<span class="small"><i>ClassSignature</i>: <i>TypeParams</i>? <i>ClassTypeSignature</i> <i>ClassTypeSignature</i>*</span>
</blockquote>
<div class="Standard">
For example the class signature of a class declared as <tt>C&lt;E&gt; extends List&lt;E&gt;</tt> is <tt>&lt;E:Ljava/lang/Object;&gt;Ljava/util/List&lt;TE;&gt;;</tt>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.1.2">4.1.2</a> Interfaces and components
</h3>
<div class="Standard">
Like for descriptors, and for the same efficiency reasons (see section <a class="Reference" href="#sub:Type">2.3.1↑</a>), the ASM API exposes signatures as they as stored in compiled classes (the main occurences of signatures are in the <tt>visit</tt>, <tt>visitField</tt> and <tt>visitMethod</tt> methods of the <tt>ClassVisitor</tt> class, as an optional class, type or method signature argument respectively). Hopefully it also provides some tools to generate and transform signatures, in the <tt>org.objectweb.asm.signature</tt> package, based on the <tt>SignatureVisitor</tt> abstract class (see Figure <a class="Reference" href="#fig:The-SignatureVisitor-interface">4.2↓</a>).
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:The-SignatureVisitor-interface"> </a><div class="figure">
<pre class="LyX-Code">
public abstract class <b>SignatureVisitor</b> {
  public final static char EXTENDS = ’+’;
  public final static char SUPER = ’-’;
  public final static char INSTANCEOF = ’=’;
  public SignatureVisitor(int api);
  public void visitFormalTypeParameter(String name);
  public SignatureVisitor visitClassBound();
  public SignatureVisitor visitInterfaceBound();
  public SignatureVisitor visitSuperclass();
  public SignatureVisitor visitInterface();
  public SignatureVisitor visitParameterType();
  public SignatureVisitor visitReturnType();
  public SignatureVisitor visitExceptionType();
  public void <b>visitBaseType</b>(char descriptor);
  public void <b>visitTypeVariable</b>(String name);
  public SignatureVisitor <b>visitArrayType</b>();
  public void <b>visitClassType</b>(String name);
  public void <b>visitInnerClassType</b>(String name);
  public void <b>visitTypeArgument</b>();
  public SignatureVisitor <b>visitTypeArgument</b>(char wildcard);
  public void <b>visitEnd</b>();
}
</pre>
<div class="caption">
Figure 4.2 The <tt>SignatureVisitor</tt><a class="IndexReference" name="entry-SignatureVisitor_-0" href="#index-SignatureVisitor_">↓</a> class
</div>

</div>

</div>

</div>
<div class="Standard">
This abstract class is used to visit type signatures, method signatures and class signatures. The methods used to visit type signatures are in bold, and must be called in the following order, which reflects the previous grammar rules (note that two of them return a <tt>SignatureVisitor</tt>: this is due to the recursive definition of type signatures):
</div>
<pre class="LyX-Code">
<tt>visitBaseType<span class="unknown">\normalfont</span>~|~visitArrayType<span class="unknown">\normalfont</span>~|~visitTypeVariable<span class="unknown">\normalfont</span>~|</tt>
<tt><span class="unknown">\normalfont</span>(~visitClassType<span class="unknown">\normalfont</span>~visitTypeArgument</tt><span class="unknown">\normalfont</span>*
 <tt> <span class="unknown">\normalfont</span>(~visitInnerClassType<span class="unknown">\normalfont</span>~visitTypeArgument<span class="unknown">\normalfont</span>~)*~visitEnd</tt><span class="unknown">\normalfont</span>~)~)
</pre>
<div class="Standard">
The methods used to visit method signatures are the following:
</div>
<pre class="LyX-Code">
<tt><span class="unknown">\normalfont</span>(~visitFormalTypeParameter<span class="unknown">\normalfont</span>~visitClassBound<span class="unknown">\normalfont</span>?~visitInterfaceBound</tt><span class="unknown">\normalfont</span>*~)*
<tt>visitParameterType<span class="unknown">\normalfont</span>*~visitReturnType<span class="unknown">\normalfont</span>~visitExceptionType<span class="unknown">\normalfont</span>*</tt>
</pre>
<div class="Standard">
Finally the methods used to visit class signatures are:
</div>
<pre class="LyX-Code">
<tt><span class="unknown">\normalfont</span>(~</tt>visitFormalTypeParameter<tt><span class="unknown">\normalfont</span>~</tt>visitClassBound<tt><span class="unknown">\normalfont</span>?~</tt>visitInterfaceBound<span class="unknown">\normalfont</span>*~)*
visitSuperClass<tt><span class="unknown">\normalfont</span>~</tt>visitInterface<tt><span class="unknown">\normalfont</span>*</tt>
</pre>
<div class="Standard">
Most of these methods return a <tt>SignatureVisitor</tt>: it is intended to visit a <i>type</i> signature. Note that, unlike with the <tt>MethodVisitor</tt>s returned by a <tt>ClassVisitor</tt>, the <tt>SignatureVisitor</tt>s returned by a <tt>SignatureVisitor</tt> must not be <tt>null</tt>, and must be used sequentially: in fact no method of the parent visitor must be called before a nested signature is fully visited.
</div>
<div class="Standard">
Like for classes, the ASM API provides two components based on this API: the <tt>SignatureReader</tt><a class="IndexReference" name="entry-SignatureReader_-0" href="#index-SignatureReader_">↓</a> component parses a signature and calls the appropriate visit methods on a given signature visitor, and the <tt>SignatureWriter</tt><a class="IndexReference" name="entry-SignatureWriter_-0" href="#index-SignatureWriter_">↓</a> component builds a signature based on the method calls it received. 
</div>
<div class="Standard">
These two classes can be used to generate and transform signatures by using the same principles as with classes and methods. For example, let’s suppose you want to rename the class names that appear in some signatures. This can be done with the following signature adapter, which forwards all the method calls it receives unchanged, except for the <tt>visitClassType</tt> and <tt>visitInnerClassType</tt> methods (we suppose here that <tt>sv</tt> methods always return <tt>this</tt>, which is the case of <tt>SignatureWriter</tt>):
</div>
<pre class="LyX-Code">
public class RenameSignatureAdapter extends SignatureVisitor {
  private SignatureVisitor sv;
  <b>private Map&lt;String, String&gt; renaming;</b>
 <b> private String oldName;</b>
  public RenameSignatureAdapter(SignatureVisitor sv,
      <b>Map&lt;String, String&gt; renaming</b>) {
    super(ASM4);
    this.sv = sv;
    <b>this.renaming = renaming;</b>
  }
  public void visitFormalTypeParameter(String name) {
    sv.visitFormalTypeParameter(name);
  }
  public SignatureVisitor visitClassBound() {
    sv.visitClassBound();
    return this;
  }
  public SignatureVisitor visitInterfaceBound() {
    sv.visitInterfaceBound();
    return this;
  }
  ...
  public void visitClassType(String name) {
    <b>oldName = name;</b>
 <b>   String newName = renaming.get(oldName);</b>
 <b>   sv.visitClassType(newName == null ? name : newName);</b>
  }
  public void visitInnerClassType(String name) {
    <b>oldName = oldName + "." + name;</b>
 <b>   String newName = renaming.get(oldName);</b>
 <b>   sv.visitInnerClassType(newName == null ? name : newName);</b>
  }
  public void visitTypeArgument() {
    sv.visitTypeArgument();
  }
  public SignatureVisitor visitTypeArgument(char wildcard) {
    sv.visitTypeArgument(wildcard);
    return this;
  }
  public void visitEnd() {
    sv.visitEnd();
  }
}
</pre>
<div class="Standard">
Then the result of the following code is <tt>"LA&lt;TK;TV;&gt;.B&lt;TK;&gt;;"</tt>:
</div>
<pre class="LyX-Code">
String s = "<b>Ljava/util/HashMap&lt;TK;TV;&gt;.HashIterator&lt;TK;&gt;;</b>";
Map&lt;String, String&gt; renaming = new HashMap&lt;String, String&gt;();
renaming.put(<b>"java/util/HashMap", "A"</b>);
renaming.put(<b>"java/util/HashMap.HashIterator", "B"</b>);
SignatureWriter sw = new SignatureWriter();
SignatureVisitor sa = new RenameSignatureAdapter(sw, renaming);
SignatureReader sr = new SignatureReader(s);
sr.acceptType(sa);
sw.toString();
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.1.3">4.1.3</a> Tools
</h3>
<div class="Standard">
The <tt>TraceClassVisitor</tt><a class="IndexReference" name="entry-TraceClassVisitor_-2" href="#index-TraceClassVisitor_">↓</a> and <tt>ASMifier</tt><a class="IndexReference" name="entry-ASMifier_-2" href="#index-ASMifier_">↓</a> classes, presented in section <a class="Reference" href="#sub:ClassTools">2.3↑</a>, print the signatures contained in class files in their internal form. They can be used to find the signature corresponding to a given generic type in the following way: write a Java class with some generic types, compile it, and use these command line tools to find the corresponding signatures.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.2">4.2</a> Annotations<a class="Label" name="sec:Annotations"> </a>
</h2>
<div class="Standard">
Class, field, method and method parameter annotations, such as <tt>@Deprecated</tt> or <tt>@Override</tt>, are stored in compiled classes if their retention policy is not <tt>RetentionPolicy.SOURCE</tt>. This information is not used at runtime by the bytecode instructions, but it can be accessed via the reflection API if the retention policy is <tt>RetentionPolicy.RUNTIME</tt>. It can also be used by compilers.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.2.1">4.2.1</a> Structure
</h3>
<div class="Standard">
Annotations<a class="IndexReference" name="entry-annotations-0" href="#index-annotations">↓</a> in source code can have various forms, such as <tt>@Deprecated</tt>, <tt>@Retention(RetentionPolicy.CLASS)</tt> or <tt>@Task(desc="refactor", id=1)</tt>. Internally, however, all annotations have the same form and are specified by an annotation type and by a set of name value pairs, where values are restricted to:
</div>
<ul>
<li>
primitive, <tt>String</tt> or <tt>Class</tt> values,
</li>
<li>
enum values,
</li>
<li>
annotation values,
</li>
<li>
arrays of the above values.
</li>

</ul>
<div class="Standard">
Note that an annotation can contain other annotations, or even annotation arrays. Annotations can therefore be quite complex.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.2.2">4.2.2</a> Interfaces and components
</h3>
<div class="Standard">
The ASM API for generating and transforming annotations is based on the <tt>AnnotationVisitor</tt> abstract class (see Figure <a class="Reference" href="#fig:The-AnnotationVisitor-interface">4.3↓</a>).
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:The-AnnotationVisitor-interface"> </a><div class="figure">
<pre class="LyX-Code">
public abstract class <b>AnnotationVisitor</b> {
  public AnnotationVisitor(int api);
  public AnnotationVisitor(int api, AnnotationVisitor av);
  public void <b>visit</b>(String name, Object value);
  public void <b>visitEnum</b>(String name, String desc, String value);
  public AnnotationVisitor <b>visitAnnotation</b>(String name, String desc);
  public AnnotationVisitor <b>visitArray</b>(String name);
  public void <b>visitEnd</b>();
}
</pre>
<div class="caption">
Figure 4.3 The <tt>AnnotationVisitor</tt><a class="IndexReference" name="entry-AnnotationVisitor_-0" href="#index-AnnotationVisitor_">↓</a> class
</div>

</div>

</div>

</div>
<div class="Standard">
The methods of this class are used to visit the name value pairs of an annotation (the annnotation type is visited in the methods that return this type, i.e. the <tt>visitAnnotation</tt> methods). The first method is used for primitive, <tt>String</tt> and <tt>Class</tt> values (the later being represented by <tt>Type</tt> objects), and the others are used for enum, annotation and array values. They can be called in any order, except <tt>visitEnd</tt>:
</div>
<pre class="LyX-Code">
<span class="unknown">\normalfont</span>(~visit<span class="unknown">\normalfont</span>~|~visitEnum<span class="unknown">\normalfont</span>~|~visitAnnotation<span class="unknown">\normalfont</span>~|~visitArray<span class="unknown">\normalfont</span>~)*~visitEnd
</pre>
<div class="Standard">
Note that two methods return an <tt>AnnotationVisitor</tt>: this is because annotations can contain other annotations. Also unlike with the <tt>MethodVisitor</tt>s returned by a <tt>ClassVisitor</tt>, the <tt>AnnotationVisitor</tt>s returned by these two methods must be used sequentially: in fact no method of the parent visitor must be called before a nested annotation is fully visited.
</div>
<div class="Standard">
Note also that the <tt>visitArray</tt> method returns an <tt>AnnotationVisitor</tt> to visit the elements of an array. However, since the elements of an array are not named, the <tt>name</tt> arguments are ignored by the methods of the visitor returned by <tt>visitArray</tt>, and can be set to <tt>null</tt>.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--12"></a>Adding, removing and detecting annotations
</h4>
<div class="Standard">
Like for fields and methods, an annotation can be removed by returning <tt>null</tt> in the <tt>visitAnnotation</tt> methods:
</div>
<pre class="LyX-Code">
public class RemoveAnnotationAdapter extends ClassVisitor {
  private String annDesc;
  public RemoveAnnotationAdapter(ClassVisitor cv, String annDesc) {
    super(ASM4, cv);
    this.annDesc = annDesc;
  }
  @Override
  public AnnotationVisitor visitAnnotation(String desc, boolean vis) {
    <b>if (desc.equals(annDesc)) {</b>
      <b>return null;</b>
    <b>}</b>
    return cv.visitAnnotation(desc, vis);
  }
}
</pre>
<div class="Standard">
Adding a class annotation<a class="IndexReference" name="entry-annotations-adding-0" href="#index-annotations-adding">↓</a> is more difficult because of the constraints in which the methods of the <tt>ClassVisitor</tt> class must be called. Indeed all the methods that may follow a <tt>visitAnnotation</tt> must be overridden to detect when all annotations have been visited (method annotations are easier to add, thanks to the <tt>visitCode</tt> method):
</div>
<pre class="LyX-Code">
public class AddAnnotationAdapter extends ClassVisitor {
  private String annotationDesc;
  <b>private boolean isAnnotationPresent;</b>
  public AddAnnotationAdapter(ClassVisitor cv, String annotationDesc) {
    super(ASM4, cv);
    this.annotationDesc = annotationDesc;
  }
  @Override public void visit(int version, int access, String name,
      String signature, String superName, String[] interfaces) {
    <b>int v = (version &amp; 0xFF) &lt; V1_5 ? V1_5 : version;</b>
    cv.visit(<b>v</b>, access, name, signature, superName, interfaces);
  }
  @Override public AnnotationVisitor visitAnnotation(String desc,
      boolean visible) {
    <b>if (visible &amp;&amp; desc.equals(annotationDesc)) {</b>
 <b>     isAnnotationPresent = true;</b>
 <b>   }</b>
    return cv.visitAnnotation(desc, visible);
  }
  @Override public void visitInnerClass(String name, String outerName,
      String innerName, int access) {
    <b>addAnnotation();</b>
    cv.visitInnerClass(name, outerName, innerName, access);
  }
  @Override 
  public FieldVisitor visitField(int access, String name, String desc,
      String signature, Object value) {
    <b>addAnnotation();</b>
    return cv.visitField(access, name, desc, signature, value);
  }
  @Override 
  public MethodVisitor visitMethod(int access, String name,
      String desc, String signature, String[] exceptions) {
    <b>addAnnotation();</b>
    return cv.visitMethod(access, name, desc, signature, exceptions);
  }
  @Override public void visitEnd() {
    <b>addAnnotation();</b>
    cv.visitEnd();
  }
  <b>private void addAnnotation() {</b>
 <b>   if (!isAnnotationPresent) {</b>
 <b>     AnnotationVisitor av = cv.visitAnnotation(annotationDesc, true);</b>
 <b>     if (av != null) {</b>
 <b>       av.visitEnd();</b>
      <b>}</b>
 <b>     isAnnotationPresent = true;</b>
 <b>   }</b>
 <b> }</b>
}
</pre>
<div class="Standard">
Note that this adapter upgrades the class version to 1.5 if it was less than that. This is necessary because the JVM ignores annotations in classes whose version is less than 1.5.
</div>
<div class="Standard">
The last and probably most frequent use case of annotations in class and method adapters is to use annotations in order to parameterize a transformation. For instance you could transform field accesses only for fields that have a <tt>@Persistent</tt> annotation, add logging code only to methods that have a <tt>@Log</tt> annotation, and so on. All these use cases can easily be implemented because annotations must be visited first: class annotations must be visited before fields and methods, and method and parameter annotations must be visited before the code. It is therefore sufficient to set a flag when the desired annotation is detected<a class="IndexReference" name="entry-annotations-detecting-0" href="#index-annotations-detecting">↓</a>, and to use it later on in the transformation, as is done in the above example with the <tt>isAnnotationPresent</tt> flag.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.2.3">4.2.3</a> Tools
</h3>
<div class="Standard">
The <tt>TraceClassVisitor</tt><a class="IndexReference" name="entry-TraceClassVisitor_-3" href="#index-TraceClassVisitor_">↓</a>, <tt>CheckClassAdapter</tt> and <tt>ASMifier</tt> classes, presented in section <a class="Reference" href="#sub:ClassTools">2.3↑</a>, also support annotations (like for methods, it is also possible to use <tt>TraceAnnotationVisitor</tt> or <tt>CheckAnnotationAdapter</tt> to work at the level of individual annotations instead of at the class level). They can be used to see how to generate some specific annotation. For example using:
</div>
<pre class="LyX-Code">
java -classpath asm.jar:asm-util.jar \
     org.objectweb.asm.util.ASMifier \
     java.lang.Deprecated
</pre>
<div class="Standard">
prints code that, after minor refactoring, reads:
</div>
<pre class="LyX-Code">
package asm.java.lang;
import org.objectweb.asm.*;
public class DeprecatedDump implements Opcodes {
  public static byte[] dump() throws Exception {
    ClassWriter cw = new ClassWriter(0);
    AnnotationVisitor av;
    cw.visit(V1_5, ACC_PUBLIC + <b>ACC_ANNOTATION</b> + ACC_ABSTRACT
        + ACC_INTERFACE, "java/lang/Deprecated", null,
        "java/lang/Object",
        new String[] { "java/lang/annotation/Annotation" });
    {
      <b>av = cw.visitAnnotation("Ljava/lang/annotation/Documented;",</b>
 <b>         true);</b>
 <b>     av.visitEnd();</b>
    }
    {
      <b>av = cw.visitAnnotation("Ljava/lang/annotation/Retention;", true);</b>
 <b>     av.visitEnum("value", "Ljava/lang/annotation/RetentionPolicy;",</b>
 <b>         "RUNTIME");</b>
 <b>     av.visitEnd();</b>
    }
    cw.visitEnd();
    return cw.toByteArray();
  }
}
</pre>
<div class="Standard">
This code shows how two create an annotation class, with the <tt>ACC_ANNOTATION</tt> flag, and shows how to create two class annotations, one without value, and one with an enum value. Method and parameter annotations can be created in a similar way, with the <tt>visitAnnotation</tt> and <tt>visitParameterAnnotation</tt> methods defined in the <tt>MethodVisitor</tt> class.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.3">4.3</a> Debug
</h2>
<div class="Standard">
Classes compiled with <tt>javac -g</tt> contain the name of their source file, a mapping between source line numbers and bytecode instructions, and a mapping betwen local variable names in source code and local variable slots in bytecode. This optional information is used in debuggers and in exception stack traces when it is available.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.1">4.3.1</a> Structure
</h3>
<div class="Standard">
The source file name of a class is stored in a dedicated class file structure section (see Figure <a class="Reference" href="#fig:Overall-structure-of-class-file">2.1↑</a>).
</div>
<div class="Standard">
The mapping between source line numbers and bytecode instructions is stored as a list of (<i>line number</i>, <i>label</i>) pairs in the compiled code section of methods. For example if <tt><i>l1</i></tt>, <tt><i>l2</i></tt> and <tt><i>l3</i></tt> are three labels that appear in this order, then the following pairs:
</div>
<pre class="LyX-Code">
(n1, <i>l1</i>)
(n2, <i>l2</i>)
(n3, <i>l3</i>)
</pre>
<div class="Standard">
mean that instructions between <tt><i>l1</i></tt> and <tt><i>l2</i></tt> come from line <tt>n1</tt>, that instructions between <tt><i>l2</i></tt> and <tt><i>l3</i></tt> come from line <tt>n2</tt>, and that instructions after <tt><i>l3</i></tt> come from line <tt>n3</tt>. Note that a given line number can appear in several pairs. This is because the instructions corresponding to expressions that appear on a single source line may not be contiguous in the bytecode. For example <tt>for (</tt><i>init<tt></tt></i>; <i>cond<tt></tt></i>; <i>incr<tt></tt></i>) <i>statement<tt></tt></i>; is generaly compiled in the following order: <i>init</i> <i>statement</i> <i>incr</i> <i>cond</i>.
</div>
<div class="Standard">
The mapping between local variable names in source code and local variable slots in bytecode is stored as a list of (<i>name</i>, <i>type descriptor</i>, <i>type signature</i>, <i>start</i>, <i>end</i>, <i>index</i>) tuples in the compiled code section of methods. Such a tuple means that, between the two labels <i>start</i> and <i>end</i>, the local variable in slot <i>index</i> corresponds to the local variable whose name and type in source code are given by the first three tuple elements. Note that the compiler may use the same local variable slot to store distinct source local variables with different scopes. Conversely a unique source local variable may be compiled into a local variable slot with a non contiguous scope. For instance it is possible to have a situation like this:
</div>
<pre class="LyX-Code">
<i>l1</i>:
  ... // here slot 1 contains local variable i
<i>l2</i>:
  ... // here slot 1 contains local variable j
<i>l3</i>:
  ... // here slot 1 contains local variable i again
<i>end</i>:
</pre>
<div class="Standard">
The corresponding tuples are:
</div>
<pre class="LyX-Code">
("i", "I", null, <i>l1</i>, <i>l2</i>, 1)
("j", "I", null, <i>l2</i>, <i>l3</i>, 1)
("i", "I", null, <i>l3</i>, <i>end</i>, 1)
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.2">4.3.2</a> Interfaces and components
</h3>
<div class="Standard">
The debug information is visited with three methods of the <tt>ClassVisitor</tt> and <tt>MethodVisitor</tt> classes:
</div>
<ul>
<li>
the source file name is visited with the <tt>visitSource</tt> method of the <tt>ClassVisitor</tt> class;
</li>
<li>
the mapping between source line numbers and bytecode instructions is visited with the <tt>visitLineNumber</tt> method of the <tt>MethodVisitor</tt> class, one pair at a time;
</li>
<li>
the mapping between local variable names in source code and local variable slots in bytecode is visited with the <tt>visitLocalVariable</tt> method of the <tt>MethodVisitor</tt> class, one tuple at a time.
</li>

</ul>
<div class="Standard">
The <tt>visitLineNumber</tt> method must be called after the label passed as argument has been visited. In practice it is called just after this label, which makes it very easy to know the source line of the current instruction in a method visitor:
</div>
<pre class="LyX-Code">
public class MyAdapter extends MethodVisitor {
  <b>int currentLine;</b>
  public MyAdapter(MethodVisitor mv) {
    super(ASM4, mv);
  }
  @Override 
  public void visitLineNumber(int line, Label start) {
    mv.visitLineNumber(line, start);
    <b>currentLine = line;</b>
  }
  ...
}
</pre>
<div class="Standard">
Similarly the <tt>visitLocalVariable</tt> method must be called after the labels passed as argument have been visited. Here are example method calls that correspond to the pairs and tuples presented in the previous section:
</div>
<pre class="LyX-Code">
visitLineNumber(n1, <i>l1</i>);
visitLineNumber(n2, <i>l2</i>);
visitLineNumber(n3, <i>l3</i>);
visitLocalVariable("i", "I", null, <i>l1</i>, <i>l2</i>, 1);
visitLocalVariable("j", "I", null, <i>l2</i>, <i>l3</i>, 1);
visitLocalVariable("i", "I", null, <i>l3</i>, <i>end</i>, 1);
</pre>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--13"></a>Ignoring debug information
</h4>
<div class="Standard">
In order to visit line numbers and local variable names, the <tt>ClassReader</tt> class may need to introduce &ldquo;artificial&rdquo; <tt>Label</tt> objects, in the sense that they are not needed by jump instructions, but only to represent the debug information. This can introduce false positives in situations such as the one explained in section <a class="Reference" href="#sub:Statefull-transformations">3.2.5↑</a>, where a <tt>Label</tt> in the middle of an instruction sequence was considered to be a jump target, and therefore prevented this sequence from being removed.
</div>
<div class="Standard">
In order to avoid these false positives it is possible to use the <tt>SKIP_DEBUG</tt> option in the <tt>ClassReader.accept</tt> method. With this option the class reader does not visit the debug information, and does not create artificial labels for it. Of course the debug information will be removed from the class, so this option can be used only if this is not a problem for your application.
</div>
<div class="Description">
<span class="Description-entry">Note:</span> the <tt>ClassReader</tt> class provides other options<a class="IndexReference" name="entry-ClassReader_-2" href="#index-ClassReader_">↓</a> such as <tt>SKIP_CODE</tt> to skip the visit of compiled code (this can be useful if you just need the class structure), <tt>SKIP_FRAMES</tt> to skip the stack map frames<a class="IndexReference" name="entry-frames-skipping-0" href="#index-frames-skipping">↓</a>, and <tt>EXPAND_FRAMES</tt> to uncompress<a class="IndexReference" name="entry-frames-uncompressing-0" href="#index-frames-uncompressing">↓</a> these frames.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.3">4.3.3</a> Tools
</h3>
<div class="Standard">
Like for generic types and annotations, you can use the <tt>TraceClassVisitor</tt>, <tt>CheckClassAdapter</tt> and <tt>ASMifier</tt> classes to find how to work with debug information.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-5">5</a> Backward compatibility<a class="Label" name="chap:Backward-compatibility"> </a>
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-5.1">5.1</a> Introduction
</h2>
<div class="Standard">
New elements have been introduced in the past in the class file format, and new elements will continue to be added in the future (<i>e.g.</i>, for modularity, annotations on Java types, etc). Up to ASM 3.<i>x</i>, each such change led to backward incompatible changes in the ASM API, which is not good. To solve these problems, a new mechanism has been introduced in ASM 4.0. Its goal is to ensure that all future ASM versions will remain backward compatible with any previous version, down to ASM 4.0, even when new features will be introduced to the class file format. This means that a class generator, a class analyzer or a class adapter written for one ASM version, starting from 4.0, will still be usable with any future ASM version. <i>However</i>, this property can not be ensured by ASM alone. It requires users to follow a few simple guidelines when writing their code. The goal of this chapter is to present these guidelines, and to give an idea of the internal mechanism used in the ASM core API to ensure backward compatibility.
</div>
<div class="Description">
<span class="Description-entry">Note:</span> the backward compatibility mechanism introduced in ASM 4.0 required to change the <tt>ClassVisitor</tt>, <tt>FieldVisitor</tt>, <tt>MethodVisitor</tt>, etc from interfaces to abstract classes, with a constructor taking an ASM version as argument. If your code was implemented for ASM 3.<i>x</i>, you can upgrade it to ASM 4.0 by replacing <tt>implements</tt> with <tt>extends</tt> in your code analyzers and adapters, and by specifying an ASM version in their constructors. In addition, <tt>ClassAdapter</tt> and <tt>MethodAdapter</tt> have been merged into <tt>ClassVisitor</tt> and <tt>MethodVisitor</tt>. To convert your code, you simply need to replace <tt>ClassAdapter</tt> with <tt>ClassVisitor</tt>, and <tt>MethodAdapter</tt> with <tt>MethodVisitor</tt>. Also, if you defined custom <tt>FieldAdapter</tt> or <tt>AnnotationAdapter</tt> classes, you can now replace them with <tt>FieldVisitor</tt> and <tt>AnnotationVisitor</tt>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.1.1">5.1.1</a> Backward compatibility contract<a class="Label" name="sub:Backward-compatibility-contract"> </a>
</h3>
<div class="Standard">
Before presenting the user guidelines to ensure backward compatibility, we define here more precisely what we mean by &ldquo;backward compatibility&rdquo;. 
</div>
<div class="Standard">
First of all, it is important to study how new class file features impact code generators, analyzers and adapters. That is, independently of any implementation and binary compatibility issues, does a class generator, analyzer or adapter designed before the introduction of these new features remains valid after these modifications? Said otherwise, if we suppose that the new features are simply ignored and passed untouched through a transformation chain designed before their introduction, does this chain remains valid? In fact the impact differs for class generators, analyzers and adapters: 
</div>
<ul>
<li>
class generators are not impacted: they generate code with some fixed class version, and these generated classes will remain valid with future JVM versions, because the JVM ensures backward binary compatibility. 
</li>
<li>
class analyzers may or may not be impacted. For instance, a code that analyzes the bytecode instructions, written for Java 4, will probably still work with Java 5 classes, despite the introduction of annotations. But this same code will probably no longer work with Java 7 classes, because it can not ignore the new invokedynamic instruction. 
</li>
<li>
class adapters may or may not be impacted. A dead code removal tool is not impacted by the introduction of annotations, or even by the new invokedynamic instruction. On the other hand, a class renaming tool is impacted by both.
</li>

</ul>
<div class="Standard">
This shows that new class file features can have an unpredictable impact on existing class analyzers or adapters. If the new features are simply ignored and passed unchanged through an analysis or transformation chain, sometimes this chain will run without errors and produce a valid result, sometimes it will run without errors but will produce an invalid result, and sometimes it will fail during execution. The second case is particularly problematic, since it breaks the analysis or transformation chain semantics without the user being aware of this. This can lead to hard to find bugs. To solve this, instead of ignoring the new features, we think it is preferable to raise an error as soon as an unknown feature is encountered in an analysis or transformation chain. The error signals that this chain may or may not work with the new class format, and that its author must analyze the situation to update it if necessary.
</div>
<div class="Standard">
All this leads to the definition of the following backward compatibility contract: 
</div>
<ul>
<li>
ASM version <i>X</i> is written for Java classes whose version is less than or equal to <i>x</i>. It cannot generate classes with a version <i>y</i> &gt; <i>x</i>, and it must <i>fail</i> if given as input, in <tt>ClassReader.accept</tt>, a class whose version is greater than <i>x</i>. 
</li>
<li>
code written for ASM <i>X</i> and following the guidelines presented below must continue to work, unmodified, with input classes up to version <i>x</i>, with any future version <i>Y</i> &gt; <i>X</i> of ASM. 
</li>
<li>
code written for ASM <i>X</i> and following the guidelines presented below must continue to work, unmodified, with input classes whose declared version is <i>y</i> but that only use features defined in versions older or equal to <i>x</i>, with ASM <i>Y</i> or any future version. 
</li>
<li>
code written for ASM <i>X</i> and following the guidelines presented below must <i>fail</i> if given as input a class that uses features introduced in class versions <i>y</i> &gt; <i>x</i>, with ASM <i>X</i> or any other future version.
</li>

</ul>
<div class="Standard">
Note that the last three points do not concern class generators, which do not have class inputs. 
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.1.2">5.1.2</a> An example<a class="Label" name="sub:BackwardCompatibility-An-example"> </a>
</h3>
<div class="Standard">
In order to illustrate the user guidelines and the internal ASM mechanism ensuring backward compatibility, we suppose in this chapter that two new imaginary attributes will be added to Java 8 classes, one to store the class author(s), and one to store its license. We also suppose that these new attributes will be exposed via two new methods in <tt>ClassVisitor</tt>, in ASM 5.0:
</div>
<pre class="LyX-Code">
void visitLicense(String license);
</pre>
<div class="Standard">
to visit the license, and a new version of <tt>visitSource</tt> to visit the author at the same time as the source file name and debug information<span class="FootOuter"><span class="SupFootMarker"> [D] </span><span class="HoverFoot"><span class="SupFootMarker"> [D] </span>in reality we would probably add a single <tt>visitLicense(String author, String license)</tt> method, since modifying a method signature is more complex than adding a method, as will be shown below. We do this here only for illustration purposes.</span></span>:
</div>
<pre class="LyX-Code">
void visitSource(String author, String source, String debug);
</pre>
<div class="Standard">
The old <tt>visitSource</tt> method remains valid, but is declared deprecated in ASM 5.0:
</div>
<pre class="LyX-Code">
@Deprecated void visitSource(String source, String debug);
</pre>
<div class="Standard">
The author and license attributes are optional, i.e., calling <tt>visitLicense</tt> is not mandatory, and <tt>author</tt> can be <tt>null</tt> in a <tt>visitSource</tt> call.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-5.2">5.2</a> Guidelines
</h2>
<div class="Standard">
This section presents the guidelines that you must follow when using the core ASM API, in order to ensure that your code will remain valid with any future ASM versions (in the sense of the above contract).
</div>
<div class="Standard">
First of all, if you write a class generator, you don’t have any guideline to follow. For example, if you write a class generator for ASM 4.0, it will probably contain a call like <tt>visitSource(mySource, myDebug)</tt>, and of course no call to <tt>visitLicense</tt>. If you run it unchanged with ASM 5.0, this will call the deprecated <tt>visitSource</tt> method, but the ASM 5.0 <tt>ClassWriter</tt> will internally redirect this to <tt>visitSource(null, mySource, myDebug)</tt>, yielding the expected result (but a bit less efficiently than if you upgrade your code to call the new method directly). Likewise, the absence of a call to <tt>visitLicense</tt> will not be a problem (the generated class version will not have changed either, and classes of this version are not expected to have a license attribute).
</div>
<div class="Standard">
If, on the other hand, you write a class analyzer or a class adapter, i.e. if you override the <tt>ClassVisitor</tt> class (or any other similar class like <tt>FieldVisitor</tt> or <tt>MethodVisitor</tt>), you must follow a few guidelines, presented below.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.2.1">5.2.1</a> Basic rule
</h3>
<div class="Standard">
We consider here the simple case of a class extending directly <tt>ClassVisitor</tt> (the discussion and guidelines are the same for the other visitor classes; the case of indirect subclasses is discussed in the next section). In this case there is ony one guideline:
</div>
<div class="Description">
<span class="Description-entry">Guideline 1:</span> to write a <tt>ClassVisitor</tt> subclass for ASM version <i>X</i>, call the <tt>ClassVisitor</tt> constructor with this exact version as argument, and <i>never override or call methods that are deprecated</i> in this version of the <tt>ClassVisitor</tt> class (or that are introduced in later versions).
</div>
<div class="Standard">
And that’s it. In our example scenario (see section <a class="Reference" href="#sub:BackwardCompatibility-An-example">5.1.2↑</a>), a class adapter written for ASM 4.0 must therefore look like this:
</div>
<pre class="LyX-Code">
class MyClassAdapter extends ClassVisitor { 
  public MyClassAdapter(ClassVisitor cv) { 
    super(<b>ASM4</b>, cv); 
  }
  ...
  public void visitSource(String source, String debug) { // optional
    ...
    super.visitSource(source, debug); // optional 
  } 
}
</pre>
<div class="Standard">
Once updated for ASM 5.0, <tt>visitSource(String, String)</tt> must be removed, and the class must thus look like this:
</div>
<pre class="LyX-Code">
class MyClassAdapter extends ClassVisitor {
  public MyClassAdapter(ClassVisitor cv) { 
    super(<b>ASM5</b>, cv); 
  } 
  ... 
  public void visitSource(String author, 
      String source, String debug) { // optional 
    ...
    super.visitSource(author, source, debug); // optional 
  } 
  public void visitLicense(String license) { // optional
    ...
    super.visitLicense(license); // optional 
  } 
}
</pre>
<div class="Standard">
How does this work? Internally, <tt>ClassVisitor</tt> is implemented as follows in ASM 4.0: 
</div>
<pre class="LyX-Code">
public abstract class ClassVisitor { 
  int api; 
  ClassVisitor cv; 
  public ClassVisitor(int api, ClassVisitor cv) { 
    this.api = api; 
    this.cv = cv; 
  }
  ... 
  public void visitSource(String source, String debug) { 
    if (cv != null) cv.visitSource(source, debug); 
  } 
}
</pre>
<div class="Standard">
In ASM 5.0, this code becomes:
</div>
<pre class="LyX-Code">
public abstract class ClassVisitor { 
  ... 
  public void visitSource(String source, String debug) {
    if (api &lt; ASM5) { 
      if (cv != null) cv.visitSource(source, debug); 
    } else { 
      visitSource(null, source, debug); 
    } 
  }
  public void visitSource(Sring author, String source, String debug) { 
    if (api &lt; ASM5) { 
      if (author == null) { 
        visitSource(source, debug); 
      } else { 
        throw new RuntimeException(); 
      } 
    } else { 
      if (cv != null) cv.visitSource(author, source, debug); 
    } 
  }
  public void visitLicense(String license) { 
    if (api &lt; ASM5) throw new RuntimeException(); 
    if (cv != null) cv.visitSource(source, debug);
  } 
}
</pre>
<div class="Standard">
If <tt>MyClassAdapter</tt> 4.0 extends <tt>ClassVisitor</tt> 4.0, everything works as expected. If we upgrade to ASM 5.0 without changing our code, <tt>MyClassAdapter</tt> 4.0 will now extend <tt>ClassVisitor</tt> 5.0. But the <tt>api</tt> field will still be <tt>ASM4</tt> &lt; <tt>ASM5</tt>, and it is easy to see that in this case <tt>ClassVisitor</tt> 5.0 behaves like <tt>ClassVisitor</tt> 4.0 when calling <tt>visitSource(String, String)</tt>. In addition, if the new <tt>visitSource</tt> method is called with a <tt>null</tt> author, the call will be redirected to the old version. Finally, if a non null author or license is found in the input class, the execution will fail, as defined in our contract (either in the new <tt>visitSource</tt> method or in <tt>visitLicense</tt>).
</div>
<div class="Standard">
If we upgrade to ASM 5.0, and update our code at the same time, we now have <tt>MyClassAdapter</tt> 5.0 extending <tt>ClassVisitor</tt> 5.0. The <tt>api</tt> field is now <tt>ASM5</tt>, and <tt>visitLicense</tt> and the new <tt>visitSource</tt> methods behave then by simply delegating calls to the next visitor <tt>cv</tt>. In addition, the old <tt>visitSource</tt> method now redirect calls to the new <tt>visitSource</tt> method, which ensures that if an old class adapter is used before our own in a transformation chain, <tt>MyClassAdapter</tt> 5.0 will not miss this visit event.
</div>
<div class="Standard">
<tt>ClassReader</tt> will always call the latest version of each visit method. Thus, no indirection will occur if we use <tt>MyClassAdapter</tt> 4.0 with ASM 4.0, or <tt>MyClassAdapter</tt> 5.0 with ASM 5.0. It is only if we use <tt>MyClassAdapter</tt> 4.0 with ASM 5.0 that an indirection occurs in <tt>ClassVisitor</tt> (at the 3rd line of new <tt>visitSource</tt> method). Thus, although old code will still work with new ASM versions, it will run a little slower. Upgrading it to use the new API will restore its performance.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.2.2">5.2.2</a> Inheritance rule
</h3>
<div class="Standard">
The above guideline is sufficient for a direct subclass of <tt>ClassVisitor</tt> or any other similar class. For indirect subclasses, i.e. if you define a subclass <tt>A1</tt> extending <tt>ClassVisitor</tt>, itself extended by <tt>A2</tt>, ... itself extended by <tt>An</tt>, then <i>all these subclasses must be written for the same ASM version</i>. Indeed, mixing different versions in an inheritance chain could lead to several versions of the same method — like <tt>visitSource(String,String)</tt> and <tt>visitSource(String,String,String)</tt> — overriden at the same time, with potentially different behaviors, resulting in wrong or unpredictable results. If these classes come from different sources, each updated independently and released separately, this property is almost impossible to ensure. This leads to a second guideline:
</div>
<div class="Description">
<span class="Description-entry">Guideline 2:</span> do not use inheritance of visitors, use delegation instead (<i>i.e.</i>, visitor chains). A good practice is to make your visitor classes final by default to ensure this.
</div>
<div class="Standard">
In fact there are two exceptions to this guideline:
</div>
<ul>
<li>
you can use inheritance of visitors if you fully control the inheritance chain yourself, and release all the classes of the hierarchy at the same time. You must then ensure that all the classes in the hierarchy are written for the same ASM version. Still, make the leaf classes of your hierarchy final. 
</li>
<li>
you can use inheritance of &ldquo;visitors&rdquo; if no class except the leaf ones override any visit method (for instance, if you use intermediate classes between <tt>ClassVisitor</tt> and the concrete visitor classes only to introduce convenience methods). Still, make the leaf classes of your hierarchy final (unless they do not override any visit method either; in this case provide a constructor taking an ASM version as argument so that subclasses can specify for which version they are written). 
</li>

</ul>
<h1 class="Part">
<a class="toc" name="toc-Part-II">Part II.</a> Tree API
</h1>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-6">6</a> Classes
</h1>
<div class="Standard">
This chapter explains how to generate and transform classes with the ASM tree API. It starts with a presentation of the tree API alone, and then explains how to compose it with the core API. The tree API for the content of methods, annotations and generics is explained in the next chapters.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.1">6.1</a> Interfaces and components
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.1.1">6.1.1</a> Presentation
</h3>
<div class="Standard">
The ASM tree API for generating and transforming compiled Java classes is based on the <tt>ClassNode</tt> class (see Figure <a class="Reference" href="#fig:The-ClassNode-class">6.1↓</a>).
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:The-ClassNode-class"> </a><div class="figure">
<pre class="LyX-Code">
public class <b>ClassNode</b> ... {
  public int version;
  public int access;
  public String name;
  public String signature;
  public String superName;
  public List&lt;String&gt; interfaces;
  public String sourceFile;
  public String sourceDebug;
  public String outerClass;
  public String outerMethod;
  public String outerMethodDesc;
  public List&lt;AnnotationNode&gt; visibleAnnotations;
  public List&lt;AnnotationNode&gt; invisibleAnnotations;
  public List&lt;Attribute&gt; attrs;
  public List&lt;InnerClassNode&gt; innerClasses;
  public List&lt;FieldNode&gt; fields;
  public List&lt;MethodNode&gt; methods;
}
</pre>
<div class="caption">
Figure 6.1 The <tt>ClassNode</tt><a class="IndexReference" name="entry-ClassNode_-0" href="#index-ClassNode_">↓</a> class (only fields are shown)
</div>

</div>

</div>

</div>
<div class="Standard">
As you can see the public fields of this class correspond to the class file structure sections presented in Figure <a class="Reference" href="#fig:Overall-structure-of-class-file">2.1↑</a>. The content of these fields is the same as in the core API. For instance <tt>name</tt> is an internal name and <tt>signature</tt> is a class signature (see sections <a class="Reference" href="#sub:Internal-names">2.1.2↑</a> and <a class="Reference" href="#sec:Generics">4.1↑</a>). Some fields contain other <tt><i>Xxx</i>Node</tt> classes: these classes, presented in details in the next chapters, have a similar structure, i.e. have fields that correspond to sub sections of the class file structure. For instance the <tt>FieldNode</tt><a class="IndexReference" name="entry-FieldNode_-0" href="#index-FieldNode_">↓</a> class looks like this:
</div>
<pre class="LyX-Code">
public class FieldNode ... {
  public int access;
  public String name;
  public String desc;
  public String signature;
  public Object value;
  public FieldNode(int access, String name, String desc, 
      String signature, Object value) { 
    ... 
  }
  ...
}
</pre>
<div class="Standard">
The <tt>MethodNode</tt><a class="IndexReference" name="entry-MethodNode_-0" href="#index-MethodNode_">↓</a> class is similar:
</div>
<pre class="LyX-Code">
public class MethodNode ... {
  public int access;
  public String name;
  public String desc;
  public String signature;
  public List&lt;String&gt; exceptions;
  ...
  public MethodNode(int access, String name, String desc,
      String signature, String[] exceptions)
  {
    ...
  }
}
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.1.2">6.1.2</a> Generating classes<a class="IndexReference" name="entry-classes-generating-1" href="#index-classes-generating">↓</a>
</h3>
<div class="Standard">
Generating a class with the tree API simply consists in creating a <tt>ClassNode</tt> object and in initializing its fields. For instance the <tt>Comparable</tt> interface in section <a class="Reference" href="#sub:Generating-classes-CoreAPI">2.2.3↑</a> can be built as follows, with approximatively the same amount of code as in section <a class="Reference" href="#sub:Generating-classes-CoreAPI">2.2.3↑</a>:
</div>
<pre class="LyX-Code">
ClassNode cn = new ClassNode();
cn.version = V1_5;
cn.access = ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE;
cn.name = "pkg/Comparable";
cn.superName = "java/lang/Object";
cn.interfaces.add("pkg/Mesurable");
cn.fields.add(new FieldNode(ACC_PUBLIC + ACC_FINAL + ACC_STATIC,
    "LESS", "I", null, new Integer(-1)));
cn.fields.add(new FieldNode(ACC_PUBLIC + ACC_FINAL + ACC_STATIC,
    "EQUAL", "I", null, new Integer(0)));
cn.fields.add(new FieldNode(ACC_PUBLIC + ACC_FINAL + ACC_STATIC,
    "GREATER", "I", null, new Integer(1)));
cn.methods.add(new MethodNode(ACC_PUBLIC + ACC_ABSTRACT,
    "compareTo", "(Ljava/lang/Object;)I", null, null));
</pre>
<div class="Standard">
Using the tree API to generate a class takes about <span class="formula">30%</span> more time (see Appendix <a class="Reference" href="#app:Bytecode-instructions">11.1↓</a>) and consumes more memory than using the core API. But it makes it possible to generate the class elements in any order, which can be convenient in some cases.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.1.3">6.1.3</a> Adding and removing class members
</h3>
<div class="Standard">
Adding and removing class members simply consists in adding or removing elements in the <tt>fields</tt> or <tt>methods</tt> lists of a <tt>ClassNode</tt> object. For example, if we define the <tt>ClassTransformer</tt><a class="IndexReference" name="entry-ClassTransformer_-0" href="#index-ClassTransformer_">↓</a> class as follows, in order to be able to compose class transformers easily:
</div>
<pre class="LyX-Code">
public class ClassTransformer {
  protected ClassTransformer ct;
  public ClassTransformer(ClassTransformer ct) {
    this.ct = ct;
  }
  public void transform(ClassNode cn) {
    if (ct != null) {
      ct.transform(cn);
    }
  }
}
</pre>
<div class="Standard">
then the <tt>RemoveMethodAdapter</tt><a class="IndexReference" name="entry-classes-removing-members-1" href="#index-classes-removing-members">↓</a><a class="IndexReference" name="entry-methods-removing-1" href="#index-methods-removing">↓</a> in section <a class="Reference" href="#sub:Removing-class-members-coreAPI">2.2.5↑</a> can be implemented as follows:
</div>
<pre class="LyX-Code">
public class RemoveMethodTransformer extends ClassTransformer {
  private String methodName;
  private String methodDesc;
  public RemoveMethodTransformer(ClassTransformer ct,
      String methodName, String methodDesc) {
    super(ct);
    this.methodName = methodName;
    this.methodDesc = methodDesc;
  }
  @Override public void transform(ClassNode cn) {
    <b>Iterator&lt;MethodNode&gt; i = cn.methods.iterator();</b>
    while (i.hasNext()) {
      MethodNode mn = i.next();
      <b>if (methodName.equals(mn.name) &amp;&amp; methodDesc.equals(mn.desc)) {</b>
 <b>       i.remove();</b>
 <b>     }</b>
    }
    super.transform(cn);
  }
}
</pre>
<div class="Standard">
As can be seen the main difference with the core API is that you need to iterate over all methods, while you don’t need to do so with the core API (this is done for you in <tt>ClassReader</tt>). In fact this difference is valid for almost all tree based transformations. For instance the <tt>AddFieldAdapter</tt><a class="IndexReference" name="entry-classes-adding-members-1" href="#index-classes-adding-members">↓</a><a class="IndexReference" name="entry-fields-adding-1" href="#index-fields-adding">↓</a> of section <a class="Reference" href="#sub:Adding-class-members-coreAPI">2.2.6↑</a> also needs an iterator when implemented with the tree API:
</div>
<pre class="LyX-Code">
public class AddFieldTransformer extends ClassTransformer {
  private int fieldAccess;
  private String fieldName;
  private String fieldDesc;
  public AddFieldTransformer(ClassTransformer ct, int fieldAccess,
      String fieldName, String fieldDesc) {
    super(ct);
    this.fieldAccess = fieldAccess;
    this.fieldName = fieldName;
    this.fieldDesc = fieldDesc;
  }
  @Override public void transform(ClassNode cn) {
    boolean isPresent = false;
    <b>for (FieldNode fn : cn.fields) {</b>
      <b>if (fieldName.equals(fn.name)) {</b>
 <b>       isPresent = true;</b>
 <b>       break;</b>
 <b>     }</b>
    }
    <b>if (!isPresent) {</b>
 <b>     cn.fields.add(new FieldNode(fieldAccess, fieldName, fieldDesc,</b>
 <b>         null, null));</b>
 <b>   }</b>
    super.transform(cn);
  }
}
</pre>
<div class="Standard">
Like for class generation, using the tree API to transform classes takes more time and consumes more memory than using the core API. But it makes it possible to implement some transformations more easily. This is the case, for example, of a transformation that adds to a class an annotation containing a digital signature of its content. With the core API the digital signature can be computed only when all the class has been visited, but then it is too late to add an annotation containing it, because annotations must be visited before class members. With the tree API this problem disappears because there is no such constraint in this case.
</div>
<div class="Standard">
In fact it <i>is</i> possible to implement the <tt>AddDigitialSignature</tt> example with the core API, but then the class must be transformed in two <i>passes</i><a class="IndexReference" name="entry-transformation-pass-0" href="#index-transformation-pass">↓</a>. During the first pass the class is visited with a <tt>ClassReader</tt> (and no <tt>ClassWriter</tt>), in order to compute the digital signature based on the class content. During the second pass the same <tt>ClassReader</tt> is reused to do a second visit of the class, this time with an <tt>AddAnnotationAdapter</tt> chained to a <tt>ClassWriter</tt>. By generalizing this argument we see that, in fact, any transformation can be implemented with the core API alone, by using several passes if necessary. But this increases the transformation code complexity, this requires to store state between passes (which can be as complex as a full tree representation!), and parsing the class several times has a cost, which must be compared to the cost of constructing the corresponding <tt>ClassNode</tt>. 
</div>
<div class="Standard">
The conclusion is that <i>the tree API is generally used for transformations that cannot be implemented in one pass with the core API</i>. But there are of course exceptions. For example an obfuscator cannot be implemented in one pass, because you cannot transform classes before the mapping from original to obfuscated names is fully constructed, which requires to parse all classes. But the tree API is not a good solution either, because it would require keeping in memory the object representation of <i>all</i> the classes to obfuscate. In this case it is better to use the core API with two passes: one to compute the mapping between original and obfuscated names (a simple hash table that requires much less memory than a full object representation of all the classes), and one to transform the classes based on this mapping.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.2">6.2</a> Components composition
</h2>
<div class="Standard">
So far we have only seen how to create and transform <tt>ClassNode</tt> objects, but we haven’t seen how to construct a <tt>ClassNode</tt> from the byte array representation of a class or, vice versa, to construct this byte array from a <tt>ClassNode</tt>. In fact this is done by composing the core API and tree API components, as explained in this section.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.2.1">6.2.1</a> Presentation
</h3>
<div class="Standard">
In addition to the fields shown in Figure <a class="Reference" href="#fig:The-ClassNode-class">6.1↑</a>, the <tt>ClassNode</tt> class extends the <tt>ClassVisitor</tt> class, and also provides an <tt>accept</tt> method that takes a <tt>ClassVisitor</tt> as parameter. The <tt>accept</tt> method generates events based on the <tt>ClassNode</tt> field values, while the <tt>ClassVisitor</tt> methods perform the inverse operation, i.e. set the <tt>ClassNode</tt> fields based on the received events:
</div>
<pre class="LyX-Code">
public class ClassNode <b>extends ClassVisitor</b> {
  ...
  public void visit(int version, int access, String name,
      String signature, String superName, String[] interfaces[]) {
    this.version = version;
    this.access = access;
    this.name = name;
    this.signature = signature;
    ...
  }
  ...
  public void <b>accept</b>(ClassVisitor cv) {
    cv.visit(version, access, name, signature, ...);
    ...
  }
}
</pre>
<div class="Standard">
Constructing a <tt>ClassNode</tt> from a byte array can therefore be done by composing it with a <tt>ClassReader</tt>, so that the events generated by the <tt>ClassReader</tt> are consumed by the <tt>ClassNode</tt> component, resulting in the initialization of its fields (as can be seen from the above code):
</div>
<pre class="LyX-Code">
ClassNode cn = new ClassNode();
ClassReader cr = new ClassReader(...);
cr.accept(cn, 0);
</pre>
<div class="Standard">
Symetrically a <tt>ClassNode</tt> can be converted to its byte array representation by composing it with a <tt>ClassWriter</tt>, so that the events generated by the <tt>ClassNode</tt>’s <tt>accept</tt> method are consumed by the <tt>ClassWriter</tt>:
</div>
<pre class="LyX-Code">
ClassWriter cw = new ClassWriter(0);
cn.accept(cw);
byte[] b = cw.toByteArray();
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.2.2">6.2.2</a> Patterns
</h3>
<div class="Standard">
Transforming a class with the tree API can be done by putting these elements together:
</div>
<pre class="LyX-Code">
ClassNode cn = new ClassNode(ASM4);
ClassReader cr = new ClassReader(...);
cr.accept(cn, 0);
... // here transform cn as you want
ClassWriter cw = new ClassWriter(0);
cn.accept(cw);
byte[] b = cw.toByteArray();
</pre>
<div class="Standard">
It is also possible to use a tree based class transformer like a class adapter with the core API. Two common patterns are used for that. The first one uses inheritance:
</div>
<pre class="LyX-Code">
public class MyClassAdapter <b>extends ClassNode</b> {
  public MyClassAdapter(ClassVisitor cv) {
    super(ASM4);
    this.cv = cv;
  }
  @Override public void visitEnd() {
    // put your transformation code here
    <b>accept(cv);</b>
  }
}
</pre>
<div class="Standard">
When this class adapter is used in a classical transformation chain:
</div>
<pre class="LyX-Code">
ClassWriter cw = new ClassWriter(0);
ClassVisitor ca = new MyClassAdapter(cw);
ClassReader cr = new ClassReader(...);
cr.accept(ca, 0);
byte[] b = cw.toByteArray();
</pre>
<div class="Standard">
the events generated by <tt>cr</tt> are consumed by the <tt>ClassNode</tt> <tt>ca</tt>, which results in the initialization of the fields of this object. At the end, when the <tt>visitEnd</tt> event is consumed, <tt>ca</tt> performs the transformation and, by calling its <tt>accept</tt> method, generates new events corresponding to the transformed class, which are consumed by <tt>cw</tt>. The corresponding sequence diagram is show in Figure <a class="Reference" href="#fig:Sequence-diagram-for-MyClassAdapter">6.2↓</a>, if we suppose that <tt>ca</tt> changes the class version.
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:Sequence-diagram-for-MyClassAdapter"> </a><div class="figure">
<div class="center">
<img class="embedded" src="figures/classnode.png" alt="figure figures/classnode.png" style="max-width: 451px; max-height: 318px;"/>

</div>
<div class="caption">
Figure 6.2 Sequence diagram for <tt>MyClassAdapter</tt>
</div>

</div>

</div>

</div>
<div class="Standard">
When compared to the sequence diagram for <tt>ChangeVersionAdapter</tt> in Figure <a class="Reference" href="#fig:ChangeVersionAdapter">2.7↑</a>, we can see that the events between <tt>ca</tt> and <tt>cw</tt> occur after the events between <tt>cr</tt> and <tt>ca</tt>, instead of simultaneously with a normal class adapter. In fact this happens with all tree based transformations, and explains why they are less constrained than event based ones.
</div>
<div class="Standard">
The second pattern that can be used to acheive the same result, with a similar sequence diagram, uses delegation instead of inheritance:
</div>
<pre class="LyX-Code">
public class MyClassAdapter extends ClassVisitor {
  ClassVisitor next;
  public MyClassAdapter(ClassVisitor cv) {
    super(ASM4, <b>new ClassNode()</b>);
    next = cv;
  }
  @Override public void visitEnd() {
    ClassNode cn = (ClassNode) cv;
    // put your transformation code here
    <b>cn.accept(next);</b>
  }
}
</pre>
<div class="Standard">
This pattern uses two objects instead of one, but works exactly in the same way as the first pattern: the received events are used to construct a <tt>ClassNode</tt>, which is transformed and converted back to an event based representation when the last event is received.
</div>
<div class="Standard">
Both patterns allow you to compose your tree based class adapters with event based adapters. They can also be used to compose tree based adapters together, but if you only need to compose tree based adapters this is not the best solution: in this case using classes such as <tt>ClassTransformer</tt> will avoid unnecessary conversions between the two representations.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-7">7</a> Methods
</h1>
<div class="Standard">
This chapter explains how to generate and transform methods with the ASM tree API. It starts with a presentation of the tree API alone, with some illustrative examples, and then presents how to compose it with the core API. The tree API for generics and annotations is presented in the next chapter.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.1">7.1</a> Interfaces and components
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.1">7.1.1</a> Presentation<a class="Label" name="sub:Methods-treeAPI"> </a>
</h3>
<div class="Standard">
The ASM tree API for generating and transforming methods is based on the <tt>MethodNode</tt> class (see Figure <a class="Reference" href="#fig:The-MethodNode-class">7.1↓</a>).
</div>
<div class="Standard">
<div class="float">
<a class="Label" name="fig:The-MethodNode-class"> </a><div class="figure">
<pre class="LyX-Code">
public class <b>MethodNode</b> ... {
  public int access;
  public String name;
  public String desc;
  public String signature;
  public List&lt;String&gt; exceptions;
  public List&lt;AnnotationNode&gt; visibleAnnotations;
  public List&lt;AnnotationNode&gt; invisibleAnnotations;
  public List&lt;Attribute&gt; attrs;
  public Object annotationDefault;
  public List&lt;AnnotationNode&gt;[] visibleParameterAnnotations;
  public List&lt;AnnotationNode&gt;[] invisibleParameterAnnotations;
  public InsnList instructions;
  public List&lt;TryCatchBlockNode&gt; tryCatchBlocks;
  public List&lt;LocalVariableNode&gt; localVariables;
  public int maxStack;
  public int maxLocals;
}
</pre>
<div class="caption">
Figure 7.1 The <tt>MethodNode</tt><a class="IndexReference" name="entry-MethodNode_-1" href="#index-MethodNode_">↓</a> class (only fields are shown)
</div>

</div>

</div>

</div>
<div class="Standard">
Most of the fields of this class are similar to the corresponding fields in <tt>ClassNode</tt>. The most important ones are the last ones, starting from the <tt>instructions</tt> field. This field is a list of instructions, managed with an <tt>InsnList</tt><a class="IndexReference" name="entry-InsnList_-0" href="#index-InsnList_">↓</a> object, whose public API is the following:
</div>
<pre class="LyX-Code">
public class InsnList { // public accessors omitted
  int size();
  AbstractInsnNode getFirst();
  AbstractInsnNode getLast();
  AbstractInsnNode get(int index);
  boolean contains(AbstractInsnNode insn);
  int indexOf(AbstractInsnNode insn);
  void accept(MethodVisitor mv);
  ListIterator iterator();
  ListIterator iterator(int index);
  AbstractInsnNode[] toArray();
  void set(AbstractInsnNode location, AbstractInsnNode insn);
  void add(AbstractInsnNode insn);
  void add(InsnList insns);
  void insert(AbstractInsnNode insn);
  void insert(InsnList insns);
  void insert(AbstractInsnNode location, AbstractInsnNode insn);
  void insert(AbstractInsnNode location, InsnList insns);
  void insertBefore(AbstractInsnNode location, AbstractInsnNode insn);
  void insertBefore(AbstractInsnNode location, InsnList insns);
  void remove(AbstractInsnNode insn);
  void clear();
}
</pre>
<div class="Standard">
An <tt>InsnList</tt> is a doubly linked list of instructions, <i>whose links are stored in the</i> <tt>AbstractInsnNode</tt> <i>objects themselves</i>. This point is extremely important because it has many consequences on the way instruction objects and instruction lists must be used:
</div>
<ul>
<li>
An <tt>AbstractInsnNode</tt> object cannot appear more than once in an instruction list.
</li>
<li>
An <tt>AbstractInsnNode</tt> object cannot belong to several instruction lists at the same time.
</li>
<li>
As a consequence, adding an <tt>AbstractInsnNode</tt> to a list requires removing it from the list to which it was belonging, if any.
</li>
<li>
As another consequence, adding all the elements of a list into another one clears the first list.
</li>

</ul>
<div class="Standard">
The <tt>AbstractInsnNode</tt><a class="IndexReference" name="entry-AbstractInsnNode_-0" href="#index-AbstractInsnNode_">↓</a> class is the super class of the classes that represent bytecode instructions. Its public API is the following:
</div>
<pre class="LyX-Code">
public abstract class AbstractInsnNode {
  public int getOpcode();
  public int getType();
  public AbstractInsnNode getPrevious();
  public AbstractInsnNode getNext();
  public void accept(MethodVisitor cv);
  public AbstractInsnNode clone(Map labels);
}
</pre>
<div class="Standard">
Its sub classes are <tt><i>Xxx</i>InsnNode</tt> classes corresponding to the <tt>visit<i>Xxx</i>Insn</tt> methods of the <tt>MethodVisitor</tt> interface, and are all build in the same way. For instance the <tt>VarInsnNode</tt> class corresponds to the <tt>visitVarInsn</tt> method and has the following structure:
</div>
<pre class="LyX-Code">
public class VarInsnNode extends AbstractInsnNode {
  public int var;
  public VarInsnNode(int opcode, int var) {
    super(opcode);
    this.var = var;
  }
  ...
}
</pre>
<div class="Standard">
Labels and frames, as well as line numbers, although they are not instructions, are also represented by sub classes of the <tt>AbstractInsnNode</tt> classes, namely the <tt>LabelNode</tt>, <tt>FrameNode</tt> and <tt>LineNumberNode</tt> classes. This allows them to be inserted just before the corresponding real instructions in the list, as in the core API (where labels and frames are visited just before their corresponding instruction). It is therefore easy to find the target of a jump instruction, with the <tt>getNext</tt> method provided by the <tt>AbstractInsnNode</tt> class: this is the first <tt>AbstractInsnNode</tt> after the target label that is a real instruction. Another consequence is that, like with the core API, removing an instruction does not break jump instructions, as long as labels remain unchanged.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.2">7.1.2</a> Generating methods
</h3>
<div class="Standard">
Generating a method<a class="IndexReference" name="entry-methods-generating-1" href="#index-methods-generating">↓</a> with the tree API consists in creating a <tt>MethodNode</tt> and in initializing its fields. The most interesting part is the generation of the method’s code. As an example, the <tt>checkAndSetF</tt> method of section <a class="Reference" href="#sub:Frames">3.1.5↑</a> can be generated as follows:
</div>
<pre class="LyX-Code">
MethodNode mn = new MethodNode(...);
InsnList il = mn.instructions;
il.add(new VarInsnNode(ILOAD, 1));
LabelNode label = new LabelNode();
il.add(new JumpInsnNode(IFLT, label));
il.add(new VarInsnNode(ALOAD, 0));
il.add(new VarInsnNode(ILOAD, 1));
il.add(new FieldInsnNode(PUTFIELD, "pkg/Bean", "f", "I"));
LabelNode end = new LabelNode();
il.add(new JumpInsnNode(GOTO, end));
il.add(label);
il.add(new FrameNode(F_SAME, 0, null, 0, null));
il.add(new TypeInsnNode(NEW, "java/lang/IllegalArgumentException"));
il.add(new InsnNode(DUP));
il.add(new MethodInsnNode(INVOKESPECIAL,
    "java/lang/IllegalArgumentException", "&lt;init&gt;", "()V"));
il.add(new InsnNode(ATHROW));
il.add(end);
il.add(new FrameNode(F_SAME, 0, null, 0, null));
il.add(new InsnNode(RETURN));
mn.maxStack = 2;
mn.maxLocals = 2;
</pre>
<div class="Standard">
Like with classes, using the tree API to generate methods takes more time and consumes more memory than using the core API. But it makes it possible to generate their content in any order. In particular the instructions can be generated in a different order than the sequential one, which can be useful in some cases.
</div>
<div class="Standard">
Consider for example an expression compiler. Normaly an expression <span class="formula"><i>e</i><sub>1</sub> + <i>e</i><sub>2</sub></span> is compiled by emitting code for <span class="formula"><i>e</i><sub><span class="text">1</span></sub></span>, then emitting code for <span class="formula"><i>e</i><sub>2</sub></span>, and then emitting code for adding the two values. But if <span class="formula"><i>e</i><sub><span class="text">1</span></sub></span> and <span class="formula"><i>e</i><sub>2</sub></span> are not of the same primitive type, a cast must be inserted just after the code for <span class="formula"><i>e</i><sub><span class="text">1</span></sub></span>, and another one just after the code for <span class="formula"><i>e</i><sub><span class="text">2</span></sub></span>. However the exact casts that must be emitted depend on <span class="formula"><i>e</i><sub><span class="text">1</span></sub></span> <i>and</i> <span class="formula"><i>e</i><sub><span class="text">2</span></sub></span> types. 
</div>
<div class="Standard">
Now, if the type of an expression is returned by the method that emits the compiled code, we have a problem if we are using the core API: the cast that must be inserted after <span class="formula"><i>e</i><sub><span class="text">1</span></sub></span> is known only after <span class="formula"><i>e</i><sub><span class="text">2</span></sub></span> has been compiled, but this is too late because we cannot insert an instruction between previously visited instructions<span class="FootOuter"><span class="SupFootMarker"> [E] </span><span class="HoverFoot"><span class="SupFootMarker"> [E] </span>the solution is to compile expressions in two passes: one to compute the expression types and the casts that must be inserted, and one to emit the compiled code.</span></span>. With the tree API this problem does not exist. For example, one possibility is to use a <tt>compile</tt> method such as:
</div>
<pre class="LyX-Code">
public Type compile(InsnList output) {
  InsnList il1 = new InsnList();
  InsnList il2 = new InsnList();
  Type t1 = e1.compile(il1);
  Type t2 = e2.compile(il2);
  Type t = ...; // compute common super type of t1 and t2
  output.addAll(il1); // done in constant time
  output.add(...); // cast instruction from t1 to t
  output.addAll(il2); // done in constant time
  output.add(...); // cast instruction from t2 to t
  output.add(new InsnNode(t.getOpcode(IADD)));
  return t;
}
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.3">7.1.3</a> Transforming methods
</h3>
<div class="Standard">
Transforming a method<a class="IndexReference" name="entry-methods-transforming-1" href="#index-methods-transforming">↓</a> with the tree API simply consists in modifying the fields of a <tt>MethodNode</tt> object, and in particular the <tt>instructions</tt> list. Although this list can be modified in arbitray ways, a common pattern is to modify it while iterating over it. Indeed, unlike with the general <tt>ListIterator</tt> contract, the <tt>ListIterator</tt> returned by an <tt>InsnList</tt> supports many conccurrent<span class="FootOuter"><span class="SupFootMarker"> [F] </span><span class="HoverFoot"><span class="SupFootMarker"> [F] </span>i.e. modifications interleaved with calls to <tt>Iterator.next</tt>. True, multi-threaded concurrent modifications are not supported.</span></span> list modifications. In fact you can use the <tt>InsnList</tt> methods to remove one or more elements before and including the current one, to remove one or more elements after the <i>next</i> element (i.e. not just after the current element, but after its successor), or to insert one or more elements before the current one or after its successor. These changes will be reflected in the iterator, i.e. the elements inserted (resp. removed) after the next element will be seen (resp. not seen) in the iterator.
</div>
<div class="Standard">
Another common pattern to modify an instruction list, when you need to insert several instructions after an instruction <i>i</i> inside a list, is to add these new instructions in a temporary instruction list, and to insert this temporary list inside the main one in one step:
</div>
<pre class="LyX-Code">
InsnList il = new InsnList();
il.add(...);
...
il.add(...);
mn.instructions.insert(i, il);
</pre>
<div class="Standard">
Inserting the instructions one by one is also possible but more cumbersome, because the insertion point must be updated after each insertion.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.4">7.1.4</a> Stateless and statefull transformations
</h3>
<div class="Standard">
Let’s take some examples to see concretely how methods can be transformed with the tree API. In order to see the differences between the core and the tree API, it is interesting to reimplement the <tt>AddTimerAdapter</tt> example of section <a class="Reference" href="#sub:Stateless-transformations">3.2.4↑</a> and the <tt>RemoveGetFieldPutFieldAdapter</tt> of section <a class="Reference" href="#sub:Statefull-transformations">3.2.5↑</a>. The timer example can be implemented as follows:
</div>
<pre class="LyX-Code">
public class AddTimerTransformer extends ClassTransformer {
  public AddTimerTransformer(ClassTransformer ct) {
    super(ct);
  }
  @Override public void transform(ClassNode cn) {
    for (MethodNode mn : (List&lt;MethodNode&gt;) cn.methods) {      
      if ("&lt;init&gt;".equals(mn.name) || "&lt;clinit&gt;".equals(mn.name)) {
        continue;
      }
      <b>InsnList insns = mn.instructions;</b>
      if (insns.size() == 0) {
        continue;
      }
 <b>     Iterator&lt;AbstractInsnNode&gt; j = insns.iterator();</b>
 <b>     while (j.hasNext()) {</b>
 <b>       AbstractInsnNode in = j.next();</b>
        int op = in.getOpcode();
        if ((op &gt;= IRETURN &amp;&amp; op &lt;= RETURN) || op == ATHROW) {
          InsnList il = new InsnList();
          il.add(new FieldInsnNode(GETSTATIC, cn.name, "timer", "J"));
          il.add(new MethodInsnNode(INVOKESTATIC, "java/lang/System",
              "currentTimeMillis", "()J"));
          il.add(new InsnNode(LADD));
          il.add(new FieldInsnNode(PUTSTATIC, cn.name, "timer", "J"));
          <b>insns.insert(in.getPrevious(), il);</b>
        }
      }
      InsnList il = new InsnList();
      il.add(new FieldInsnNode(GETSTATIC, cn.name, "timer", "J"));
      il.add(new MethodInsnNode(INVOKESTATIC, "java/lang/System",
          "currentTimeMillis", "()J"));
      il.add(new InsnNode(LSUB));
      il.add(new FieldInsnNode(PUTSTATIC, cn.name, "timer", "J"));
      <b>insns.insert(il);</b>
      mn.maxStack += 4;
    }
    int acc = ACC_PUBLIC + ACC_STATIC;
    cn.fields.add(new FieldNode(acc, "timer", "J", null, null));
    super.transform(cn);
  }
}
</pre>
<div class="Standard">
You can see here the pattern discussed in the previous section for inserting several instructions in the instruction list, which consists in using a temporary instruction list. This example also shows that it is possible to insert instructions before the current one while iterating over an instruction list. Note that the amount of code that is necessary to implement this adapter is approximatively the same with the core and tree APIs. 
</div>
<div class="Standard">
The method adapter that removes field self assignments (see section <a class="Reference" href="#sub:Statefull-transformations">3.2.5↑</a>) can be implemented as follows (if we suppose that <tt>MethodTransformer</tt> is similar to the <tt>ClassTransformer</tt> class of the previous chapter):
</div>
<pre class="LyX-Code">
public class RemoveGetFieldPutFieldTransformer extends
    MethodTransformer {
  public RemoveGetFieldPutFieldTransformer(MethodTransformer mt) {
    super(mt);
  }
  @Override public void transform(MethodNode mn) {
    <b>InsnList insns = mn.instructions;</b>
 <b>   Iterator&lt;AbstractInsnNode&gt; i = insns.iterator();</b>
 <b>   while (i.hasNext()) {</b>
 <b>     AbstractInsnNode i1 = i.next();</b>
      if (isALOAD0(i1)) {
        AbstractInsnNode i2 = getNext(i1);
        if (i2 != null &amp;&amp; isALOAD0(i2)) {
          AbstractInsnNode i3 = getNext(i2);
          if (i3 != null &amp;&amp; i3.getOpcode() == GETFIELD) {
            AbstractInsnNode i4 = getNext(i3);
            if (i4 != null &amp;&amp; i4.getOpcode() == PUTFIELD) {
              if (sameField(i3, i4)) {
                <b>while (i.next() != i4) {</b>
 <b>               }</b>
 <b>               insns.remove(i1);</b>
 <b>               insns.remove(i2);</b>
 <b>               insns.remove(i3);</b>
 <b>               insns.remove(i4);</b>
              }
            }
          }
        }
      }
    }
    super.transform(mn);
  }
  <b>private static AbstractInsnNode getNext(AbstractInsnNode insn) {</b>
 <b>   do {</b>
 <b>     insn = insn.getNext();</b>
 <b>     if (insn != null &amp;&amp; !(insn instanceof LineNumberNode)) {</b>
 <b>       break;</b>
 <b>     }</b>
 <b>   } while (insn != null);</b>
 <b>   return insn;</b>
 <b> }</b>
  private static boolean isALOAD0(AbstractInsnNode i) {
    return i.getOpcode() == ALOAD &amp;&amp; ((VarInsnNode) i).var == 0;
  }
  private static boolean sameField(AbstractInsnNode i,
      AbstractInsnNode j) {
    return ((FieldInsnNode) i).name.equals(((FieldInsnNode) j).name);
  }
}
</pre>
<div class="Standard">
Here again we can see that it is possible to remove instructions in an instruction list while iterating over it. Note however the <tt>while (i.next() != i4)</tt> loop: this is necessary to place the iterator <i>after</i> the instructions that must be removed (since it is not possible to remove the instruction just after the current one). Both the visitor and tree based implementations can detect labels and frames in the middle of the sequence to be detected, and in this case do not remove it. But ignoring the line numbers inside the sequence requires more code with the tree based API (see the <tt>getNext</tt> method) than with the core API. The major difference between the two implementations, however, is that no state machine is needed with the tree API. In particular the special case of three or more successive <tt>ALOAD 0</tt> instructions, which can easily be overlooked, is no longer a problem.
</div>
<div class="Standard">
With the above implementation, a given instruction may be examined more than once since, at each step of the <tt>while</tt> loop, <tt>i2</tt>, <tt>i3</tt> and <tt>i4</tt>, which will be examined in future iterations, may also be examined at this iteration. It is in fact possible to use a more efficient implementation, where each instruction is examined at most once:
</div>
<pre class="LyX-Code">
public class RemoveGetFieldPutFieldTransformer2 extends
    MethodTransformer {
  ...
  @Override public void transform(MethodNode mn) {
    InsnList insns = mn.instructions;
    Iterator i = insns.iterator();
    while (i.hasNext()) {
      AbstractInsnNode i1 = (AbstractInsnNode) i.next();
      if (isALOAD0(i1)) {
        AbstractInsnNode i2 = getNext(i);
        if (i2 != null &amp;&amp; isALOAD0(i2)) {
          AbstractInsnNode i3 = getNext(i);
          <b>while (i3 != null &amp;&amp; isALOAD0(i3)) {</b>
 <b>           i1 = i2;</b>
 <b>           i2 = i3;</b>
 <b>           i3 = getNext(i);</b>
 <b>         }</b>
          if (i3 != null &amp;&amp; i3.getOpcode() == GETFIELD) {
            AbstractInsnNode i4 = getNext(i);
            if (i4 != null &amp;&amp; i4.getOpcode() == PUTFIELD) {
              if (sameField(i3, i4)) {
                insns.remove(i1);
                insns.remove(i2);
                insns.remove(i3);
                insns.remove(i4);
              }
            }
          }
        }
      }
    }
    super.transform(mn);
  }
  private static AbstractInsnNode getNext(Iterator i) {
    while (i.hasNext()) {
      AbstractInsnNode in = (AbstractInsnNode) i.next();
      if (!(in instanceof LineNumberNode)) {
        return in;
      }
    }
    return null;
  }
  ...
}
</pre>
<div class="Standard">
The difference with the previous implementation is the <tt>getNext</tt> method, which now acts on the list iterator. When the sequence is recognized the iterator is just after it, so the <tt>while (i.next() != i4)</tt> loop is no longer necessary. But here the special case of three or more successive <tt>ALOAD 0</tt> instructions shows up again (see the <tt>while (i3 != null)</tt> loop).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.5">7.1.5</a> Global transformations<a class="Label" name="sub:Global-transformations"> </a>
</h3>
<div class="Standard">
All the method transformations that we have seen so far were <i>local</i>, even the statefull ones, in the sense that the transformation of an instruction <i>i</i> only depended on instructions at a fixed distance from <i>i</i>. There are however <i>global</i> transformations, where the transformation of an instruction <i>i</i> may depend on instructions that can be at an arbitrary distance of <i>i</i>. For these transformations the tree API is really helpful, i.e., using the core API to implement them would be really complicated.
</div>
<div class="Standard">
One example is a transformation that replaces a jump to a <tt>GOTO</tt> <tt><i>label</i></tt> instruction with a jump to <tt><i>label</i></tt>, and that replaces a <tt>GOTO</tt> to a <tt>RETURN</tt> instruction with this <tt>RETURN</tt> instruction. Indeed the target of a jump instruction can be at an arbitrary distance of this instruction, before or after it. Such a transformation can be implemented as follows:
</div>
<pre class="LyX-Code">
public class OptimizeJumpTransformer extends MethodTransformer {
  public OptimizeJumpTransformer(MethodTransformer mt) {
    super(mt);
  }
  @Override public void transform(MethodNode mn) {
    InsnList insns = mn.instructions;
    Iterator&lt;AbstractInsnNode&gt; i = insns.iterator();
    while (i.hasNext()) {
      AbstractInsnNode in = i.next();
      if (in instanceof JumpInsnNode) {
        LabelNode label = ((JumpInsnNode) in).label;
        AbstractInsnNode target;
        // while target == goto l, replace label with l  
        while (true) {
          target = label;
          while (target != null &amp;&amp; target.getOpcode() &lt; 0) {
            target = target.getNext();
          }
          if (target != null &amp;&amp; target.getOpcode() == GOTO) {
            label = ((JumpInsnNode) target).label;
          } else {
            break;
          }
        }
        // update target
        ((JumpInsnNode) in).label = label;
        // if possible, replace jump with target instruction
        if (in.getOpcode() == GOTO &amp;&amp; target != null) {
          int op = target.getOpcode();
          if ((op &gt;= IRETURN &amp;&amp; op &lt;= RETURN) || op == ATHROW) {
            // replace ’in’ with clone of ’target’
            insns.set(in, target.<b>clone</b>(null));
          }
        }
      }
    }
    super.transform(mn);
  }
}
</pre>
<div class="Standard">
This code works as follows: when a jump instruction <tt>in</tt> is found, its target is stored in <tt>label</tt>. Then the instruction that comes just after this label is searched for with the innermost while loop (<tt>AbstractInsnNode</tt> objects that do not represent real instructions, such as <tt>FrameNode</tt> or <tt>LabelNode</tt>, have a negative &ldquo;opcode&rdquo;). As long as this instruction is a <tt>GOTO</tt>, <tt>label</tt> is replaced with the target of this instruction, and the previous steps are repeated. Finally the target label of <tt>in</tt> is replaced with this updated <tt>label</tt> value and, if <tt>in</tt> is itself a <tt>GOTO</tt> and if its updated target is a <tt>RETURN</tt> instruction, <tt>in</tt> is replaced with a <i>clone</i> of this return instruction (recall that an instruction object cannot appear more than once in an instruction list).
</div>
<div class="Standard">
The effect of this transformation on the <tt>checkAndSetF</tt> method defined in section <a class="Reference" href="#sub:Frames">3.1.5↑</a> is shown below:
</div>
<pre class="LyX-Code">
// before                  // after
  ILOAD 1                    ILOAD 1
  IFLT <i>label</i>                 IFLT <i>label</i>
  ALOAD 0                    ALOAD 0
  ILOAD 1                    ILOAD 1
  PUTFIELD ...               PUTFIELD ...
  GOTO <i>end</i>                   <b>RETURN</b>
<i>label:                     label:</i>
F_SAME                     F_SAME
  NEW ...                    NEW ...
  DUP                        DUP
  INVOKESPECIAL ...          INVOKESPECIAL ...
  ATHROW                     ATHROW
<i>end:                       end:</i>
F_SAME                     F_SAME
  RETURN                     RETURN
</pre>
<div class="Standard">
Note that, although this transformation changes the jump instructions (more formally the control flow graph), it does <i>not</i> need to update the method’s frames<a class="IndexReference" name="entry-frames-updating-3" href="#index-frames-updating">↓</a>. Indeed the state of the execution frame remains the same at each instruction and, since no new jump target is introduced, no new frame must be visited. It may happen, however, that a frame is no longer needed. For instance, in the above example, the <tt><i>end</i></tt> label is no longer used after transformation, as well as the <tt>F_SAME</tt> frame and the <tt>RETURN</tt> instruction after it. Hopefully it is perfectly legal to visit more frames than is strictly necessary, as well as to include unused code — called <i>dead</i><a class="IndexReference" name="entry-dead-code-0" href="#index-dead-code">↓</a> or <i>unreachable</i><a class="IndexReference" name="entry-unreachable-code-0" href="#index-unreachable-code">↓</a> code — in a method. The above method adapter is therefore correct, even if it could be improved to remove dead code and frames.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.2">7.2</a> Components composition
</h2>
<div class="Standard">
So far we have only seen how to create and transform <tt>MethodNode</tt> objects, but we haven’t seen the link with the byte array representation of classes. Like for classes, this link is done by composing the core API and tree API components, as explained in this section.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.2.1">7.2.1</a> Presentation
</h3>
<div class="Standard">
In addition to the fields shown in Figure <a class="Reference" href="#fig:The-MethodNode-class">7.1↑</a> the <tt>MethodNode</tt> class extends the <tt>MethodVisitor</tt> class, and also provides two <tt>accept</tt> methods that take a <tt>MethodVisitor</tt> or a <tt>ClassVisitor</tt> as parameter. The <tt>accept</tt> methods generate events based on the <tt>MethodNode</tt> field values, while the <tt>MethodVisitor</tt> methods perform the inverse operation, i.e. set the <tt>MethodNode</tt> fields based on the received events.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.2.2">7.2.2</a> Patterns<a class="Label" name="sub:MethodAPICompositionPatterns"> </a>
</h3>
<div class="Standard">
Like for classes, it is possible to use a tree based method transformer like a method adapter with the core API. The two patterns that can be used for classes are indeed also valid for methods, and work exactly in the same way. The pattern based on inheritance is the following:
</div>
<pre class="LyX-Code">
public class MyMethodAdapter <b>extends MethodNode</b> {
  public MyMethodAdapter(int access, String name, String desc, 
      String signature, String[] exceptions, MethodVisitor mv) {
    super(ASM4, access, name, desc, signature, exceptions);
    this.mv = mv;
  }
  @Override public void visitEnd() {
    // put your transformation code here
    <b>accept(mv);</b>
  }
}
</pre>
<div class="Standard">
While the pattern based on delegation is:
</div>
<pre class="LyX-Code">
public class MyMethodAdapter extends MethodVisitor {
  MethodVisitor next;
  public MyMethodAdapter(int access, String name, String desc, 
      String signature, String[] exceptions, MethodVisitor mv) {
    super(ASM4, 
<b>       new MethodNode(access, name, desc, signature, exceptions)</b>);
    next = mv;
  }
  @Override public void visitEnd() {
    MethodNode mn = (MethodNode) mv;
    // put your transformation code here
    <b>mn.accept(next);</b>
  }
}
</pre>
<div class="Standard">
A variant of the first pattern is to use it with an anonymous inner class directly in the <tt>visitMethod</tt> of a <tt>ClassAdapter</tt>:
</div>
<pre class="LyX-Code">
public MethodVisitor visitMethod(int access, String name,
    String desc, String signature, String[] exceptions) {
  return <b>new MethodNode</b>(ASM4, access, name, desc, signature, exceptions) 
  {
    @Override public void visitEnd() {
      // put your transformation code here
      <b>accept(cv);</b>
    }
  };
}
</pre>
<div class="Standard">
These patterns show that it is possible to use the tree API only for methods, and the core API for classes. <i>In practice this strategy is often used</i>.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-8">8</a> Method Analysis
</h1>
<div class="Standard">
This chapter presents the ASM API for analyzing the code of methods, which is based on the tree API. It starts with a presentation of code analysis algorithms, and then presents the corresponding ASM API, with some examples.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.1">8.1</a> Presentation
</h2>
<div class="Standard">
Code analysis is a very large topic, and many algorithms exist for analyzing code. It would be impossible and out of the scope of this document to present them all here. In fact the goal of this section is just to give an overview of the algorithms that are used in ASM. A better presentation of this topic can be found in books about compilers. The next sections present two important types of code analysis techniques, namely data flow and control flow analysis:
</div>
<ul>
<li>
A <i>data flow</i><a class="IndexReference" name="entry-data-flow-analysis-0" href="#index-data-flow-analysis">↓</a> analysis consists in computing the state of the execution frames of a method, for each instruction of this method. This state can be represented in a more or less abstract way. For example reference values can be represented by a single value, by one value per class, by three possible values in the { null, not null, may be null } set, etc.
</li>
<li>
A <i>control flow</i><a class="IndexReference" name="entry-control-flow-analysis-0" href="#index-control-flow-analysis">↓</a> analysis consists in computing the control flow graph of a method, and in performing analyses on this graph. The <i>control flow graph</i><a class="IndexReference" name="entry-control-flow-graph-1" href="#index-control-flow-graph">↓</a> is a graph whose nodes are instructions, and whose oriented edges connect two instructions <span class="formula"><i>i</i> → <i>j</i></span> if <span class="formula"><i>j</i></span> can be executed just after <span class="formula"><i>i</i></span>.
</li>

</ul>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.1">8.1.1</a> Data flow analyses
</h3>
<div class="Standard">
Two types of data flow analyses can be performed:
</div>
<ul>
<li>
a <i>forward</i> analysis computes, for each instruction, the state of the execution frame after this instruction, from the state before its execution.
</li>
<li>
a <i>backward</i> analysis computes, for each instruction, the state of the execution frame <i>before</i> this instruction, from the state after its execution.
</li>

</ul>
<div class="Standard">
A forward data flow analysis is performed by simulating the execution of each bytecode instruction of a method on its execution frame, which generally consists in:
</div>
<ul>
<li>
popping values from the stack, 
</li>
<li>
combining them, 
</li>
<li>
and pushing the result on the stack. 
</li>

</ul>
<div class="Standard">
This looks like what an interpreter or the Java Virtual Machine does, but in fact it is completely different because the goal is to simulate <i>all potential execution paths</i> in a method, <i>for all possible argument values</i>, instead of the single execution path determined by some specific method argument values. One consequence is that, for branch instructions, <i>both</i> branches are simulated (while a real interpreter follows only one branch, depending on the actual condition value).
</div>
<div class="Standard">
Another consequence is that the manipulated values are in fact <i>sets</i> of possible values. These sets can be very large, such as &ldquo;all possible values&rdquo;, &ldquo;all the integers&rdquo;, &ldquo;all possible objects&rdquo; or &ldquo;all possible <tt>String</tt> objects&rdquo;, in which case they can also be called <i>types</i>. They can also be more precise, such as &ldquo;all positive integers&rdquo;, &ldquo;all integers between 0 and 10&rdquo; or &ldquo;all possible non <tt>null</tt> objects&rdquo;. Simulating the execution of an instruction <i>i</i> consists in finding the set of all possible results of <i>i</i>, for all combinations of values in its operand value sets. For instance, if integers are represented by three sets P = &ldquo;positive or null&rdquo;, N = &ldquo;negative or null&rdquo;, and A = &ldquo;all integers&rdquo;, simulating the <tt>IADD</tt> instruction means returning P if both operands are P, N if both operands are N, and A in all other cases.
</div>
<div class="Standard">
A last consequence is the need to compute <i>unions</i> of sets of values: for example the set of possible values corresponding to <tt>(b ? e1 : e2)</tt> is the union of the possible values of <tt>e1</tt> and of the possible values of <tt>e2</tt>. More generally this operation is needed each time the control flow graph contains two or more edges with a common destination. In the previous example, where integers are represented by the three sets P, N, and A, computing the union of two of these sets is easy: it is always A, unless the two sets are equal.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.2">8.1.2</a> Control flow analyses<a class="Label" name="sub:Control-flow-analyses"> </a>
</h3>
<div class="Standard">
A control flow analysis is an analysis based on the control flow graph of a method. As an example, the control flow graph of the <tt>checkAndSetF</tt> method in section <a class="Reference" href="#sub:Bytecode-sequence-examples">3.1.3↑</a> is given below (with labels included in the graph like real instructions):
</div>
<div class="Standard">
<div class="center">
<img class="embedded" src="figures/controlflowgraph.png" alt="figure figures/controlflowgraph.png" style="max-width: 302px; max-height: 170px;"/>

</div>

</div>
<div class="Standard">
This graph can be decomposed in four <i>basic blocks</i><a class="IndexReference" name="entry-basic-block-0" href="#index-basic-block">↓</a> (shown above with rectangles), a basic block being a sequence of instructions such that each instruction except the last one has exactly one successor, and such that no instruction except the first one can be the target of a jump.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.2">8.2</a> Interfaces and components
</h2>
<div class="Standard">
The ASM API for code analysis is in the <tt>org.objectweb.asm.tree.analysis</tt> package. As the package name implies, it is based on the tree API. In fact this package provides a framework for doing forward data flow analyses.
</div>
<div class="Standard">
In order to be able to perform various data flow analyses, with more or less precise sets of values, the data flow analysis algorithm is split in two parts: one is fixed and is provided by the framework, the other is variable and provided by users. More precisely:
</div>
<ul>
<li>
The overall data flow analysis algorithm, and the task of popping from the stack, and pushing back to the stack, the appropriate number of values, is implemented once and for all in the <tt>Analyzer</tt><a class="IndexReference" name="entry-Analyzer_-0" href="#index-Analyzer_">↓</a> and <tt>Frame</tt><a class="IndexReference" name="entry-Frame_-0" href="#index-Frame_">↓</a> classes.
</li>
<li>
The task of combining values and of computing unions of value sets is performed by user defined subclasses of the <tt>Interpreter</tt><a class="IndexReference" name="entry-Interpreter_-0" href="#index-Interpreter_">↓</a> and <tt>Value</tt><a class="IndexReference" name="entry-Value_-0" href="#index-Value_">↓</a> abstract classes. Several predefined subclasses are provided, and are explained in the next sections.
</li>

</ul>
<div class="Standard">
Although the primary goal of the framework is to perform data flow analyses, the <tt>Analyzer</tt> class can also construct the control flow graph of the analyzed method. This can be done by overriding the <tt>newControlFlowEdge</tt> and <tt>newControlFlowExceptionEdge</tt> methods of this class, which by default do nothing. The result can be used for doing control flow analyses.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.1">8.2.1</a> Basic data flow analysis
</h3>
<div class="Standard">
The <tt>BasicInterpreter</tt><a class="IndexReference" name="entry-BasicInterpreter_-0" href="#index-BasicInterpreter_">↓</a> class is one of the predefined subclass of the <tt>Interpreter</tt> abstract class. It simulates the effect of bytecode instructions by using seven sets of values, defined in the <tt>BasicValue</tt> class:
</div>
<ul>
<li>
<tt>UNINITIALIZED_VALUE</tt> means &ldquo;all possible values&rdquo;.
</li>
<li>
<tt>INT_VALUE</tt> means &ldquo;all <tt>int</tt>, <tt>short</tt>, <tt>byte</tt>, <tt>boolean</tt> or <tt>char</tt> values&rdquo;.
</li>
<li>
<tt>FLOAT_VALUE</tt> means &ldquo;all <tt>float</tt> values&rdquo;.
</li>
<li>
<tt>LONG_VALUE</tt> means &ldquo;all <tt>long</tt> values&rdquo;.
</li>
<li>
<tt>DOUBLE_VALUE</tt> means &ldquo;all <tt>double</tt> values&rdquo;.
</li>
<li>
<tt>REFERENCE_VALUE</tt> means &ldquo;all object and array values&rdquo;.
</li>
<li>
<tt>RETURNADDRESS_VALUE</tt> is used for subroutines (see Appendix <a class="Reference" href="#sec:Subroutines">11.2↓</a>).
</li>

</ul>
<div class="Standard">
This interpreter is not very useful in itself (the method frames already provide such an information, with more details — see section <a class="Reference" href="#sub:Frames">3.1.5↑</a>), but it can be used as an &ldquo;empty&rdquo; <tt>Interpreter</tt> implementation in order to construct an <tt>Analyzer</tt>. This analyzer can then be used to detect unreachable code in a method. Indeed, even by following both branches in jumps instructions, it is not possible to reach code that cannot be reached from the first instruction. The consequence is that, after an analysis, and whatever the <tt>Interpreter</tt> implementation, the computed frames — returned by the <tt>Analyzer.getFrames</tt> method — are <tt>null</tt> for instructions that cannot be reached. This property can be used to implement a <tt>RemoveDeadCodeAdapter</tt><a class="IndexReference" name="entry-dead-code-removing-0" href="#index-dead-code-removing">↓</a> class very easily (there are more efficient ways, but they require to write more code):
</div>
<pre class="LyX-Code">
public class RemoveDeadCodeAdapter extends MethodVisitor {
  String owner;
  MethodVisitor next;
  public RemoveDeadCodeAdapter(String owner, int access, String name,
      String desc, MethodVisitor mv) {
    super(ASM4, new MethodNode(access, name, desc, null, null));
    this.owner = owner;
    next = mv;
  }
  @Override public void visitEnd() {
    MethodNode mn = (MethodNode) mv;
    <b>Analyzer&lt;BasicValue&gt; a = </b>
<b>        new Analyzer&lt;BasicValue&gt;(new BasicInterpreter());</b>
    try {
      <b>a.analyze(owner, mn);</b>
 <b>     Frame&lt;BasicValue&gt;[] frames = a.getFrames();</b>
      AbstractInsnNode[] insns = mn.instructions.toArray();
      for (int i = 0; i &lt; frames.length; ++i) {
        <b>if (frames[i] == null &amp;&amp; !(insns[i] instanceof LabelNode)) {</b>
 <b>         mn.instructions.remove(insns[i]);</b>
 <b>       }</b>
      }
    } catch (AnalyzerException ignored) {
    }
    mn.accept(next);
  }
}
</pre>
<div class="Standard">
When combined with the <tt>OptimizeJumpAdapter</tt> of section <a class="Reference" href="#sub:Global-transformations">7.1.5↑</a>, the dead code introduced by the jump optimizer is removed. For example, using this adapter chain on the <tt>checkAndSetF</tt> method gives:
</div>
<pre class="LyX-Code">
// after OptimizeJump      // after RemoveDeadCode
  ILOAD 1                    ILOAD 1
  IFLT <i>label</i>                 IFLT <i>label</i>
  ALOAD 0                    ALOAD 0
  ILOAD 1                    ILOAD 1
  PUTFIELD ...               PUTFIELD ...
  RETURN                   <b> </b> RETURN
<i>label:                     label:</i>
F_SAME                     F_SAME
  NEW ...                    NEW ...
  DUP                        DUP
  INVOKESPECIAL ...          INVOKESPECIAL ...
  ATHROW                     ATHROW
<i>end:                       end:</i>
F_SAME
  RETURN
</pre>
<div class="Standard">
Note that dead labels are not removed. This is done on purpose: indeed it does not change the resulting code, but avoids removing a label that, although not reachable, might be referenced in a <tt>LocalVariableNode</tt>, for instance.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.2">8.2.2</a> Basic data flow verifier
</h3>
<div class="Standard">
The <tt>BasicVerifier</tt><a class="IndexReference" name="entry-BasicVerifier_-0" href="#index-BasicVerifier_">↓</a> class extends the <tt>BasicInterpreter</tt> class. It uses the same seven sets but, unlike <tt>BasicInterpreter</tt>, checks that instructions are used correctly. For instance it checks that the operands of an <tt>IADD</tt> instruction are <tt>INTEGER_VALUE</tt> values (while <tt>BasicInterpreter</tt> just returns the result, i.e. <tt>INTEGER_VALUE</tt>). This class can be used for debugging purposes during the development of a class generator or adapter, as explained in section <a class="Reference" href="#sub:MethodTools">3.3↑</a>. For instance this class can detect that the <tt>ISTORE</tt> <tt>1</tt> <tt>ALOAD</tt> <tt>1</tt> sequence is invalid. It can be included in a utility method adapter like this (in practice it is simpler to use the <tt>CheckMethodAdapter</tt> class, which can be configured to use a <tt>BasicVerifier</tt>):
</div>
<pre class="LyX-Code">
public class BasicVerifierAdapter extends MethodVisitor {
  String owner;
  MethodVisitor next;
  public BasicVerifierAdapter(String owner, int access, String name,
      String desc, MethodVisitor mv) {
    super(ASM4, new MethodNode(access, name, desc, null, null));
    this.owner = owner;
    next = mv;
  }
  @Override public void visitEnd() {
    MethodNode mn = (MethodNode) mv;
    <b>Analyzer&lt;BasicValue&gt; a = </b>
<b>        new Analyzer&lt;BasicValue(new BasicVerifier());</b>
 <b>   try {</b>
 <b>     a.analyze(owner, mn);</b>
 <b>   } catch (AnalyzerException e) {</b>
 <b>     throw new RuntimeException(e.getMessage());</b>
 <b>   }</b>
    mn.accept(next);
  }
}
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.3">8.2.3</a> Simple data flow verifier
</h3>
<div class="Standard">
The <tt>SimpleVerifier</tt><a class="IndexReference" name="entry-SimpleVerifier_-0" href="#index-SimpleVerifier_">↓</a> class extends the <tt>BasicVerifier</tt> class. It uses more sets to simulate the execution of bytecode instructions: indeed each class is represented by its own set, representing all possible objects of this class. It can therefore detect more errors, such as the fact of calling a method defined in the <tt>String</tt> class on an object whose possible values are &ldquo;all objects of type <tt>Thread</tt>&rdquo;.
</div>
<div class="Standard">
This class uses the Java reflection API in order to perform verifications and computations related to the class hierarchy. It therefore loads the classes referenced by a method into the JVM. This default behavior can be changed by overriding the protected methods of this class.
</div>
<div class="Standard">
Like <tt>BasicVerifier</tt>, this class could be used during the development of a class generator or adapter in order find bugs more easily. But it can also be used for other purposes. One example is a transformation that removes unnecessary casts in methods: if this analyzer finds that the operand of a <tt>CHECKCAST</tt> <tt>to</tt> instruction is the set of values &ldquo;all objects of type <tt>from</tt>&rdquo;, and if <tt>to</tt> is a super class of <tt>from</tt>, then the <tt>CHECKCAST</tt> instruction is unnecessary and can be removed. The implementation of this transformation is the following:
</div>
<pre class="LyX-Code">
public class RemoveUnusedCastTransformer extends MethodTransformer {
  String owner;
  public RemoveUnusedCastTransformer(String owner,
      MethodTransformer mt) {
    super(mt);
    this.owner = owner;
  }
  @Override public MethodNode transform(MethodNode mn) {
    <b>Analyzer&lt;BasicValue&gt; a = </b>
<b>        new Analyzer&lt;BasicValue&gt;(new SimpleVerifier());</b>
    try {
      <b>a.analyze(owner, mn);</b>
 <b>     Frame&lt;BasicValue&gt;[] frames = a.getFrames();</b>
      AbstractInsnNode[] insns = mn.instructions.toArray();
      for (int i = 0; i &lt; insns.length; ++i) {
        AbstractInsnNode insn = insns[i];
        <b>if (insn.getOpcode() == CHECKCAST) {</b>
          Frame f = frames[i];
          if (f != null &amp;&amp; f.getStackSize() &gt; 0) {
            <b>Object operand = f.getStack(f.getStackSize() - 1);</b>
            Class&lt;?&gt; to = getClass(((TypeInsnNode) insn).desc);
            Class&lt;?&gt; from = getClass(((BasicValue) operand).getType());
            <b>if (to.isAssignableFrom(from)) {</b>
 <b>             mn.instructions.remove(insn);</b>
 <b>           }</b>
          }
        }
      }
    } catch (AnalyzerException ignored) {
    }
    return mt == null ? mn : mt.transform(mn);
  }
  private static Class&lt;?&gt; getClass(String desc) {
    try {
      return Class.forName(desc.replace(’/’, ’.’));
    } catch (ClassNotFoundException e) {
      throw new RuntimeException(e.toString());
    }
  }
  private static Class&lt;?&gt; getClass(Type t) {
    if (t.getSort() == Type.OBJECT) {
      return getClass(t.getInternalName());
    }
    return getClass(t.getDescriptor());
  }
}
</pre>
<div class="Standard">
For Java 6 classes (or classes upgraded to Java 6 with <tt>COMPUTE_FRAMES</tt>), however, it is simpler and much more efficient to use an <tt>AnalyzerAdapter</tt> for doing this with the core API:
</div>
<pre class="LyX-Code">
public class RemoveUnusedCastAdapter extends MethodVisitor {
  <b>public AnalyzerAdapter aa;</b>
  public RemoveUnusedCastAdapter(MethodVisitor mv) {
    super(ASM4, mv);
  }
  @Override public void visitTypeInsn(int opcode, String desc) {
    <b>if (opcode == CHECKCAST) {</b>
      Class&lt;?&gt; to = getClass(desc);
      if (aa.stack != null &amp;&amp; aa.stack.size() &gt; 0) {
        <b>Object operand = aa.stack.get(aa.stack.size() - 1);</b>
        if (operand instanceof String) {
          Class&lt;?&gt; from = getClass((String) operand);
          <b>if (to.isAssignableFrom(from)) {</b>
 <b>           return;</b>
 <b>         }</b>
        }
      }
    }
    mv.visitTypeInsn(opcode, desc);
  }
  private static Class getClass(String desc) {
    try {
      return Class.forName(desc.replace(’/’, ’.’));
    } catch (ClassNotFoundException e) {
      throw new RuntimeException(e.toString());
    }
  }
}
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.4">8.2.4</a> User defined data flow analysis
</h3>
<div class="Standard">
Let’s suppose that we would like to detect field accesses and method calls on potentially <tt>null</tt> objects, such as in the following source code fragment (where the first line prevents some compilers from detecting the bug, which would otherwise be detected as an &ldquo;o may not have been initialized&rdquo; error):
</div>
<pre class="LyX-Code">
Object o = null;
while (...) {
  o = ...;
}
o.m(...); // potential NullPointerException!
</pre>
<div class="Standard">
Then we need a data flow analysis that can tell us that, at the <tt>INVOKEVIRTUAL</tt> instruction corresponding to the last line, the bottom stack value, corresponding to <tt>o</tt>, may be <tt>null</tt>. In order to do that we need to distinguish three sets for reference values: the <tt>NULL</tt> set containing the <tt>null</tt> value, the <tt>NONNULL</tt> set containing all non null reference values, and the <tt>MAYBENULL</tt> set containing all the reference values. Then we just need to consider that <tt>ACONST_NULL</tt> pushes the <tt>NULL</tt> set on the operand stack, while all other instructions that push a reference value on the stack push the <tt>NONNULL</tt> set (in other words we consider that the result of any field access or method call is not <tt>null</tt> — we cannot do better without a global analysis of all the classes of the program). The <tt>MAYBENULL</tt> set is necessary to represent the union of the <tt>NULL</tt> and <tt>NONNULL</tt> sets.
</div>
<div class="Standard">
The above rules must be implemented in a custom <tt>Interpreter</tt> subclass. It would be possible to implement it from scratch, but it is also possible, and much easier, to implement it by extending the <tt>BasicInterpreter</tt><a class="IndexReference" name="entry-BasicInterpreter_-1" href="#index-BasicInterpreter_">↓</a> class. Indeed, if we consider that <tt>BasicValue.REFERENCE_VALUE</tt> corresponds to the <tt>NONNULL</tt> set, then we just need to override the method that simulates the execution of <tt>ACONST_NULL</tt>, so that it returns <tt>NULL</tt>, as well as the method that computes set unions:
</div>
<pre class="LyX-Code">
class IsNullInterpreter extends BasicInterpreter {
  public final static BasicValue NULL = new BasicValue(null);
  public final static BasicValue MAYBENULL = new BasicValue(null);
  public IsNullInterpreter() {
    super(ASM4);
  }
  @Override public BasicValue newOperation(AbstractInsnNode insn) {
    <b>if (insn.getOpcode() == ACONST_NULL) {</b>
 <b>     return NULL;</b>
 <b>   }</b>
    return super.newOperation(insn);
  }
  @Override public BasicValue merge(BasicValue v, BasicValue w) {
    <b>if (isRef(v) &amp;&amp; isRef(w) &amp;&amp; v != w) {</b>
 <b>     return MAYBENULL;</b>
 <b>   }</b>
    return super.merge(v, w);
  }
  private boolean isRef(Value v) {
    return v == REFERENCE_VALUE || v == NULL || v == MAYBENULL;
  }
}
</pre>
<div class="Standard">
It is then easy to use this <tt>IsNullnterpreter</tt> in order to detect instructions that can lead to potential null pointer exceptions:
</div>
<pre class="LyX-Code">
public class NullDereferenceAnalyzer {
  public List&lt;AbstractInsnNode&gt; findNullDereferences(String owner,
      MethodNode mn) throws AnalyzerException {
    List&lt;AbstractInsnNode&gt; result = new ArrayList&lt;AbstractInsnNode&gt;();
    <b>Analyzer&lt;BasicValue&gt; a = </b>
<b>        new Analyzer&lt;BasicValue&gt;(new IsNullInterpreter());</b>
 <b>   a.analyze(owner, mn);</b>
    Frame&lt;BasicValue&gt;[] frames = a.getFrames();
    AbstractInsnNode[] insns = mn.instructions.toArray();
    for (int i = 0; i &lt; insns.length; ++i) {
      AbstractInsnNode insn = insns[i];
      if (frames[i] != null) {
        <b>Value v = getTarget(insn, frames[i]);</b>
 <b>       if (v == NULL || v == MAYBENULL) {</b>
 <b>         result.add(insn);</b>
 <b>       }</b>
      }
    }
    return result;
  }
  private static BasicValue getTarget(AbstractInsnNode insn,
      Frame&lt;BasicValue&gt; f) {
    switch (insn.getOpcode()) {
    case GETFIELD:
    case ARRAYLENGTH:
    case MONITORENTER:
    case MONITOREXIT:
      return getStackValue(f, 0);
    case PUTFIELD:
      return getStackValue(f, 1);
    case INVOKEVIRTUAL:
    case INVOKESPECIAL:
    case INVOKEINTERFACE:
      String desc = ((MethodInsnNode) insn).desc;
      return getStackValue(f, Type.getArgumentTypes(desc).length);
    }
    return null;
  }
  private static BasicValue getStackValue(Frame&lt;BasicValue&gt; f, 
      int index) {
    int top = f.getStackSize() - 1;
    return index &lt;= top ? f.getStack(top - index) : null;
  }
}
</pre>
<div class="Standard">
The <tt>findNullDereferences</tt> method analyzes the given method node with an <tt>IsNullInterpreter</tt>. It then tests, for each instruction, if the set of possible values of its reference operand (if any) is the <tt>NULL</tt> or the <tt>NONNULL</tt> set. If it is the case this instruction may lead to a null pointer exception, so it is added to the list of such instructions that is returned by this method. 
</div>
<div class="Standard">
The <tt>getTarget</tt> method returns the <tt>Value</tt> corresponding to the object operand of <tt>insn</tt>, in the frame <tt>f</tt>, or <tt>null</tt> if <tt>insn</tt> does not have an object operand. Its main role is to compute the offset of this value from the top of the operand stack, which depends on the type of instruction.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.5">8.2.5</a> Control flow analysis
</h3>
<div class="Standard">
Control flow analyses can have many applications. A simple example is to compute the <i>cyclomatic complexity</i> of methods. This metric is defined as the number of edges in the control flow graph, minus the number of nodes, plus two. For instance the cyclomatic complexity of the <tt>checkAndSetF</tt> method, whose control flow graph is shown in section <a class="Reference" href="#sub:Control-flow-analyses">8.1.2↑</a>, is <span class="formula">11 − 12 + 2 = 1</span>. This metric gives a good indication of the &ldquo;complexity&rdquo; of a method (there is a correlation between this number and the average number of bugs in a method). It also gives the recommended number of test cases that are necessary to &ldquo;correctly&rdquo; test a method.
</div>
<div class="Standard">
The algorithm to compute this metric can be implemented with the ASM analysis framework (there are more efficient ways, based on the core API alone, but they require to write more code). The first step consits in constructing the control flow graph. As we said at the begining of this chapter, this can be done by overriding the <tt>newControlFlowEdge</tt> method of the <tt>Analyzer</tt> class. This class represents nodes as <tt>Frame</tt> objects. If we want to store the graph in these objects, we need to extend the <tt>Frame</tt> class:
</div>
<pre class="LyX-Code">
class Node&lt;V extends Value&gt; extends Frame&lt;V&gt; {
  Set&lt; Node&lt;V&gt; &gt; successors = new HashSet&lt; Node&lt;V&gt; &gt;();
  public Node(int nLocals, int nStack) {
    super(nLocals, nStack);
  }
  public Node(Frame&lt;? extends V&gt; src) {
    super(src);
  }
}
</pre>
<div class="Standard">
Then we can provide an <tt>Analyzer</tt> subclass that constructs our control flow graph, and use its result to compute the number of edges, the number of nodes, and finally the cyclomatic complexity:
</div>
<pre class="LyX-Code">
public class CyclomaticComplexity {
  public int getCyclomaticComplexity(String owner, MethodNode mn)
      throws AnalyzerException {
    Analyzer&lt;BasicValue&gt; a = 
<b>        new Analyzer&lt;BasicValue&gt;(new BasicInterpreter()) {</b>
 <b>     protected Frame&lt;BasicValue&gt; newFrame(int nLocals, int nStack) {</b>
 <b>       return new Node&lt;BasicValue&gt;(nLocals, nStack);</b>
 <b>     }</b>
 <b>     protected Frame&lt;BasicValue&gt; newFrame(</b>
<b>          Frame&lt;? extends BasicValue&gt; src) {</b>
 <b>       return new Node&lt;BasicValue&gt;(src);</b>
 <b>     }</b>
 <b>     protected void newControlFlowEdge(int src, int dst) {</b>
 <b>       Node&lt;BasicValue&gt; s = (Node&lt;BasicValue&gt;) getFrames()[src];</b>
 <b>       s.successors.add((Node&lt;BasicValue&gt;) getFrames()[dst]);</b>
 <b>     }</b>
 <b>   };</b>
    <b>a.analyze(owner, mn);</b>
    Frame&lt;BasicValue&gt;[] frames = a.getFrames();
    int edges = 0;
    int nodes = 0;
    for (int i = 0; i &lt; frames.length; ++i) {
      if (frames[i] != null) {
        edges += ((Node&lt;BasicValue&gt;) frames[i]).successors.size();
        nodes += 1;
      }
    }
    return edges - nodes + 2;
  }
}
</pre>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-9">9</a> Metadata
</h1>
<div class="Standard">
This chapter presents the tree API for compiled Java classes metadata, such as annotations. It is very short because these metadata have already been presented in chapter <a class="Reference" href="#cha:Metadata">4↑</a>, and because the tree API is simple once the corresponding core API is known.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-9.1">9.1</a> Generics
</h2>
<div class="Standard">
The tree API does not provide any support for generic types! Indeed it represents generic types with signatures, as in the core API, but does not provide a <tt>SignatureNode</tt> class corresponding to <tt>SignatureVisitor</tt>, although this would be possible (in fact it would be convenient to use several <tt>Node</tt> classes to distinguish between type, method and class signatures, at least).
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-9.2">9.2</a> Annotations
</h2>
<div class="Standard">
The tree API for annotations is based on the <tt>AnnotationNode</tt><a class="IndexReference" name="entry-AnnotationNode_-0" href="#index-AnnotationNode_">↓</a> class, whose public API is the following:
</div>
<pre class="LyX-Code">
public class AnnotationNode extends AnnotationVisitor {
  public String desc;
  public List&lt;Object&gt; values;
  public AnnotationNode(String desc);
  public AnnotationNode(int api, String desc);
  ... // methods of the AnnotationVisitor interface
  public void accept(AnnotationVisitor av);
}
</pre>
<div class="Standard">
The <tt>desc</tt> field contains the annotation type, while the <tt>values</tt> field contains the name value pairs, where each name is followed by its associated value (the representation of values is described in the Javadoc).
</div>
<div class="Standard">
As you can see the <tt>AnnotationNode</tt> class extends the <tt>AnnotationVisitor</tt> class, and also provides an <tt>accept</tt> method that takes as parameter an object of this type, like the <tt>ClassNode</tt> and <tt>MethodNode</tt> classes with the class and method visitor classes. The patterns that we have seen for classes and methods can therefore also be used for composing the core and tree API components for annotations. For example the &ldquo;anonymous inner class&rdquo; variant of the pattern based on inheritance (see section <a class="Reference" href="#sub:MethodAPICompositionPatterns">7.2.2↑</a>), adapted to annotations, gives:
</div>
<pre class="LyX-Code">
public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
  return <b>new AnnotationNode(ASM4, desc)</b> {
    @Override public void visitEnd() {
      // put your annotation transformation code here
      <b>accept</b>(cv.visitAnnotation(desc, visible));
    }
  };
}
</pre>
<h2 class="Section">
<a class="toc" name="toc-Section-9.3">9.3</a> Debug
</h2>
<div class="Standard">
The source file from which a class was compiled is stored in the <tt>sourceFile</tt> field in <tt>ClassNode</tt>. The information about source line numbers is stored in <tt>LineNumberNode</tt> objects, whose class inherits from <tt>AbstractInsnNode</tt>. Similarly to the core API, where information about line numbers is visited at the same time as instructions, <tt>LineNumberNode</tt> objects are part of the instruction list. Finally the name and type of source local variables is stored in the <tt>MethodNode</tt>’s <tt>localVariables</tt> field, which is a list of <tt>LocalVariableNode</tt> objects.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-10">10</a> Backward compatibility<a class="Label" name="chap:Backward-compatibility2"> </a>
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-10.1">10.1</a> Introduction
</h2>
<div class="Standard">
As with the core API, a new mechanism has been introduced in the tree API in ASM 4.0, in order to ensure backward compatibility in the future ASM versions. However, here again, this property can not be ensured by ASM alone. It requires users to follow a few simple guidelines when writing their code. The goal of this chapter is to present these guidelines, and to give an idea of the internal mechanism used in the ASM tree API to ensure backward compatibility.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-10.2">10.2</a> Guidelines
</h2>
<div class="Standard">
This section presents the guidelines that you must follow when using the ASM tree API, in order to ensure that your code will remain valid with any future ASM versions (in the sense of the contract defined in section <a class="Reference" href="#sub:Backward-compatibility-contract">5.1.1↑</a>).
</div>
<div class="Standard">
First of all, if you write a class generator using the tree API, there is no guideline to follow (as with the core API). You can create the <tt>ClassNode</tt> and other elements with any constructor, and use any method of these classes.
</div>
<div class="Standard">
If, on the other hand, you write a class analyzer or a class adapter with the tree API, <i>i.e.</i>, if you use a <tt>ClassNode</tt> or other similar classes populated directly or indirectly via a <tt>ClassReader.accept()</tt>, or if you override one of these classes, then you must follow a few guidelines, presented below.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-10.2.1">10.2.1</a> Basic rules
</h3>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--14"></a>Creating class nodes
</h4>
<div class="Standard">
We consider here the case where you create a <tt>ClassNode</tt>, populate it via a <tt>ClassReader</tt>, and then analyze or transform it before optionally writing the result with a <tt>ClassWriter</tt> (the discussion and guidelines are the same for the other node classes; analyzing or transforming a <tt>ClassNode</tt> created by someone else is discussed in the next section). In this case there is only one guideline:
</div>
<div class="Description">
<span class="Description-entry">Guideline 3:</span> to write a class analyzer or adapter with the tree API of ASM version <i>X</i>, create your <tt>ClassNode</tt> by using the constructor with this exact version as argument (as opposed to the default constructor, without parameters).
</div>
<div class="Standard">
The goal of this guideline is to throw an error as soon as an unknown feature is encountered when populating the <tt>ClassNode</tt> via a <tt>ClassReader</tt> (as defined in the backward compatibility contract). If you do not follow it, your analysis or transformation code may fail later when encountering an unknown element, or it may succeed but produce a wrong result because it should not have ignored these unknown elements. In other words, the last clause of the contract may not be ensured if this guideline is not followed.
</div>
<div class="Standard">
How does this work? Internally, <tt>ClassNode</tt> is implemented as follows in ASM 4.0 (we reuse here the example of section <a class="Reference" href="#sub:BackwardCompatibility-An-example">5.1.2↑</a>):
</div>
<pre class="LyX-Code">
public class ClassNode extends ClassVisitor {
  public ClassNode() {
    super(ASM4, null); 
  } 
  public ClassNode(int api) { 
    super(api, null); 
  } 
  ... 
  public void visitSource(String source, String debug) {
    // store source and debug in local fields ...
  }
}
</pre>
<div class="Standard">
In ASM 5.0, this code becomes:
</div>
<pre class="LyX-Code">
public class ClassNode extends ClassVisitor { 
  ... 
  public void visitSource(String source, String debug) { 
    if (api &lt; ASM5) { 
      // store source and debug in local fields ... 
    } else { 
      visitSource(null, source, debug); 
    } 
  }
  public void visitSource(Sring author, String source, String debug) { 
    if (api &lt; ASM5) {
      if (author == null) 
        visitSource(source, debug); 
      else 
        throw new RuntimeException(); 
    } else { 
      // store author, source and debug in local fields ... 
    }
  } 
  public void visitLicense(String license) { 
    if (api &lt; ASM5) throw new RuntimeException(); 
    // store license in local fields ... 
  }
}
</pre>
<div class="Standard">
If you use ASM 4.0, creating a <tt>ClassNode(ASM4)</tt> does nothing special. But if you upgrade to ASM 5.0, without changing your code, you will get a <tt>ClassNode</tt> 5.0 whose <tt>api</tt> field will be <tt>ASM4</tt> &lt; <tt>ASM5</tt>. It is then easy to see that if the input class contains a non null author or license attribute, populating the <tt>ClassNode</tt> via a <tt>ClassReader</tt> will fail, as defined in our contract. If you also upgrade your code, changing the <tt>api</tt> field to <tt>ASM5</tt> and also updating the rest of the code to take these new attributes into account, then no errors will be thrown when populating the node.
</div>
<div class="Standard">
Note that the <tt>ClassNode</tt> 5.0 code is very similar to the <tt>ClassVisitor</tt> 5.0 code. This is to ensure a proper semantics if you define subclasses of <tt>ClassNode</tt> (similarly to subclasses of <tt>ClassVisitor</tt> - see section <a class="Reference" href="#sub:Tree-Inheritance-rules">10.2.2↓</a>).
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--15"></a>Using existing class nodes
</h4>
<div class="Standard">
If your class analyzer or adapter receives a <tt>ClassNode</tt> created by someone else, then you cannot be sure of the ASM version that was passed to its constructor when it was created, if any. You could check the <tt>api</tt> field yourself, but if you find that this version is higher than the version you support, simply rejecting the class would be too conservative. Indeed, it may happen that this class does not contain any unknown feature. On the other hand, you cannot test if unknown features are present or not (in our example scenario, how could you test, when writing code for ASM 4.0, that the unknown <tt>license</tt> field is not present in your <tt>ClassNode</tt>, since you do not know at this stage that such a field will be added in the future?). The <tt>ClassNode.check()</tt> method is designed to solve this issue. This leads to the following guideline:
</div>
<div class="Description">
<span class="Description-entry">Guideline 4:</span> to write a class analyzer or adapter with the tree API of ASM version <i>X</i>, using a <tt>ClassNode</tt> created by someone else, call its <tt>check()</tt> method with this exact version as argument before using the <tt>ClassNode</tt> in any way.
</div>
<div class="Standard">
The goal is the same as for guideline 3: the last clause of the contract may not be ensured if this guideline is not followed. How does this work? Internally, the check method is implemented as follows in ASM 4.0
</div>
<pre class="LyX-Code">
public class ClassNode extends ClassVisitor { 
  ... 
  public void check(int api) { 
    // nothing to do 
  }
}
</pre>
<div class="Standard">
In ASM 5.0 this code becomes:
</div>
<pre class="LyX-Code">
public class ClassNode extends ClassVisitor { 
  ...
  public void check(int api) {
    if (api &lt; ASM5 &amp;&amp; (author != null || license != null)) {
      throw new RuntimeException();
    }
  }
}
</pre>
<div class="Standard">
If your code is written for ASM 4.0, and if you get a <tt>ClassNode</tt> 4.0, whose <tt>api</tt> field will be <tt>ASM4</tt>, there will be no problem and <tt>check</tt> does nothing. But if you get a <tt>ClassNode</tt> 5.0, the <tt>check(ASM4)</tt> method will fail if this node actually contains a non null <tt>author</tt> or <tt>license</tt>, i.e. if it contains new features that were unknown in ASM 4.0.
</div>
<div class="Description">
<span class="Description-entry">Note:</span> this guideline can also be used if you create the <tt>ClassNode</tt> yourself. Then you don’t need to follow guideline 3, <i>i.e.</i>, you don’t need to specify an ASM version in the ClassNode constructor. The checks will occur instead in the <tt>check</tt> method (but this may be less efficient that doing the checks earlier, when populating the <tt>ClassNode</tt>).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-10.2.2">10.2.2</a> Inheritance rules<a class="Label" name="sub:Tree-Inheritance-rules"> </a>
</h3>
<div class="Standard">
If you want to provide subclasses of <tt>ClassNode</tt> or other similar node classes, then guidelines 1 and 2 apply. Note that, in the special case, often used, of a <tt>MethodNode</tt> anonymous subclass whose <tt>visitEnd()</tt> method is overriden:
</div>
<pre class="LyX-Code">
class MyClassVisitor extends ClassVisitor { 
  ...
  public MethodVisitor visitMethod(...) { 
    final MethodVisitor mv = super.visitMethod(...);
    if (mv != null) { 
      return new MethodNode(<b>ASM4</b>) { 
        public void visitEnd() { 
          // perform a transformation 
          accept(mv); 
        }
      }
    }
    return mv;
  }
}
</pre>
<div class="Standard">
then guideline 2 is automatically enforced (the anonymous class cannot be overriden although it is not explicitely declared final). You simply need to follow guideline 3, <i>i.e.</i>, specify an ASM version in the MethodNode constructor (or follow guideline 4, <i>i.e.</i>, call <tt>check(ASM4)</tt> before performing the transformation).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-10.2.3">10.2.3</a> Other packages
</h3>
<div class="Standard">
The classes in <tt>asm.util</tt> and <tt>asm.commons</tt> have two variants of each constructor: one with and one without an ASM version parameter.
</div>
<div class="Standard">
If you simply want to instantiate and use as is the <tt>ASMifier</tt>, <tt>Textifier</tt>, or <tt>Check<i>Xxx</i>Adapter</tt> classes in <tt>asm.util</tt>, or any class in the <tt>asm.commons</tt> package, then you can instantiate them with a constructor without an ASM version parameter. You could also use a constructor with an ASM version parameter, but this would unnecessarily restrict these components to the specified ASM version (while using the no-arg constructor is equivalent to say &ldquo;use the latest ASM version&rdquo;). This is why the constructors using an ASM version parameter are declared <tt>protected</tt>.
</div>
<div class="Standard">
If, on the other hand, you want to override the <tt>ASMifier</tt>, <tt>TextifierVisitor</tt>, or <tt>CheckXxxAdapter</tt> classes in <tt>asm.util</tt>, or any class in the <tt>asm.commons</tt> package, then the guidelines 1 and 2 apply. In particular, your constructor <i>must</i> call <tt>super(...)</tt> with the ASM version you want to use as parameter.
</div>
<div class="Standard">
Finally, the same distinction must be made if you want to use vs. override the <tt>Interpreter</tt> class or its subclasses in <tt>asm.tree.analysis</tt>. Note also that before using the analysis package you must create a <tt>MethodNode</tt> or get one from someone else, and that guidelines 3 and 4 must be used here before passing this node to an <tt>Analyzer</tt>. 
</div>
<div class="Standard">
<span class="unknown">\appendix</span>
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-11">11</a> Appendix
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-11.1">11.1</a> Bytecode instructions<a class="Label" name="app:Bytecode-instructions"> </a>
</h2>
<div class="Standard">
This section gives a short description of the bytecode instructions. For a complete description, see the Java Virtual Machine Specification.
</div>
<div class="Description">
<span class="Description-entry">Conventions:</span> a and b represent <tt>int</tt>, <tt>float</tt>, <tt>long</tt> or <tt>double</tt> values (<i>e.g.</i>, they mean <tt>int</tt> for <tt>IADD</tt> but <tt>long</tt> for <tt>LADD</tt>), o and p represent objet references, v represents any value (or, for stack instructions, a value of size 1), w represents a <tt>long</tt> or <tt>double</tt>, and i, j and n represent <tt>int</tt> values.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--16"></a>Local variables
</h4>
<div class="Standard">
<table>
<tr>
<td align="left" valign="top">
Instruction
</td>
<td align="left" valign="top">
Stack before
</td>
<td align="left" valign="top">
Stack after
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ILOAD</tt>, <tt>LLOAD</tt>, <tt>FLOAD</tt>, <tt>DLOAD</tt> <i>var</i>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , a
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ALOAD</tt> <i>var</i>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , o
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ISTORE</tt>, <tt>LSTORE</tt>, <tt>FSTORE</tt>, <tt>DSTORE</tt> <i>var</i>
</td>
<td align="left" valign="top">
... , a
</td>
<td align="left" valign="top">
...
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ASTORE</tt> <i>var</i>
</td>
<td align="left" valign="top">
... , o
</td>
<td align="left" valign="top">
...
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IINC</tt> <i>var</i> <i>incr</i>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
...
</td>

</tr>

</table>

</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--17"></a>Stack
</h4>
<div class="Standard">
<table>
<tr>
<td align="left" valign="top">
<tt>POP</tt>
</td>
<td align="left" valign="top">
... , v
</td>
<td align="left" valign="top">
...
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>POP2</tt>
</td>
<td align="left" valign="top">
... , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span>
</td>
<td align="left" valign="top">
...
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top">
... , w
</td>
<td align="left" valign="top">
...
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>DUP</tt>
</td>
<td align="left" valign="top">
... , v
</td>
<td align="left" valign="top">
... , v , <b>v</b>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>DUP2</tt>
</td>
<td align="left" valign="top">
... , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span>
</td>
<td align="left" valign="top">
... , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span> , <b>v<span class="formula"><sub><span class="text"><b>1</b></span></sub></span></b> , <b>v<span class="formula"><sub><b>2</b></sub></span></b>
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top">
... , w
</td>
<td align="left" valign="top">
... , w, <b>w</b>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>SWAP</tt>
</td>
<td align="left" valign="top">
... , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span>
</td>
<td align="left" valign="top">
... , v<span class="formula"><b><sub>2</sub></b></span> , v<span class="formula"><b><sub>1</sub></b></span>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>DUP_X1</tt>
</td>
<td align="left" valign="top">
... , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span>
</td>
<td align="left" valign="top">
... , <b>v</b><span class="formula"><sub><b>2</b></sub></span> , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>DUP_X2</tt>
</td>
<td align="left" valign="top">
... , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span> , v<span class="formula"><sub>3</sub></span>
</td>
<td align="left" valign="top">
... , <b>v<span class="formula"><b><sub>3</sub></b></span></b> , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span> , v<span class="formula"><sub>3</sub></span>
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top">
... , w , v
</td>
<td align="left" valign="top">
... , <b>v</b> , w , v
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>DUP2_X1</tt>
</td>
<td align="left" valign="top">
... , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span> , v<span class="formula"><sub>3</sub></span>
</td>
<td align="left" valign="top">
... , <b>v<span class="formula"><sub><b>2</b></sub></span></b> , <b>v<span class="formula"><sub><b>3</b></sub></span></b> , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span> , v<span class="formula"><sub>3</sub></span>
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top">
... , v , w
</td>
<td align="left" valign="top">
... , <b>w</b> , v , w
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>DUP2_X2</tt>
</td>
<td align="left" valign="top">
... , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span> , v<span class="formula"><sub>3</sub></span> , v<span class="formula"><sub>4</sub></span>
</td>
<td align="left" valign="top">
... , <b>v<span class="formula"><b><sub>3</sub></b></span></b> , <b>v<span class="formula"><b><sub>4</sub></b></span></b> , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span> , v<span class="formula"><sub>3</sub></span> , v<span class="formula"><sub>4</sub></span>
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top">
... , w , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span>
</td>
<td align="left" valign="top">
... , <b>v<span class="formula"><b><sub>1</sub></b></span></b> , <b>v<span class="formula"><b><sub>2</sub></b></span></b> , w , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span>
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top">
.... , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span> , w
</td>
<td align="left" valign="top">
... , <b>w</b> , v<span class="formula"><sub><span class="text">1</span></sub></span> , v<span class="formula"><sub>2</sub></span> , w
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="left" valign="top">
... , w<span class="formula"><sub><span class="text">1</span></sub></span> , w<span class="formula"><sub>2</sub></span>
</td>
<td align="left" valign="top">
... , <b>w</b><span class="formula"><sub><b>2</b></sub></span> , w<span class="formula"><sub><span class="text">1</span></sub></span> , w<span class="formula"><sub>2</sub></span> 
</td>

</tr>

</table>

</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--18"></a>Constants
</h4>
<div class="Standard">
<table>
<tr>
<td align="left" valign="top">
<tt>ICONST_<i>n</i></tt> <span class="footnotesize">(<tt><span class="formula"> − 1 ≤ <i>n</i> ≤ 5</span></tt>)</span>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , <i>n</i>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>LCONST_<i>n</i></tt> <span class="footnotesize">(<tt><span class="formula">0 ≤ <i>n</i> ≤ 1</span></tt>)</span>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , <i>nL</i>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>FCONST_<i>n</i></tt> <span class="footnotesize">(<tt><span class="formula">0 ≤ <i>n</i> ≤ 2</span></tt>)</span>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , <i>nF</i>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>DCONST_<i>n</i></tt> <span class="footnotesize">(<tt><span class="formula">0 ≤ <i>n</i> ≤ 1</span></tt>)</span>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , <i>nD</i>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>BIPUSH</tt> <i>b</i>, <span class="formula"> − 128 ≤ <i>b</i> &lt; 127</span>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , <i>b</i>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>SIPUSH</tt> <i>s</i>, <span class="formula"> − 32768 ≤ <i>s</i> &lt; 32767</span>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , <i>s</i>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>LDC</tt> <i>cst <span class="footnotesize"></span></i>(<tt>int</tt>, <tt>float</tt>, <tt>long</tt>, <tt>double</tt>, <tt>String</tt> or <tt>Type</tt>)
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , <i>cst</i>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ACONST_NULL</tt>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , <tt>null</tt>
</td>

</tr>

</table>

</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--19"></a>Arithmetic and logic
</h4>
<div class="Standard">
<table>
<tr>
<td align="left" valign="top">
<tt>IADD</tt>, <tt>LADD</tt>, <tt>FADD</tt>, <tt>DADD</tt>
</td>
<td align="left" valign="top">
... , a , b
</td>
<td align="left" valign="top">
... , a <tt>+</tt> b
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ISUB</tt>, <tt>LSUB</tt>, <tt>FSUB</tt>, <tt>DSUB</tt>
</td>
<td align="left" valign="top">
... , a , b
</td>
<td align="left" valign="top">
... , a <tt>-</tt> b
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IMUL</tt>, <tt>LMUL</tt>, <tt>FMUL</tt>, <tt>DMUL</tt>
</td>
<td align="left" valign="top">
... , a , b
</td>
<td align="left" valign="top">
... , a <tt>*</tt> b
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IDIV</tt>, <tt>LDIV</tt>, <tt>FDIV</tt>, <tt>DDIV</tt>
</td>
<td align="left" valign="top">
... , a , b
</td>
<td align="left" valign="top">
... , a <tt>/</tt> b
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IREM</tt>, <tt>LREM</tt>, <tt>FREM</tt>, <tt>DREM</tt>
</td>
<td align="left" valign="top">
... , a , b
</td>
<td align="left" valign="top">
... , a <tt>%</tt> b
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>INEG</tt>, <tt>LNEG</tt>, <tt>FNEG</tt>, <tt>DNEG</tt>
</td>
<td align="left" valign="top">
... , a
</td>
<td align="left" valign="top">
... , <tt>-</tt>a
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ISHL</tt>, <tt>LSHL</tt>
</td>
<td align="left" valign="top">
... , a , n
</td>
<td align="left" valign="top">
... , a <tt>&lt;&lt;</tt> n
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ISHR</tt>, <tt>LSHR</tt>
</td>
<td align="left" valign="top">
... , a , n
</td>
<td align="left" valign="top">
... , a <tt>&gt;&gt;</tt> n
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IUSHR</tt>, <tt>LUSHR</tt>
</td>
<td align="left" valign="top">
... , a , n
</td>
<td align="left" valign="top">
... , a <tt>&gt;&gt;&gt;</tt> n
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IAND</tt>, <tt>LAND</tt>
</td>
<td align="left" valign="top">
... , a , b
</td>
<td align="left" valign="top">
... , a <tt>&amp;</tt> b
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IOR</tt>, <tt>LOR</tt>
</td>
<td align="left" valign="top">
... , a , b
</td>
<td align="left" valign="top">
... , a <tt>|</tt> b
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IXOR</tt>, <tt>LXOR</tt>
</td>
<td align="left" valign="top">
... , a , b
</td>
<td align="left" valign="top">
... , a <tt>^</tt> b
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>LCMP</tt>
</td>
<td align="left" valign="top">
... , a , b
</td>
<td align="left" valign="top">
... ,<span class="footnotesize"> a <tt>==</tt> b <tt>?</tt> <tt>0</tt> <tt>:</tt> <tt>(</tt>a <tt>&lt;</tt> b <tt>?</tt> <tt>-1</tt> <tt>:</tt> <tt>1)</tt></span>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>FCMPL</tt>, <tt>FCMPG</tt>
</td>
<td align="left" valign="top">
... , a , b
</td>
<td align="left" valign="top">
... , <span class="footnotesize">a <tt>==</tt> b <tt>?</tt> <tt>0</tt> <tt>:</tt> <tt>(</tt>a <tt>&lt;</tt> b <tt>?</tt> <tt>-1</tt> <tt>:</tt> <tt>1)</tt></span>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>DCMPL</tt>, <tt>DCMPG</tt>
</td>
<td align="left" valign="top">
... , a , b
</td>
<td align="left" valign="top">
... ,<span class="footnotesize"> a <tt>==</tt> b <tt>?</tt> <tt>0</tt> <tt>:</tt> <tt>(</tt>a <tt>&lt;</tt> b <tt>?</tt> <tt>-1</tt> <tt>:</tt> <tt>1)</tt></span>
</td>

</tr>

</table>

</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--20"></a>Casts
</h4>
<div class="Standard">
<table>
<tr>
<td align="left" valign="top">
<tt>I2B</tt>
</td>
<td align="left" valign="top">
... , i
</td>
<td align="left" valign="top">
... , <tt>(byte)</tt> i
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>I2C</tt>
</td>
<td align="left" valign="top">
... , i
</td>
<td align="left" valign="top">
... , <tt>(char)</tt> i
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>I2S</tt>
</td>
<td align="left" valign="top">
... , i
</td>
<td align="left" valign="top">
... , <tt>(short)</tt> i
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>L2I</tt>, <tt>F2I</tt>, <tt>D2I</tt>
</td>
<td align="left" valign="top">
... , a
</td>
<td align="left" valign="top">
... , <tt>(int)</tt> a
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>I2L</tt>, <tt>F2L</tt>, <tt>D2L</tt>
</td>
<td align="left" valign="top">
... , a
</td>
<td align="left" valign="top">
... , <tt>(long)</tt> a
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>I2F</tt>, <tt>L2F</tt>, <tt>D2F</tt>
</td>
<td align="left" valign="top">
... , a
</td>
<td align="left" valign="top">
... , <tt>(float)</tt> a
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>I2D</tt>, <tt>L2D</tt>, <tt>F2D</tt>
</td>
<td align="left" valign="top">
... , a
</td>
<td align="left" valign="top">
... , <tt>(double)</tt> a
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>CHECKCAST</tt> <i>class</i>
</td>
<td align="left" valign="top">
... , o
</td>
<td align="left" valign="top">
... , <tt>(</tt><i>class<tt></tt></i>) o
</td>

</tr>

</table>

</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--21"></a>Objects, fields and methods
</h4>
<div class="Standard">
<table>
<tr>
<td align="left" valign="top">
<tt>NEW</tt> <i>class</i>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , <tt>new</tt> <i>class</i>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>GETFIELD</tt> <i>c</i> <i>f</i> <i>t</i>
</td>
<td align="left" valign="top">
... , o
</td>
<td align="left" valign="top">
... , o<tt>.</tt><i>f</i>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>PUTFIELD</tt> <i>c</i> <i>f</i> <i>t</i>
</td>
<td align="left" valign="top">
... , o , v
</td>
<td align="left" valign="top">
...
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>GETSTATIC</tt> <i>c</i> <i>f</i> <i>t</i>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top">
... , <i>c<tt></tt></i>.<i>f</i>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>PUTSTATIC</tt> <i>c</i> <i>f</i> <i>t</i>
</td>
<td align="left" valign="top">
... , v
</td>
<td align="left" valign="top">
...
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>INVOKEVIRTUAL</tt> <i>c</i> <i>m</i> <i>t</i>
</td>
<td align="left" valign="top">
... , o , v<span class="formula"><sub>1</sub></span> , ... , v<span class="formula"><sub><i>n</i></sub></span>
</td>
<td align="left" valign="top">
... , o<tt>.</tt><i>m<tt></tt></i>(v<span class="formula"><sub>1</sub></span><tt>,</tt> ... v<span class="formula"><sub><i>n</i></sub></span><tt>)</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>INVOKESPECIAL</tt> <i>c</i> <i>m</i> <i>t</i>
</td>
<td align="left" valign="top">
... , o , v<span class="formula"><sub>1</sub></span> , ... , v<span class="formula"><sub><i>n</i></sub></span>
</td>
<td align="left" valign="top">
... , o<tt>.</tt><i>m<tt></tt></i>(v<span class="formula"><sub>1</sub></span><tt>,</tt> ... v<span class="formula"><sub><i>n</i></sub></span><tt>)</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>INVOKESTATIC</tt> <i>c</i> <i>m</i> <i>t</i>
</td>
<td align="left" valign="top">
... , v<span class="formula"><sub>1</sub></span> , ... , v<span class="formula"><sub><i>n</i></sub></span>
</td>
<td align="left" valign="top">
... , <i>c<tt></tt></i>.<i>m<tt></tt></i>(v<span class="formula"><sub>1</sub></span><tt>,</tt> ... v<span class="formula"><sub><i>n</i></sub></span><tt>)</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>INVOKEINTERFACE</tt> <i>c</i> <i>m</i> <i>t</i>
</td>
<td align="left" valign="top">
... , o , v<span class="formula"><sub>1</sub></span> , ... , v<span class="formula"><sub><i>n</i></sub></span>
</td>
<td align="left" valign="top">
... , o<tt>.</tt><i>m<tt></tt></i>(v<span class="formula"><sub>1</sub></span><tt>,</tt> ... v<span class="formula"><sub><i>n</i></sub></span><tt>)</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>INVOKEDYNAMIC</tt> <i>m</i> <i>t bsm</i> 
</td>
<td align="left" valign="top">
... , o , v<span class="formula"><sub>1</sub></span> , ... , v<span class="formula"><sub><i>n</i></sub></span>
</td>
<td align="left" valign="top">
... , o<tt>.</tt><i>m<tt></tt></i>(v<span class="formula"><sub>1</sub></span><tt>,</tt> ... v<span class="formula"><sub><i>n</i></sub></span><tt>)</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>INSTANCEOF</tt> <i>class</i>
</td>
<td align="left" valign="top">
... , o
</td>
<td align="left" valign="top">
... , o <tt>instanceof</tt> <i>class</i>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>MONITORENTER</tt>
</td>
<td align="left" valign="top">
... , o
</td>
<td align="left" valign="top">
...
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>MONITOREXIT</tt>
</td>
<td align="left" valign="top">
... , o
</td>
<td align="left" valign="top">
...
</td>

</tr>

</table>

</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--22"></a>Arrays
</h4>
<div class="Standard">
<table>
<tr>
<td align="left" valign="top">
<tt>NEWARRAY</tt> <i>type</i> <span class="footnotesize">(for any primitive type)</span>
</td>
<td align="left" valign="top">
... , n
</td>
<td align="left" valign="top">
... , <tt>new</tt> <i>type<tt></tt></i>[n<tt>]</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ANEWARRAY</tt> <i>class</i>
</td>
<td align="left" valign="top">
... , n
</td>
<td align="left" valign="top">
... , <tt>new</tt> <i>class<tt></tt></i>[n<tt>]</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>MULTIANEWARRAY</tt> <i>[...[t n</i>
</td>
<td align="left" valign="top">
<span class="footnotesize">... , i<span class="formula"><sub><span class="text">1</span></sub></span> , ... , i<span class="formula"><sub><span class="text">n</span></sub></span></span>
</td>
<td align="left" valign="top">
<span class="footnotesize">... , <tt>new</tt> <i>t<tt></tt></i>[i<span class="formula"><sub><span class="text">1</span></sub></span><tt>]</tt>...<tt>[</tt>i<span class="formula"><sub><span class="text">n</span></sub></span><tt>]</tt>...</span>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>BALOAD,</tt> <tt><span class="default">CALOAD</span></tt>, <tt><span class="default">SALOAD</span></tt>
</td>
<td align="left" valign="top">
... , o , i
</td>
<td align="left" valign="top">
... , o<tt>[</tt>i<tt>]</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IALOAD</tt>, <tt><span class="default">LALOAD</span></tt>, <tt><span class="default">FALOAD</span></tt>, <tt><span class="default">DALOAD</span></tt>
</td>
<td align="left" valign="top">
... , o , i
</td>
<td align="left" valign="top">
... , o<tt>[</tt>i<tt>]</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>AALOAD</tt>
</td>
<td align="left" valign="top">
... , o , i
</td>
<td align="left" valign="top">
... , o<tt>[</tt>i<tt>]</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>BASTORE</tt>, <tt>CASTORE</tt>, <tt>SASTORE</tt>
</td>
<td align="left" valign="top">
... , o , i , j
</td>
<td align="left" valign="top">
...
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IASTORE</tt>, <tt><span class="default">LASTORE</span></tt>, <tt><span class="default">FASTORE</span></tt>, <tt><span class="default">DASTORE</span></tt>
</td>
<td align="left" valign="top">
... , o , i , a
</td>
<td align="left" valign="top">
...
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>AASTORE</tt>
</td>
<td align="left" valign="top">
... , o , i , p
</td>
<td align="left" valign="top">
...
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ARRAYLENGTH</tt>
</td>
<td align="left" valign="top">
... , o
</td>
<td align="left" valign="top">
... , o<tt>.length</tt>
</td>

</tr>

</table>

</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--23"></a>Jumps
</h4>
<div class="Standard">
<table>
<tr>
<td align="left" valign="top">
<tt>IFEQ</tt>
</td>
<td align="left" valign="top">
... , i
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>==</tt> <tt>0</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IFNE</tt>
</td>
<td align="left" valign="top">
... , i
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>!=</tt> <tt>0</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IFLT</tt>
</td>
<td align="left" valign="top">
... , i
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>&lt;</tt> <tt>0</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IFGE</tt>
</td>
<td align="left" valign="top">
... , i
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>&gt;=</tt> <tt>0</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IFGT</tt>
</td>
<td align="left" valign="top">
... , i
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>&gt;</tt> <tt>0</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IFLE</tt>
</td>
<td align="left" valign="top">
... , i
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>&lt;=</tt> <tt>0</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IF_ICMPEQ</tt>
</td>
<td align="left" valign="top">
... , i , j
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>==</tt> j
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IF_ICMPNE</tt>
</td>
<td align="left" valign="top">
... , i , j
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>!=</tt> j
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IF_ICMPLT</tt>
</td>
<td align="left" valign="top">
... , i , j
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>&lt;</tt> j
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IF_ICMPGE</tt>
</td>
<td align="left" valign="top">
... , i , j
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>&gt;=</tt> j
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IF_ICMPGT</tt>
</td>
<td align="left" valign="top">
... , i , j
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>&gt;</tt> j
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IF_ICMPLE</tt>
</td>
<td align="left" valign="top">
... , i , j
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if i <tt>&lt;=</tt> j
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IF_ACMPEQ</tt>
</td>
<td align="left" valign="top">
... , o , p
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if o <tt>==</tt> p
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IF_ACMPNE</tt>
</td>
<td align="left" valign="top">
... , o , p
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if o <tt>!=</tt> p
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IFNULL</tt>
</td>
<td align="left" valign="top">
... , o
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if o <tt>==</tt> <tt>null</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>IFNONNULL</tt>
</td>
<td align="left" valign="top">
... , o
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump if o <tt>!=</tt> <tt>null</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>GOTO</tt>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump always
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>TABLESWITCH</tt>
</td>
<td align="left" valign="top">
... , i
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump always
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>LOOKUPSWITCH</tt>
</td>
<td align="left" valign="top">
... , i
</td>
<td align="left" valign="top" style="width: 1cm;">
...
</td>
<td align="left" valign="top">
jump always
</td>

</tr>

</table>

</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--24"></a>Return
</h4>
<div class="Standard">
<table>
<tr>
<td align="left" valign="top">
<tt>IRETURN</tt>, <tt>LRETURN</tt>, <tt>FRETURN</tt>, <tt>DRETURN </tt>
</td>
<td align="left" valign="top">
... , a
</td>
<td align="left" valign="top" style="width: 1cm;">
 
</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ARETURN</tt>
</td>
<td align="left" valign="top">
... , o
</td>
<td align="left" valign="top" style="width: 1cm;">

</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>RETURN</tt>
</td>
<td align="left" valign="top">
...
</td>
<td align="left" valign="top" style="width: 1cm;">

</td>

</tr>
<tr>
<td align="left" valign="top">
<tt>ATHROW</tt>
</td>
<td align="left" valign="top">
... , o
</td>
<td align="left" valign="top" style="width: 1cm;">

</td>

</tr>

</table>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-11.2">11.2</a> Subroutines<a class="Label" name="sec:Subroutines"> </a>
</h2>
<div class="Standard">
In addition two the bytecode instructions presented in the previous section, classes whose version is <i>lower</i> than or equal to <tt>V1_5</tt> can also contain the <tt>JSR</tt> and <tt>RET</tt> instructions, used for subroutines (<tt>JSR</tt> means Jump to SubRoutine, and <tt>RET</tt> means RETurn from subroutine). Classes whose version is higher than or equal to <tt>V1_6</tt> must <i>not</i> contain these instructions (they have been removed to simplify the new verifier architecture introduced in Java 6; this was possible because they are not strictly necessary).
</div>
<div class="Standard">
The <tt>JSR</tt> instruction takes a label as argument, and jumps unconditionaly to this label. Before doing so however, it pushes on the operand stack a <i>return address</i>, which is the index of the instruction just after the <tt>JSR</tt>. This return address can be manipulated only by the stack instructions such as <tt>POP</tt>, <tt>DUP</tt> or <tt>SWAP</tt>, by the <tt>ASTORE</tt> instruction, and by the <tt>RET</tt> instruction.
</div>
<div class="Standard">
The <tt>RET</tt> instruction takes a local variable index as argument. It loads the return address contained in this slot and jumps unconditionaly to the corresponding instruction. Since the return address can have several possible values, a <tt>RET</tt> instruction can return to several possible instructions.
</div>
<div class="Standard">
Let’s take an example to illustrate this. Consider the following code:
</div>
<pre class="LyX-Code">
  JSR <i>sub</i>
  JSR <i>sub</i>
  RETURN
<i>sub</i>:
  ASTORE 1
  IINC 0 1
  RET 1
</pre>
<div class="Standard">
The first instruction pushes as return address the index of the second instruction, and jumps to the <tt>ASTORE</tt> instruction. This instruction stores the return address in local variable 1. Then local variable 0 is incremented by one. Finally the RET instruction loads the return address contained in local variable 1 and jumps to the corresponding instruction, <i>i.e.</i>, the second instruction.
</div>
<div class="Standard">
This second instruction is again a <tt>JSR</tt> instruction: it pushes as return address the index of the third instruction, and jumps to the <tt>ASTORE</tt> instruction. When the <tt>RET</tt> instruction is reached again the return address corresponds now to the <tt>RETURN</tt> instruction, and so execution jumps to this <tt>RETURN</tt> and stops.
</div>
<div class="Standard">
The instructions after the <tt><i>sub</i></tt> label define what is called a subroutine. It is like a little &ldquo;method&rdquo;, which can be &ldquo;called&rdquo; from different places, inside a normal method. Subroutines were used, prior to Java 6, to compile <tt>finally</tt> blocks in Java. But in fact subroutines are not strictly necessary: it is indeed possible to replace each <tt>JSR</tt> instruction with the body of the corresponding subroutine. This <i>inlining</i> produces duplicated code but removes the <tt>JSR</tt> and <tt>RET</tt> instructions. With the above example the result is very simple:
</div>
<pre class="LyX-Code">
IINC 0 1
IINC 0 1
RETURN
</pre>
<div class="Standard">
ASM provides a <tt>JSRInlinerAdapter</tt> class which can perform this transformation automatically, in the <tt>org.objectweb.asm.commons</tt> package. You can use it to remove <tt>JSR</tt> and <tt>RET</tt> instructions in order to simplify code analysis, or to transform classes from version 1.5 or less to 1.6 or higher.
</div>
<div class="Standard">
<span class="unknown">\cleardoublepage</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-11.3">11.3</a> Attributes
</h2>
<div class="Standard">
As explained in section <a class="Reference" href="#sub:Class-Structure-Overview">2.1.1↑</a>, it is possible to associate arbitrary <i>attributes</i><a class="IndexReference" name="entry-attributes-1" href="#index-attributes">↓</a> to classes, fields and methods. This extensibility mechanism is very useful to extend the class file format when new features are introduced. For example it has been used to extend this format in order to support annotations, generics, stack map frames, etc. This mechanism can also be used by users, as opposed to Sun, but since the introduction of annotations in Java 5, <i>it is much easier to use annotations than attributes</i>. That being said, if you <i>really</i> need to use your own attributes, or if you must manage non standard attributes defined by others, this can be done in ASM with the <tt>Attribute</tt> class.
</div>
<div class="Standard">
By default, the <tt>ClassReader</tt> class creates an <tt>Attribute</tt> instance for each non standard attribute it finds, and calls the <tt>visitAttribute</tt> method (of the <tt>ClassVisitor</tt>, <tt>FieldVisitor</tt> or <tt>MethodVisitor</tt> class, depending on the context) with this instance as argument. This instance contains the raw content of the attribute, in the form of a private byte array. The <tt>ClassWriter</tt> class, when visiting such unknow attributes, just copies this raw byte array in the class it constructs. <i>This default behavior is safe only if the optimization described in section</i> <a class="Reference" href="#sub:Transforming-classes-CoreAPI">2.2.4↑</a> <i>is used</i> (this gives another reason to use this optimization, besides the performance gain). Without this option the raw content may become inconsistent with the new constant pool created by the class writer, resulting in a corrupted class file.
</div>
<div class="Standard">
By default non standard attributes are therefore copied as is in transformed classes, and their content is completely opaque to ASM and to users. If you need access to this content, you must first define an <tt>Attribute</tt> sub class that is able to decode the raw content, and to reencode it. You must also pass a prototype instance of this class in the <tt>ClassReader.accept</tt> method, so that this class can decode attributes of this type. Let’s take an example to illustrate this. The following class can be used to support an imaginary &ldquo;Comment&rdquo; attribute, whose raw content is a <tt>short</tt> value that references an UTF8 string stored in the constant pool:
</div>
<pre class="LyX-Code">
class CommentAttribute extends Attribute {
  private String comment;
  public CommentAttribute(final String comment) {
    super("Comment");
    this.comment = comment;
  }
  public String getComment() {
    return comment;
  }
  @Override 
  public boolean isUnknown() {
    return false;
  }
  @Override 
 <b> protected Attribute read(ClassReader cr, int off, int len,</b>
 <b>     char[] buf, int codeOff, Label[] labels) {</b>
 <b>   return new CommentAttribute(cr.readUTF8(off, buf));</b>
 <b> }</b>
  @Override 
 <b> protected ByteVector write(ClassWriter cw, byte[] code, int len,</b>
 <b>     int maxStack, int maxLocals) {</b>
 <b>   return new ByteVector().putShort(cw.newUTF8(comment));</b>
 <b> }</b>
}
</pre>
<div class="Standard">
The most important methods are the <tt>read</tt> and <tt>write</tt> methods. The <tt>read</tt> method decodes the raw content of attributes of this type, and the <tt>write</tt> method performs the inverse operation. Note that the <tt>read</tt> method must return a <i>new</i> attribute instance. In order to decode attributes of this type when reading a class, you must use:
</div>
<pre class="LyX-Code">
ClassReader cr = ...;
ClassVisitor cv = ...;
cr.accept(cv, new Attribute[] { new CommentAttribute("") }, 0);
</pre>
<div class="Standard">
The &ldquo;Comment&rdquo; attributes will then be recognized, and a <tt>CommentAttribute</tt> instance will be created for each of them (while unknown ones continue to be represented by <tt>Attribute</tt> instances).
</div>
<div class="Standard">
<span class="unknown">\cleardoublepage</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-11.4">11.4</a> Guidelines
</h2>
<div class="Standard">
We recall here the guidelines that must be followed in order to ensure that your code will be backward compatible with older ASM versions (see chapters <a class="Reference" href="#chap:Backward-compatibility">5↑</a> and <a class="Reference" href="#chap:Backward-compatibility2">10↑</a>).
</div>
<div class="Description">
<span class="Description-entry">Guideline 1:</span> to write a <tt>ClassVisitor</tt> subclass for ASM version <i>X</i>, call the <tt>ClassVisitor</tt> constructor with this exact version as argument, and <i>never override or call methods that are deprecated</i> in this version of the <tt>ClassVisitor</tt> class (or that are introduced in later versions).
</div>
<div class="Description">
<span class="Description-entry">Guideline 2:</span> do not use inheritance of visitors, use delegation instead (i.e. visitor chains). A good practice is to make your visitor classes final by default to ensure this.
</div>
<div class="Description">
<span class="Description-entry">Guideline 3:</span> to write a class analyzer or adapter with the tree API of ASM version <i>X</i>, create your <tt>ClassNode</tt> by using the constructor with this exact version as argument (as opposed to the default constructor, without parameters).
</div>
<div class="Description">
<span class="Description-entry">Guideline 4:</span> to write a class analyzer or adapter with the tree API of ASM version <i>X</i>, using a <tt>ClassNode</tt> created by someone else, call its <tt>check()</tt> method with this exact version as argument before using the <tt>ClassNode</tt> in any way.
</div>
<div class="Standard">
Guidelines 1 and 2 also apply for subclasses of <tt>ClassNode</tt>, <tt>MethodNode</tt>, etc, of <tt>Interpreter</tt> and its subclasses in <tt>asm.tree.analysis</tt>, of the <tt>ASMifier</tt>, <tt>Texifier</tt>, or <tt>Check<i>Xxx</i>Adapter</tt> classes in <tt>asm.util</tt>, and of any class in the <tt>asm.commons</tt> package. Finally, there are two exceptions to guideline 2:
</div>
<ul>
<li>
you can use inheritance of visitors if you fully control the inheritance chain yourself, and release all the classes of the hierarchy at the same time. You must then ensure that all the classes in the hierarchy are written for the same ASM version. Still, make the leaf classes of your hierarchy final.
</li>
<li>
you can use inheritance of &ldquo;visitors&rdquo; if no class except the leaf ones override any visit method (for instance, if you use intermediate classes between <tt>ClassVisitor</tt> and the concrete visitor classes only to introduce convenience methods). Still, make the leaf classes of your hierarchy final (unless they do not override any visit method either; in this case provide a constructor taking an ASM version as argument so that subclasses can specify for which version they are written).
</li>

</ul>
<div class="Standard">
<span class="unknown">\cleardoublepage</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-11.5">11.5</a> Performances
</h2>
<div class="Standard">
The figure below gives the relative performances of the core and tree APIs, of the <tt>ClassWriter</tt> options, and of the analysis framework (shorter is faster): 
</div>
<div class="Standard">
<div class="center">
<img class="embedded" src="figures/perfs.png" alt="figure figures/perfs.png" style="max-width: 455px; max-height: 420px;"/>

</div>

</div>
<div class="Standard">
The reference time 100 corresponds to a <tt>ClassReader</tt> chained directly to a <tt>ClassWriter</tt>. The &ldquo;add timer&rdquo; and &ldquo;remove sequence&rdquo; tests correspond to <tt>AddTimerAdapter</tt> and <tt>RemoveGetFieldPutFieldAdapter</tt> (<i>italic</i> means that the optimization described in section <a class="Reference" href="#sub:Transforming-classes-CoreAPI">2.2.4↑</a> is used, <b>bold</b> means that the tree API is used). The total transformation time is decomposed into three parts: class parsing (bottom), class transformation or analysis (middle) and class writing (top). For each test the measured value is the time needed to parse, transform and write a <i>byte array</i>, <i>i.e.</i>, the time needed to load classes from disk and to load them inside the JVM is <i>not</i> taken into account. The results were obtained by running each test ten times, on the 18600+ classes of JDK 7 <tt>rt.jar</tt>, and by using the performance of the best run.
</div>
<div class="Standard">
A quick analysis of these results shows that:
</div>
<ul>
<li>
90% of the transformation time is due to class parsing and writing.
</li>
<li>
The &ldquo;copy constant pool&rdquo; optimization gives a 15-20% speed up.
</li>
<li>
Tree based transformations are about 25% slower than visitor based ones.
</li>
<li>
The <tt>COMPUTE_MAXS</tt> option does not cost too much.
</li>
<li>
The <tt>COMPUTE_FRAMES</tt> option costs a lot <span class="formula"> ⇒ </span> do incremental frame updates.
</li>
<li>
The cost of the analysis package is quite high!
</li>

</ul>
<div class="Standard">
<span class="unknown">\clearpage</span>
</div>
<a class="toc" name="Index"></a><h1 class="index">Index</h1><p class="printindex">
<a class="printindex" name="index-ASMifier_"></a>ASMifier@: <a class="IndexArrow" href="#entry-ASMifier_-0">↑</a>, <a class="IndexArrow" href="#entry-ASMifier_-1">↑</a>, <a class="IndexArrow" href="#entry-ASMifier_-2">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-AbstractInsnNode_"></a>AbstractInsnNode@: <a class="IndexArrow" href="#entry-AbstractInsnNode_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-AdviceAdapter_"></a>AdviceAdapter@: <a class="IndexArrow" href="#entry-AdviceAdapter_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Analyzer_"></a>Analyzer@: <a class="IndexArrow" href="#entry-Analyzer_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-AnalyzerAdapter_"></a>AnalyzerAdapter@: <a class="IndexArrow" href="#entry-AnalyzerAdapter_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-AnnotationNode_"></a>AnnotationNode@: <a class="IndexArrow" href="#entry-AnnotationNode_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-AnnotationVisitor_"></a>AnnotationVisitor@: <a class="IndexArrow" href="#entry-AnnotationVisitor_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-BasicInterpreter_"></a>BasicInterpreter@: <a class="IndexArrow" href="#entry-BasicInterpreter_-0">↑</a>, <a class="IndexArrow" href="#entry-BasicInterpreter_-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-BasicVerifier_"></a>BasicVerifier@: <a class="IndexArrow" href="#entry-BasicVerifier_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-CheckClassAdapter_"></a>CheckClassAdapter@: <a class="IndexArrow" href="#entry-CheckClassAdapter_-0">↑</a>, <a class="IndexArrow" href="#entry-CheckClassAdapter_-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-CheckMethodAdapter_"></a>CheckMethodAdapter@: <a class="IndexArrow" href="#entry-CheckMethodAdapter_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-ClassNode_"></a>ClassNode@: <a class="IndexArrow" href="#entry-ClassNode_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-ClassReader_"></a>ClassReader@: <a class="IndexArrow" href="#entry-ClassReader_-0">↑</a>, <a class="IndexArrow" href="#entry-ClassReader_-1">↑</a>, <a class="IndexArrow" href="#entry-ClassReader_-2">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-ClassTransformer_"></a>ClassTransformer@: <a class="IndexArrow" href="#entry-ClassTransformer_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-ClassVisitor_"></a>ClassVisitor@: <a class="IndexArrow" href="#entry-ClassVisitor_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-ClassWriter_"></a>ClassWriter@: <a class="IndexArrow" href="#entry-ClassWriter_-0">↑</a>, <a class="IndexArrow" href="#entry-ClassWriter_-1">↑</a>, <a class="IndexArrow" href="#entry-ClassWriter_-2">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-FieldNode_"></a>FieldNode@: <a class="IndexArrow" href="#entry-FieldNode_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-FieldVisitor_"></a>FieldVisitor@: <a class="IndexArrow" href="#entry-FieldVisitor_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Frame_"></a>Frame@: <a class="IndexArrow" href="#entry-Frame_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-InsnList_"></a>InsnList@: <a class="IndexArrow" href="#entry-InsnList_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Interpreter_"></a>Interpreter@: <a class="IndexArrow" href="#entry-Interpreter_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Label_"></a>Label@: <a class="IndexArrow" href="#entry-Label_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-LocalVariablesSorter_"></a>LocalVariablesSorter@: <a class="IndexArrow" href="#entry-LocalVariablesSorter_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-MethodNode_"></a>MethodNode@: <a class="IndexArrow" href="#entry-MethodNode_-0">↑</a>, <a class="IndexArrow" href="#entry-MethodNode_-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-MethodVisitor_"></a>MethodVisitor@: <a class="IndexArrow" href="#entry-MethodVisitor_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Opcodes_"></a>Opcodes@: <a class="IndexArrow" href="#entry-Opcodes_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-PatternMethodAdapter_"></a>PatternMethodAdapter@: <a class="IndexArrow" href="#entry-PatternMethodAdapter_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-SignatureReader_"></a>SignatureReader@: <a class="IndexArrow" href="#entry-SignatureReader_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-SignatureVisitor_"></a>SignatureVisitor@: <a class="IndexArrow" href="#entry-SignatureVisitor_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-SignatureWriter_"></a>SignatureWriter@: <a class="IndexArrow" href="#entry-SignatureWriter_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-SimpleVerifier_"></a>SimpleVerifier@: <a class="IndexArrow" href="#entry-SimpleVerifier_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-TraceClassVisitor_"></a>TraceClassVisitor@: <a class="IndexArrow" href="#entry-TraceClassVisitor_-0">↑</a>, <a class="IndexArrow" href="#entry-TraceClassVisitor_-1">↑</a>, <a class="IndexArrow" href="#entry-TraceClassVisitor_-2">↑</a>, <a class="IndexArrow" href="#entry-TraceClassVisitor_-3">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-TraceMethodVisitor_"></a>TraceMethodVisitor@: <a class="IndexArrow" href="#entry-TraceMethodVisitor_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Type_"></a>Type@: <a class="IndexArrow" href="#entry-Type_-0">↑</a>, <a class="IndexArrow" href="#entry-Type_-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Value_"></a>Value@: <a class="IndexArrow" href="#entry-Value_-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-annotations"></a>annotations: <a class="IndexArrow" href="#entry-annotations-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-annotations-adding"></a>adding: <a class="IndexArrow" href="#entry-annotations-adding-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-annotations-detecting"></a>detecting: <a class="IndexArrow" href="#entry-annotations-detecting-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-attributes"></a>attributes: <a class="IndexArrow" href="#entry-attributes-0">↑</a>, <a class="IndexArrow" href="#entry-attributes-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-basic-block"></a>basic block: <a class="IndexArrow" href="#entry-basic-block-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-bytecode-instruction"></a>bytecode instruction: <a class="IndexArrow" href="#entry-bytecode-instruction-0">↑</a>, <a class="IndexArrow" href="#entry-bytecode-instruction-1">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-bytecode-instruction-arguments"></a>arguments: <a class="IndexArrow" href="#entry-bytecode-instruction-arguments-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-bytecode-instruction-opcode"></a>opcode: <a class="IndexArrow" href="#entry-bytecode-instruction-opcode-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-bytecode-instruction-operands"></a>operands: <a class="IndexArrow" href="#entry-bytecode-instruction-operands-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-class-signature"></a>class signature: <a class="IndexArrow" href="#entry-class-signature-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes"></a>classes: 
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-classes-adding-members"></a>adding members: <a class="IndexArrow" href="#entry-classes-adding-members-0">↑</a>, <a class="IndexArrow" href="#entry-classes-adding-members-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-checking"></a>checking: <a class="IndexArrow" href="#entry-classes-checking-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-core-API"></a>core API: <a class="IndexArrow" href="#entry-classes-core-API-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-event-based-representation"></a>event based representation: <a class="IndexArrow" href="#entry-classes-event-based-representation-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-generating"></a>generating: <a class="IndexArrow" href="#entry-classes-generating-0">↑</a>, <a class="IndexArrow" href="#entry-classes-generating-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-loading"></a>loading: <a class="IndexArrow" href="#entry-classes-loading-0">↑</a>, <a class="IndexArrow" href="#entry-classes-loading-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-object-based-representation"></a>object based representation: <a class="IndexArrow" href="#entry-classes-object-based-representation-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-overall-structure"></a>overall structure: <a class="IndexArrow" href="#entry-classes-overall-structure-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-parsing"></a>parsing: <a class="IndexArrow" href="#entry-classes-parsing-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-printing"></a>printing: <a class="IndexArrow" href="#entry-classes-printing-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-removing-members"></a>removing members: <a class="IndexArrow" href="#entry-classes-removing-members-0">↑</a>, <a class="IndexArrow" href="#entry-classes-removing-members-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-textual-representation"></a>textual representation: <a class="IndexArrow" href="#entry-classes-textual-representation-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-classes-transforming"></a>transforming: <a class="IndexArrow" href="#entry-classes-transforming-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-constant-pool"></a>constant pool: <a class="IndexArrow" href="#entry-constant-pool-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-constructors"></a>constructors: <a class="IndexArrow" href="#entry-constructors-0">↑</a>, <a class="IndexArrow" href="#entry-constructors-1">↑</a>, <a class="IndexArrow" href="#entry-constructors-2">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-control-flow-analysis"></a>control flow analysis: <a class="IndexArrow" href="#entry-control-flow-analysis-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-control-flow-graph"></a>control flow graph: <a class="IndexArrow" href="#entry-control-flow-graph-0">↑</a>, <a class="IndexArrow" href="#entry-control-flow-graph-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-core-API"></a>core API: <a class="IndexArrow" href="#entry-core-API-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-data-flow-analysis"></a>data flow analysis: <a class="IndexArrow" href="#entry-data-flow-analysis-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-dead-code"></a>dead code: <a class="IndexArrow" href="#entry-dead-code-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-dead-code-removing"></a>removing: <a class="IndexArrow" href="#entry-dead-code-removing-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-exceptions"></a>exceptions: 
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-exceptions-declaration"></a>declaration: <a class="IndexArrow" href="#entry-exceptions-declaration-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-exceptions-handlers"></a>handlers: <a class="IndexArrow" href="#entry-exceptions-handlers-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-execution-frame"></a>execution frame: <a class="IndexArrow" href="#entry-execution-frame-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-execution-stack"></a>execution stack: <a class="IndexArrow" href="#entry-execution-stack-0">↑</a>, <a class="IndexArrow" href="#entry-execution-stack-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-fields"></a>fields: 
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-fields-adding"></a>adding: <a class="IndexArrow" href="#entry-fields-adding-0">↑</a>, <a class="IndexArrow" href="#entry-fields-adding-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-fields-constant-value"></a>constant value: <a class="IndexArrow" href="#entry-fields-constant-value-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-fields-removing"></a>removing: <a class="IndexArrow" href="#entry-fields-removing-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-frames"></a>frames: <a class="IndexArrow" href="#entry-frames-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-frames-compression"></a>compression: <a class="IndexArrow" href="#entry-frames-compression-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-frames-computing"></a>computing: <a class="IndexArrow" href="#entry-frames-computing-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-frames-skipping"></a>skipping: <a class="IndexArrow" href="#entry-frames-skipping-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-frames-uncompressing"></a>uncompressing: <a class="IndexArrow" href="#entry-frames-uncompressing-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-frames-updating"></a>updating: <a class="IndexArrow" href="#entry-frames-updating-0">↑</a>, <a class="IndexArrow" href="#entry-frames-updating-1">↑</a>, <a class="IndexArrow" href="#entry-frames-updating-2">↑</a>, <a class="IndexArrow" href="#entry-frames-updating-3">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-generic-classes"></a>generic classes: <a class="IndexArrow" href="#entry-generic-classes-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-internal-name"></a>internal name: <a class="IndexArrow" href="#entry-internal-name-0">↑</a>, <a class="IndexArrow" href="#entry-internal-name-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-label"></a>label: <a class="IndexArrow" href="#entry-label-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-local-variables"></a>local variables: <a class="IndexArrow" href="#entry-local-variables-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-local-variables-computing-number-of"></a>computing number of: <a class="IndexArrow" href="#entry-local-variables-computing-number-of-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-local-variables-inserting"></a>inserting: <a class="IndexArrow" href="#entry-local-variables-inserting-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-local-variables-renumbering"></a>renumbering: <a class="IndexArrow" href="#entry-local-variables-renumbering-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-local-variables-size"></a>size: <a class="IndexArrow" href="#entry-local-variables-size-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-method-descriptor"></a>method descriptor: <a class="IndexArrow" href="#entry-method-descriptor-0">↑</a>, <a class="IndexArrow" href="#entry-method-descriptor-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-method-signature"></a>method signature: <a class="IndexArrow" href="#entry-method-signature-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-methods"></a>methods: 
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-methods-generating"></a>generating: <a class="IndexArrow" href="#entry-methods-generating-0">↑</a>, <a class="IndexArrow" href="#entry-methods-generating-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-methods-removing"></a>removing: <a class="IndexArrow" href="#entry-methods-removing-0">↑</a>, <a class="IndexArrow" href="#entry-methods-removing-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-methods-structure"></a>structure: <a class="IndexArrow" href="#entry-methods-structure-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-methods-transforming"></a>transforming: <a class="IndexArrow" href="#entry-methods-transforming-0">↑</a>, <a class="IndexArrow" href="#entry-methods-transforming-1">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-opcode"></a>opcode: <a class="IndexArrow" href="#entry-opcode-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-operand"></a>operand: <a class="IndexArrow" href="#entry-operand-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-operand-stack"></a>operand stack: <a class="IndexArrow" href="#entry-operand-stack-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-operand-stack-size"></a>size: <a class="IndexArrow" href="#entry-operand-stack-size-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-operand-stack-updating-size"></a>updating size: <a class="IndexArrow" href="#entry-operand-stack-updating-size-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-signature"></a>signature: <a class="IndexArrow" href="#entry-signature-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-static-blocks"></a>static blocks: <a class="IndexArrow" href="#entry-static-blocks-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-transformation-chain"></a>transformation chain: <a class="IndexArrow" href="#entry-transformation-chain-0">↑</a>, <a class="IndexArrow" href="#entry-transformation-chain-1">↑</a>, <a class="IndexArrow" href="#entry-transformation-chain-2">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-transformation-pass"></a>transformation pass: <a class="IndexArrow" href="#entry-transformation-pass-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-tree-API"></a>tree API: <a class="IndexArrow" href="#entry-tree-API-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-type-descriptor"></a>type descriptor: <a class="IndexArrow" href="#entry-type-descriptor-0">↑</a>, <a class="IndexArrow" href="#entry-type-descriptor-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-type-signature"></a>type signature: <a class="IndexArrow" href="#entry-type-signature-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-unreachable-code"></a>unreachable code: <a class="IndexArrow" href="#entry-unreachable-code-0">↑</a>
</p>

</div>
</body>
</html>
